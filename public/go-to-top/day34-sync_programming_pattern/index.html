<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Go 翻山越岭——并发编程模式 | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/day34-sync_programming_pattern/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Go 翻山越岭——并发编程模式" />
<meta property="og:description" content="通常我们在写 Go 代码的时候，听得比较多的是 Go 和传统并发模式不一样。Go 语言采用的是 CSP 模式，即 &ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&rdquo;
这句英文看起来有些玄乎，但其实是在说，除了 runtime 中的 hchan 结构，没有其他结构能够共享内存。而如果我们想要共享数据的话，就需要 chan 去做任务发送，这时候做的其实是一些拷贝的工作。听起来有点抽象，来看一些别人写的代码示例。
第一个例子 Fan-in 扇入，也就是多个分支合并为一个分支，或合并为少数的分支。
这里的代码意思是要把多个 channel 的结果合并到同一个 channel 中去，这样消费者只用去消费一个就好了。函数中第一行是通过判断输入的 channel 数组的长度来实现的：
 如果是 0，说明递归结束直接返回； 如果是 1，就返回当前的 channel； 如果是 2，就需要调用 mergeTwo 函数。这个 mergeTwo 函数也就是简单的 for 循环 &#43; select 结合来实现的。 最后 default，就是不断对 channel 的长度除 2 ，然后递归地调用 mergeTwo 最终来实现。  一般情况下，我们要合并 channel 的话，数量不会很多几百上千个，常见的是 5-6 个。并且更加实际环境中，每个 channel 还有其具体的名字的，也就只需要写一个 select 就可以了，不用像以上代码中不定长的 channel 实现方式要简单得多。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/day34-sync_programming_pattern/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-12-03T20:32:49+08:00" />
<meta property="article:modified_time" content="2021-12-03T20:32:49+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 翻山越岭——并发编程模式"/>
<meta name="twitter:description" content="通常我们在写 Go 代码的时候，听得比较多的是 Go 和传统并发模式不一样。Go 语言采用的是 CSP 模式，即 &ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&rdquo;
这句英文看起来有些玄乎，但其实是在说，除了 runtime 中的 hchan 结构，没有其他结构能够共享内存。而如果我们想要共享数据的话，就需要 chan 去做任务发送，这时候做的其实是一些拷贝的工作。听起来有点抽象，来看一些别人写的代码示例。
第一个例子 Fan-in 扇入，也就是多个分支合并为一个分支，或合并为少数的分支。
这里的代码意思是要把多个 channel 的结果合并到同一个 channel 中去，这样消费者只用去消费一个就好了。函数中第一行是通过判断输入的 channel 数组的长度来实现的：
 如果是 0，说明递归结束直接返回； 如果是 1，就返回当前的 channel； 如果是 2，就需要调用 mergeTwo 函数。这个 mergeTwo 函数也就是简单的 for 循环 &#43; select 结合来实现的。 最后 default，就是不断对 channel 的长度除 2 ，然后递归地调用 mergeTwo 最终来实现。  一般情况下，我们要合并 channel 的话，数量不会很多几百上千个，常见的是 5-6 个。并且更加实际环境中，每个 channel 还有其具体的名字的，也就只需要写一个 select 就可以了，不用像以上代码中不定长的 channel 实现方式要简单得多。"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/go-to-top">Go 语言系列</a></li>
      
        <li><a href="/posts">杂谈</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于我</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>通常我们在写 Go 代码的时候，听得比较多的是 Go 和传统并发模式不一样。Go 语言采用的是 CSP 模式，即 &ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&rdquo;</p>
<p>这句英文看起来有些玄乎，但其实是在说，除了 runtime 中的 hchan 结构，没有其他结构能够共享内存。而如果我们想要共享数据的话，就需要 chan 去做任务发送，这时候做的其实是一些拷贝的工作。听起来有点抽象，来看一些别人写的代码示例。</p>
<p>第一个例子 Fan-in 扇入，也就是多个分支合并为一个分支，或合并为少数的分支。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112032304677.png" alt="image-20211203230406497"></p>
<!-- raw HTML omitted -->
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112032309871.png" alt="image-20211203230942784"></p>
<!-- raw HTML omitted -->
<p>这里的代码意思是要把多个 channel 的结果合并到同一个 channel 中去，这样消费者只用去消费一个就好了。函数中第一行是通过判断输入的 channel 数组的长度来实现的：</p>
<ul>
<li>如果是 0，说明递归结束直接返回；</li>
<li>如果是 1，就返回当前的 channel；</li>
<li>如果是 2，就需要调用 mergeTwo 函数。这个 mergeTwo 函数也就是简单的 for 循环 + select 结合来实现的。</li>
<li>最后 default，就是不断对 channel 的长度除 2 ，然后递归地调用 mergeTwo 最终来实现。</li>
</ul>
<p>一般情况下，我们要合并 channel 的话，数量不会很多几百上千个，常见的是 5-6 个。并且更加实际环境中，每个 channel 还有其具体的名字的，也就只需要写一个 select 就可以了，不用像以上代码中不定长的 channel 实现方式要简单得多。</p>
<p>第二个例子 Or channel，意思是说有多个 channel，其中一个有结果的时候，不管其他 channel 的结果，直接把整体的结果返回。这个一般是在有多个后端向前端响应结果，并且一旦有个后端返回了就不用等另外个后端返回的场景下去用，也就是通过用更多资源的方式来降低延时、提升用户的体验。Or channel 的实现和这种实现类似，代码如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112032317626.png" alt="image-20211203231732542"></p>
<!-- raw HTML omitted -->
<p>这个代码的逻辑稍微复杂，具体是这样的：</p>
<ul>
<li>如果当前 channel 数组的长度为 0，直接返回空；</li>
<li>如果是 1，就返回当前的 channel；</li>
<li>如果是 2，就用 select 和两个 case 就解决了。</li>
<li>如果是 3个以上多个 channel，就采用 select 的  0、1、2 case，其他的就递归去调用 or 函数来实现。</li>
</ul>
<p>以上代码也是《Concurrency in Go》书中的代码，也建议大家通过抄一下去学习。</p>
<p>第三个例子，将 channel 串联起来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112032327076.png" alt="image-20211203232747010"></p>
<!-- raw HTML omitted -->
<p>这个代码中逻辑比较简单，也就是一个 channel 收到了然后做一些处理，然后做些处理，然后再发往下一个 channel。这种例子一般用于上下游的数据处理，通过将 channel 串联起来，解决速度不匹配的问题。</p>
<p>第四个例子，是由 PingCap 工程师分享的案例：想要通过 Goroutine 并发去提升请求的性能，但是在业务场景下，需要按照顺序，把数据处理后返回给用户。所以既要通过并发提升性能，又能够保证返回的顺序性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112032328302.png" alt="image-20211203232839228"></p>
<!-- raw HTML omitted -->
<p>这个代码逻辑如下：</p>
<ul>
<li>用户提供了一个 task 任务，按照用户提供的 task 顺序分别发送了两个目标：一个是并发执行任务的 worker，另一个是保证顺序的函数。
<ul>
<li>这里保证顺序的函数可以任意去实现，如数组或链表都是可以的，只要保证最后在消费的时候，是从这个保证顺序的列表或 channel 去消费就 OK 的。</li>
</ul>
</li>
<li>在进行消费的时候 fifo，每次消费一个元素，就执行 t.wait，也就是上方的 sync.WaitGroup。
<ul>
<li>worker 函数中，每次执行完成任务之后执行 t.Done 就 OK。</li>
</ul>
</li>
</ul>
<p>这个例子比较好玩，网上别人也很少讲到。</p>
<p>OK，其实以上的例子与代码大部分都来自于《Concurrency in Go》和鸟窝在 Gopher China 分享的内容，比较多，这里给一下地址插个眼：</p>
<p>[1]《 Concurrency in Go》.pdf</p>
<p><a href="https://github.com/chapin666/books/blob/master/golang/Concurrency-in-Go.pdf">https://github.com/chapin666/books/blob/master/golang/Concurrency-in-Go.pdf</a></p>
<p>[2]《 Concurrency in Go-中文版》.pdf</p>
<p>[https://github.com/hapi666/GOBook/blob/master/Concurrency%20in%20Go%E4%B8%AD%E6%96%87%E7%89%88.pdf](<a href="https://github.com/hapi666/GOBook/blob/master/Concurrency">https://github.com/hapi666/GOBook/blob/master/Concurrency</a> in Go中文版.pdf)</p>
<p>[3] 《Go并发编程实践》博客总结，鸟窝，</p>
<p><a href="https://colobu.com/2019/04/28/gopher-2019-concurrent-in-action/">https://colobu.com/2019/04/28/gopher-2019-concurrent-in-action/</a></p>
<p>OK，下期文章继续总结一下常见的并发 Bug，让我们防患于未然。</p>

  

  </div>
</article>
  
  













  
  
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
            repo= "JupiterXue/BlogComment"
            issue-term="title"
            theme="github-light"
    crossorigin="anonymous"
    async>
    </script>
  </div>
  




    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/go-to-top">Go 语言系列</a></li>
         
        <li><a href="/posts">杂谈</a></li>
         
        <li><a href="/tags">标签</a></li>
         
        <li><a href="/about">关于我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
