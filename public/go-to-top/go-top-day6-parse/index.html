<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Go 翻山越岭——编译原理基础 | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/go-top-day6-parse/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Go 翻山越岭——编译原理基础" />
<meta property="og:description" content="上回我们说到 8 个常见 Go 业务场景，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础”
回顾 Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，我们可以通过这句代码，编译一段简单的 “Hello World！” 程序看到：
1go build -x hello.go 编译原理基础 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &#34;fmt&#34; 4 5func main() { 6 println(1 &#43; 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &#34;fmt&#34; 4 5func main() { 6 var x int = &#34;abc&#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &ldquo;abc&rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/go-top-day6-parse/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-08-15T09:38:51+08:00" />
<meta property="article:modified_time" content="2021-08-15T09:38:51+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 翻山越岭——编译原理基础"/>
<meta name="twitter:description" content="上回我们说到 8 个常见 Go 业务场景，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础”
回顾 Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，我们可以通过这句代码，编译一段简单的 “Hello World！” 程序看到：
1go build -x hello.go 编译原理基础 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &#34;fmt&#34; 4 5func main() { 6 println(1 &#43; 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &#34;fmt&#34; 4 5func main() { 6 var x int = &#34;abc&#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &ldquo;abc&rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题："/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/posts">文章</a></li>
      
        <li><a href="/tags">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>上回我们说到 <strong>8 个常见 Go 业务场景</strong>，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础”</p>
<h1 id="回顾">回顾</h1>
<p>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，我们可以通过这句代码，编译一段简单的 “Hello World！” 程序看到：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>go build -x hello.go
</code></pre></div><h1 id="编译原理基础">编译原理基础</h1>
<p>我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）</p>
<p><img src="C:%5CUsers%5CXfavor%5CDesktop%5C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt="编译过程"></p>
<p>**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>    println(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>}
</code></pre></div><p>我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：</p>
<p><img src="C:%5CUsers%5CXfavor%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210815232014055.png" alt="image-20210815232014055"></p>
<p>我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。</p>
<p><strong>语法分析</strong>（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。</p>
<p><strong>抽象语法树</strong>（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。</p>
<p>这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：</p>
<p><img src="C:%5CUsers%5CXfavor%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210815233646288.png" alt="image-20210815233646288"></p>
<p>左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）</p>
<p><strong>语义分析</strong>（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span> = <span style="color:#e6db74">&#34;abc&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>    println(<span style="color:#a6e22e">x</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span>}
</code></pre></div><p>作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &ldquo;abc&rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：</p>
<p><img src="C:%5CUsers%5CXfavor%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210815234112649.png" alt="image-20210815234112649"></p>
<p>这个过程往往是在抽象语法树 AST 上做类型检查，不让你执行成功。</p>
<p>我们有了 AST 以后，要转换为汇编，还是不可以，还需要经过两步：中间代码（SSA）的生成与优化。</p>
<p>SSA（Single Static Assignment） 即静态单赋值，是一种中间表示形式。 之所以称之为单赋值，是因为每个名字在SSA中仅被赋值一次.</p>
<p>SSA是一种高效的数据流分析技术，目前几乎所有的现代编译器。其两大特点是：</p>
<ol>
<li>Static：每个变量只能赋值一次（因此应该叫做常理更合适）；</li>
<li>Single：每个表达式只能做一个简单运算，对于复杂的表达式要做拆分。</li>
</ol>
<p>我们有个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span><span style="color:#f92672">*</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span><span style="color:#f92672">*</span><span style="color:#a6e22e">c</span> <span style="color:#75715e">// 这句代码不能直接转化为汇编
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#75715e"></span>}
</code></pre></div><p>我们来手动做一次简化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>    <span style="color:#a6e22e">t0</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>    <span style="color:#a6e22e">t1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">c</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>    <span style="color:#a6e22e">t2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t0</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">t1</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">t2</span> <span style="color:#75715e">// 这个就能直接转化为汇编
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#75715e"></span>}
</code></pre></div><p>手动当然不现实，那么我们有什么方法能实现自动转 SSA 呢？</p>
<ol>
<li>在线查看 SSA 过程https://golang.design/gossa</li>
<li>GOSSAFUNC=funcname go build x.go</li>
</ol>
<p>OK，以上的编译原理是不是有点头大？从源代码到汇编，我们需要这么多过程，那么有没有什么工具能够直接从 Go 源代码到汇编呢？当然，也有：看好我施展魔法啦：https://godbolt.org/</p>
<p><img src="C:%5CUsers%5CXfavor%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210815235150609.png" alt="image-20210815235150609"></p>
<p><strong>参考资料</strong></p>
<p>[1] 维基百科搜索关键词</p>
<p>[2] 从词法分析角度看 Go 代码的组成</p>
<p><a href="https://studygolang.com/articles/24419?fr=sidebar">https://studygolang.com/articles/24419?fr=sidebar</a></p>
<p>[3] 静态单赋值（SSA,Static Single-Assignment)</p>
<p><a href="https://blog.csdn.net/manok/article/details/89851085">https://blog.csdn.net/manok/article/details/89851085</a></p>

  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/posts">文章</a></li>
         
        <li><a href="/tags">归档</a></li>
         
        <li><a href="/about">关于</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
