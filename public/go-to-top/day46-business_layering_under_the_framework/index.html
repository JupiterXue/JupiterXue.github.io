<!DOCTYPE html>
<html lang="zh-CN"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="content-type" content="text/html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title itemprop="name">Go 翻山越岭——架构下的业务逻辑 | 木夜星空的个人博客</title>
<meta property="og:title" content="Go 翻山越岭——架构下的业务逻辑 | 木夜星空的个人博客" />
<meta name="twitter:title" content="Go 翻山越岭——架构下的业务逻辑 | 木夜星空的个人博客" />
<meta itemprop="name" content="Go 翻山越岭——架构下的业务逻辑 | 木夜星空的个人博客" />
<meta name="application-name" content="Go 翻山越岭——架构下的业务逻辑 | 木夜星空的个人博客" />
<meta property="og:site_name" content="" />

<meta name="description" content="">
<meta itemprop="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />

<meta property="og:locale" content="zh-CN" />
<meta name="language" content="zh-CN" />

  <link rel="alternate" hreflang="en" href="http://localhost:1313/go-to-top/day46-business_layering_under_the_framework/" title="" />






<meta name="generator" content="Hugo 0.135.0">

    
    <meta property="og:url" content="http://localhost:1313/go-to-top/day46-business_layering_under_the_framework/">
  <meta property="og:site_name" content="木夜星空的个人博客">
  <meta property="og:title" content="Go 翻山越岭——架构下的业务逻辑">
  <meta property="og:description" content="在我们互联网公司中都会有一类工程师叫做，架构师。他们经常会去参加一些架构师大会。在他们的圈子中也会有一些黑话，我们一般的程序员是听不懂的，因此就需要我们在写代码的同时，去学习一些相关的理论。这些理论只是名词多，其实并不难。
因为 Go 语言主要用在做后端系统，下面说的也是 API 层面的业务分层。
传统分层 在很早的 web 项目中，都是采用的 MVC 的框架模式。
MVC 这种模式在上个世纪 70 年代就已提出，到现在一直在被使用，因此可以说使用 MVC 的 web 项目称得上远古时代。最早的 web 开发用 PHP 的比较多，而 PHP 的架构尤其以 MVC 模式比较多，Model、View、Controller 都是标准化的组件。
但是，存在一个局限性：前后端所有的代码都放在一起的。所以前端可能不那么讲究，就在 PHP 代码中做一套模板引擎，然后直接在在 Vue 里面去写渲染代码；后端的逻辑也很简单，都写在 Controller 里面。情况更糟的是，有些的公司对业务逻辑到底写在哪里还有争议，有的人写在 Model 里。
后来，当前后端分离变成主流共识之后，View 层直接被干掉了。
有一个原因在于前端和后端各自都变得比较复杂了，所以前端也要专门去做工程化了，随后有了 Angular、React、Vue 等三大知名的前端框架。
而后端将 View 拆出去以后，只剩 Model 和 Controller，不过项目也开始变得复杂，一个接口就有几千、上万行代码的情况。这种情况，如果将全部代码堆积在 Controller 里面，并且还是按照以前的编程流程，过程式开发的话，整个代码维护起来相当地费劲。
所以，大多数公司的后端会将逻辑越来越复杂的业务，拆分成单独的 logic，如下：
model 改成了 dao（data access object）。由于 model 很多时候都被当作领域模型来用，看起来里面就应该有一些逻辑。而 dao 就是仅仅作为数据获取的结构体。 controller 直接被拆分成了两部分，一部分还是叫做 controller，不过功能上更加简单，可能负责的是 API 接口的入口、协议或校验入口等。另一部分 logic ，这个在不同公司有不同的名字，可能叫做 services，都是用来写业务逻辑的。 但是，随着公司的发展，业务逻辑也在逐渐地膨胀，到后面越来越复杂。如果对 拆分后的 controller 没有指导的话，业务代码是很难管理、很难看懂维护的。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="go-to-top">
    <meta property="article:published_time" content="2021-12-30T19:36:09+08:00">
    <meta property="article:modified_time" content="2021-12-30T19:36:09+08:00">
    <meta property="article:tag" content="Go">


    
    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Go 翻山越岭——架构下的业务逻辑">
  <meta name="twitter:description" content="在我们互联网公司中都会有一类工程师叫做，架构师。他们经常会去参加一些架构师大会。在他们的圈子中也会有一些黑话，我们一般的程序员是听不懂的，因此就需要我们在写代码的同时，去学习一些相关的理论。这些理论只是名词多，其实并不难。
因为 Go 语言主要用在做后端系统，下面说的也是 API 层面的业务分层。
传统分层 在很早的 web 项目中，都是采用的 MVC 的框架模式。
MVC 这种模式在上个世纪 70 年代就已提出，到现在一直在被使用，因此可以说使用 MVC 的 web 项目称得上远古时代。最早的 web 开发用 PHP 的比较多，而 PHP 的架构尤其以 MVC 模式比较多，Model、View、Controller 都是标准化的组件。
但是，存在一个局限性：前后端所有的代码都放在一起的。所以前端可能不那么讲究，就在 PHP 代码中做一套模板引擎，然后直接在在 Vue 里面去写渲染代码；后端的逻辑也很简单，都写在 Controller 里面。情况更糟的是，有些的公司对业务逻辑到底写在哪里还有争议，有的人写在 Model 里。
后来，当前后端分离变成主流共识之后，View 层直接被干掉了。
有一个原因在于前端和后端各自都变得比较复杂了，所以前端也要专门去做工程化了，随后有了 Angular、React、Vue 等三大知名的前端框架。
而后端将 View 拆出去以后，只剩 Model 和 Controller，不过项目也开始变得复杂，一个接口就有几千、上万行代码的情况。这种情况，如果将全部代码堆积在 Controller 里面，并且还是按照以前的编程流程，过程式开发的话，整个代码维护起来相当地费劲。
所以，大多数公司的后端会将逻辑越来越复杂的业务，拆分成单独的 logic，如下：
model 改成了 dao（data access object）。由于 model 很多时候都被当作领域模型来用，看起来里面就应该有一些逻辑。而 dao 就是仅仅作为数据获取的结构体。 controller 直接被拆分成了两部分，一部分还是叫做 controller，不过功能上更加简单，可能负责的是 API 接口的入口、协议或校验入口等。另一部分 logic ，这个在不同公司有不同的名字，可能叫做 services，都是用来写业务逻辑的。 但是，随着公司的发展，业务逻辑也在逐渐地膨胀，到后面越来越复杂。如果对 拆分后的 controller 没有指导的话，业务代码是很难管理、很难看懂维护的。">


    

    <link rel="canonical" href="http://localhost:1313/go-to-top/day46-business_layering_under_the_framework/">
    <link href="/style.min.e390ba7da26222f4dc42a349955d76dbbe44e5ce2535a43de5a70633a0a9ec3c.css" rel="stylesheet">
    <link href="/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css" rel="stylesheet">

    
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg">
    <link rel="shortcut icon" href="/favicon.ico">




<link rel="manifest" href="http://localhost:1313/site.webmanifest">

<meta name="msapplication-config" content="/browserconfig.xml">
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="theme-color" content="#434648">

    
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">

    </head>
<body data-theme = "" class="notransition">

<script src="/js/theme.js"></script>

<div class="navbar" role="navigation">
    <nav class="menu" aria-label="Main Navigation">
        <a href="http://localhost:1313/" class="logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" 
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" 
stroke-linejoin="round" class="feather feather-home">
<title></title>
<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
<polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg>
        </a>
        <input type="checkbox" id="menu-trigger" class="menu-trigger" />
        <label for="menu-trigger">
            <span class="menu-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7L3.40726 7"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488L3.49301 3.51488"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"></path><path stroke-linecap="round" stroke-linejoin="round" d="M0.5 12.5V1.5C0.5 0.947715 0.947715 0.5 1.5 0.5H12.5C13.0523 0.5 13.5 0.947715 13.5 1.5V12.5C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C0.947715 13.5 0.5 13.0523 0.5 12.5Z"></path></svg>
            </span>
        </label>

        <div class="trigger">
            <ul class="trigger-container">
                
                
                <li class="menu-separator">
                    <span>|</span>
                </li>
                
                
            </ul>
            <a id="mode" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
            </a>
        </div>
    </nav>
</div>

<div class="wrapper post">
    <main class="page-content" aria-label="Content">
        <article>
            <header class="header">
                <h1 class="header-title">Go 翻山越岭——架构下的业务逻辑</h1>
                
                
                
                <div class="post-meta">
                    <time datetime="2021-12-30T19:36:09&#43;08:00" itemprop="datePublished"> Dec 30, 2021 </time>
                </div>
                
            </header>
            
            <div class="page-content">
                <p>在我们互联网公司中都会有一类工程师叫做，架构师。他们经常会去参加一些架构师大会。在他们的圈子中也会有一些黑话，我们一般的程序员是听不懂的，因此就需要我们在写代码的同时，去学习一些相关的理论。这些理论只是名词多，其实并不难。</p>
<p>因为 Go 语言主要用在做后端系统，下面说的也是 API 层面的业务分层。</p>
<h1 id="传统分层">传统分层</h1>
<p>在很早的 web 项目中，都是采用的 MVC 的框架模式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302001395.png" alt="image-20211230200100037"></p>
<!-- raw HTML omitted -->
<p>MVC 这种模式在上个世纪 70 年代就已提出，到现在一直在被使用，因此可以说使用 MVC 的 web 项目称得上远古时代。最早的 web 开发用 PHP 的比较多，而 PHP 的架构尤其以 MVC 模式比较多，Model、View、Controller 都是标准化的组件。</p>
<p>但是，存在一个局限性：前后端所有的代码都放在一起的。所以前端可能不那么讲究，就在 PHP 代码中做一套模板引擎，然后直接在在 Vue 里面去写渲染代码；后端的逻辑也很简单，都写在 Controller 里面。情况更糟的是，有些的公司对业务逻辑到底写在哪里还有争议，有的人写在 Model 里。</p>
<p>后来，当前后端分离变成主流共识之后，View 层直接被干掉了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302202047.png" alt="image-20211230220222943"></p>
<!-- raw HTML omitted -->
<p>有一个原因在于前端和后端各自都变得比较复杂了，所以前端也要专门去做工程化了，随后有了 Angular、React、Vue 等三大知名的前端框架。</p>
<p>而后端将 View 拆出去以后，只剩 Model 和 Controller，不过项目也开始变得复杂，一个接口就有几千、上万行代码的情况。这种情况，如果将全部代码堆积在 Controller 里面，并且还是按照以前的编程流程，过程式开发的话，整个代码维护起来相当地费劲。</p>
<p>所以，大多数公司的后端会将逻辑越来越复杂的业务，拆分成单独的 logic，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302213764.png" alt="image-20211230221310686"></p>
<!-- raw HTML omitted -->
<ul>
<li>model 改成了 dao（data access object）。由于 model 很多时候都被当作领域模型来用，看起来里面就应该有一些逻辑。而 dao 就是仅仅作为数据获取的结构体。</li>
<li>controller 直接被拆分成了两部分，一部分还是叫做 controller，不过功能上更加简单，可能负责的是 API 接口的入口、协议或校验入口等。另一部分 logic ，这个在不同公司有不同的名字，可能叫做 services，都是用来写业务逻辑的。</li>
</ul>
<p>但是，随着公司的发展，业务逻辑也在逐渐地膨胀，到后面越来越复杂。如果对 拆分后的 controller 没有指导的话，业务代码是很难管理、很难看懂维护的。</p>
<p>后来，DDD （领域驱动设计）社区提出了两种方法：</p>
<ul>
<li>贫血模式。也就是刚刚讲的逻辑，将业务代码都卸载 logic 层内，并且像 Struct、Class 上没有任何逻辑，或只有少量逻辑的代码也写在一起。</li>
<li>充血模式。可以往 Struct 和 Class 上去绑定一定的行为，让 domain object 即 entity 有更多逻辑，将原来的业务逻辑从这种改动后剥离出来，还有一些对象校验的也能从业务逻辑中剥离出来。有了这些领域对象之后，再通过聚合来组合 entity 的逻辑，最终组成现有的业务逻辑。</li>
</ul>
<p>这么说还是有点抽象，来看两个贫血模式代码的例子，摘自书籍《实现领域驱动设计》：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302233978.png" alt="image-20211230223359867"></p>
<!-- raw HTML omitted -->
<p>这里的逻辑是想要保存用户的信息，其中有一大堆的参数。可能我现在有一个业务逻辑只是想要更新一下用户所在的城市，那么也要调用 saveCustomer 这个大的函数，并且传入一大堆本来不需要传递的参数。</p>
<p>其中有点糟糕的是，saveCustomer 函数会认为你传入的参数都是有效的，因此会依次把每个字段都做更新，如果其他参数传入的是空，可能就会对其他数据造成影响。</p>
<p>再来看一个实际开发中更可能遇到的场景：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302238308.png" alt="image-20211230223854227"></p>
<!-- raw HTML omitted -->
<p>这里的 saveCustomer  函数逻辑将每个字段做了是否为空的校验，如果不为空意味着你想要更新这个字段。</p>
<p>更糟糕的是，业务逻辑被埋没在存储业务之中了，因此这种代码可能导致你在开发过程中“失忆”的，在对某段函数迭代了一段时间以后，本身这个业务逻辑到底要做哪些需求的，完全看不出来了。</p>
<p>DDD 社区提供了一个解决的思路：定义 Customer Repo，代码如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302247022.png" alt="image-20211230224749949"></p>
<!-- raw HTML omitted -->
<p>首先定义了一个叫做 Customer 的 Repo，然后将之后想要完成的业务需求直接改成了非常具体的函数名字。比如说想要修改用户的地址，就直接加一个功能叫做 relocateTo；如果想要修改电话号码，就添加函数 changeHomeTelephone。这便是整个 Customer Repo 所拥有的的方法集。我们通过阅读当前方法集的名字就能够明白当前的业务需求是什么。</p>
<p>在此基础上，相关的 Repo 实现都相对简单多了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302247687.png" alt="image-20211230224725610"></p>
<!-- raw HTML omitted -->
<p>整个 Repo 的实现比较简单，里面拆分成了几个小的函数。主流程中，根据不同的用例选择执行不同的对象函数，而不是用数据建模，将所有处理集中在同一个函数里。</p>
<h1 id="solid">SOLID</h1>
<p>SOLID 是指面向对象设计 5 大重要原则的首字母缩写，当我们设计类和模块时，遵守 SOLID 原则可以让软件更加健壮和稳定。</p>
<p>今天我们重点了解依赖倒置原则 DIP（Dependency Inversin Principle），它的意思是说高层模块不应该依赖低层模块，相反，他们应该依赖抽象类或者接口。这里有一段根据 DIP 原则修改前的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// business/order.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;dao&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createOreder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">someData</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dao</span>.<span style="color:#a6e22e">SaveOrder</span>(<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// dao/mysql.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SaveOrder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">data</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do the mysql job
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>而使用依赖导致原则修改后的代码，如果最初我们的逻辑是 controller → logic → dao，就能改变为 dao → logic → contorller，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// business/order.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// import &#34;dao&#34; 不再依赖 dao 层
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">OrderRepo</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">repoInstance</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createOrder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">someData</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">repoInstance</span>.<span style="color:#a6e22e">SaveOrder</span>(<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">OrderRepo</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SaveOrder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// dao/mysql.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SaveOrder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">data</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do the mysql job
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>之前的代码中，业务依赖着 dao，必须导入才能使用。现在我们不让业务依赖具体的某一个存储实现，那么我们就需要把 dao 的操作变为接口。</p>
<p>改造后的代码中，我们定义了一个 repoInstance 来实现接口 OrderRepo，这个接口只有 SaveOrder 的操作。由于 Interface 的定义是和业务代码放在一起的，所以都在同一个文件里，不需要再去导入。并且我们能够在 dao 中实现业务模块中定义的接口。</p>
<p>通过这种改造，我们能够将整个依赖关系从业务到 dao，改变为从 dao 到业务，将逻辑关系反转了。</p>
<p>以下再用一张图来解释我说的话：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302303317.png" alt="image-20211230230345237"></p>
<!-- raw HTML omitted -->
<p>可以看到，无论是入口还是存储层，都会依赖业务逻辑。而如果将业务逻辑放在最上层，意味着业务逻辑可以不依赖任何的库，最终外部任何库的变化都不会导致业务逻辑发生任何变化。</p>
<p>OK，今天讲的只是业务逻辑转化的概念，下期文章继续聊聊各个社区的大佬是如何根据这些原则去写代码的。</p>

            </div>
        </article></main>
</div>
<footer class="footer">
    <span class="footer_item"> </span>
    &nbsp;

    <div class="footer_social-icons">
</div>
    <small class="footer_copyright">
        © 2024 .
        
    </small>
</footer>







    
    <script async src="http://localhost:1313/js/main.js" ></script>

    

</body>
</html>
