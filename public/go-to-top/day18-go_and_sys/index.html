<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> GO 翻山越岭——Go 常见系统调用 | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/day18-go_and_sys/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="GO 翻山越岭——Go 常见系统调用" />
<meta property="og:description" content="系统调用，是操作系统内核为应用提供的 API。今天继续来讲一个系统调用案例和 Go 中常见系统调用
   arch syscall NR return arg0 arg1 arg2 arg3 arg4 arg5     213 epoll_create man/ cs/ 0xd5 int size - - - -    来源：https://chromium.googlesource.com/chromiumos/docs/&#43;/master/constants/syscalls.md#x86_64-64_bit
这是 Linux 中的系统调用，编号是 213，我们可以从一下代码了解更多信息：
1# define SYS_epoll_create 213 2 3TEXT runtime.epoll_create(SB), NOSPLIT, $0 4	MOVL	size&#43;0(FP), DI 5	MOVL	$SYS_epoll_create, AX 6	SYSCALL 7	MOVL	AX, ret&#43;8(FP) 8	RET 编号 213 按照调用规约会被存储在 rax 寄存器中，也就是这里的 AX 寄存器。epoll_create 只有一个阐述传递，也就是 int 类型的 size。SYSCALL 直接进入内核去了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/day18-go_and_sys/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-09-07T07:28:31+08:00" />
<meta property="article:modified_time" content="2021-09-07T07:28:31+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GO 翻山越岭——Go 常见系统调用"/>
<meta name="twitter:description" content="系统调用，是操作系统内核为应用提供的 API。今天继续来讲一个系统调用案例和 Go 中常见系统调用
   arch syscall NR return arg0 arg1 arg2 arg3 arg4 arg5     213 epoll_create man/ cs/ 0xd5 int size - - - -    来源：https://chromium.googlesource.com/chromiumos/docs/&#43;/master/constants/syscalls.md#x86_64-64_bit
这是 Linux 中的系统调用，编号是 213，我们可以从一下代码了解更多信息：
1# define SYS_epoll_create 213 2 3TEXT runtime.epoll_create(SB), NOSPLIT, $0 4	MOVL	size&#43;0(FP), DI 5	MOVL	$SYS_epoll_create, AX 6	SYSCALL 7	MOVL	AX, ret&#43;8(FP) 8	RET 编号 213 按照调用规约会被存储在 rax 寄存器中，也就是这里的 AX 寄存器。epoll_create 只有一个阐述传递，也就是 int 类型的 size。SYSCALL 直接进入内核去了。"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/go-to-top">Go 语言系列</a></li>
      
        <li><a href="/posts">杂谈</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于我</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>系统调用，是操作系统内核为应用提供的 API。今天继续来讲一个系统调用案例和 Go 中常见系统调用</p>
<table>
<thead>
<tr>
<th style="text-align:center">arch</th>
<th style="text-align:center">syscall NR</th>
<th style="text-align:center">return</th>
<th style="text-align:center">arg0</th>
<th style="text-align:center">arg1</th>
<th style="text-align:center">arg2</th>
<th style="text-align:center">arg3</th>
<th style="text-align:center">arg4</th>
<th style="text-align:center">arg5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">213</td>
<td style="text-align:center">epoll_create</td>
<td style="text-align:center">man/ cs/</td>
<td style="text-align:center">0xd5</td>
<td style="text-align:center">int size</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>来源：https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit</p>
<p>这是 Linux 中的系统调用，编号是 213，我们可以从一下代码了解更多信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ABAP" data-lang="ABAP"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#66d9ef">define</span> SYS_epoll_create    <span style="color:#ae81ff">213</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>TEXT runtime.epoll_create(SB), NOSPLIT, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>	MOVL	<span style="color:#66d9ef">size</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0</span>(FP), DI
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>	MOVL	<span style="color:#960050;background-color:#1e0010">$</span>SYS_epoll_create, AX
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>	SYSCALL
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>	MOVL	AX, ret<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>(FP)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span>	RET
</code></pre></div><p>编号 213 按照调用规约会被存储在 rax 寄存器中，也就是这里的 AX 寄存器。epoll_create 只有一个阐述传递，也就是 int 类型的 size。SYSCALL 直接进入内核去了。</p>
<p>因此，我们需要知道 SYSCALL 之后发生了什么，即我们写好应用程序 Application program 执行了哪些 SYSCALL 逻辑。从下图可以得知：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109072232527.png" alt="SYSCALL 之后发生了什么"></p>
<p>当我们调用了 syscall.EpollCreate 之后进入了 syscall 包中的一段代码，然后根据一定的规则翻译成 runtime.RawSyscall，里面会有一堆准备参数和逻辑，完了之后就是执行 SYSCALL 指令。上期说的我们写的代码处于 CPU 分级保护域 ring-3，执行这个指令之后就能帮助我们从 ring-3 切换到 ring-0，然后去执行内核相关的代码了。ring-0 内核模式下什么操作都能够进行，没有特别的权限限制。内核也有相关的系统调用表（在最上面的链接中），会去调用具体的系统调用实现。</p>
<blockquote>
<p>推荐一个可以查看层内核的在线工具，做 C/C++ 的同学都可以看：code.woboq.org</p>
</blockquote>
<h1 id="go-常见系统调用">Go 常见系统调用</h1>
<p>我想，大多数同学和我一样，想问一个问题：了解了系统调用对我们有什么用呢？按理来说，我们还要了解几个部分，Go 的实现，Go 怎么和操作系统交互。知道了 GC 就知道 Go 怎么和系统进行交互。知道了内存相关就知道内核 flag 或 syscall 被修改后为什么会导致应用层行为出这么大的问题。像这些业务问题我们大概知道一点，就不会在做应用的时候完全束手无策。</p>
<p>在 Go 代码中，也有支持系统调用的地方，比如：</p>
<table>
<thead>
<tr>
<th>Go 代码</th>
<th>系统调用</th>
</tr>
</thead>
<tbody>
<tr>
<td>os.GetPid()</td>
<td>getpid()</td>
</tr>
<tr>
<td>println(&ldquo;hello world&rdquo;)</td>
<td>write(2, &ldquo;hello world&rdquo;, 11)</td>
</tr>
<tr>
<td>startm -&gt; newm -&gt; newosproc</td>
<td>clone(child_stack=0xc43003c00, flags=&hellip;&hellip;)</td>
</tr>
</tbody>
</table>
<p>系统调用 write(2, &ldquo;hello world&rdquo;, 11) 中，2 代表 stderr，11 代表字符串长度 strlen。我们在 Linux 中最常见的就是 stdin、stdout、stderr，如果不主动做修改，他们分别对应数字 0, 1, 2. 这里可能会问到，为什么会传递字符串长度，在 C 语言中传递字符串就需要传指针，因为指针不知道字符串的长度。而 Go 语言虽然看起来只是传递了数据结构，但底层还是会做展开。比如传入了一个数组，就会展开为：一个地址、一个长度 len、一个容量 cup，写的是一个参数，底层就展开为了三个参数。</p>
<p>启动线程代码 startm -&gt; newm -&gt; newosproc  中，newosproc  最终调用了系统调用 clone。</p>
<p>然后再看下不同操作系统下常见的系统调用</p>
<table>
<thead>
<tr>
<th style="text-align:center">Types of System Calls</th>
<th>Windows</th>
<th>Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Process Control</td>
<td>CreateProcess()<!-- raw HTML omitted -->ExitProcess()<!-- raw HTML omitted -->WaitForSingleObject()</td>
<td>fork()<!-- raw HTML omitted -->exit()<!-- raw HTML omitted -->wait()</td>
</tr>
<tr>
<td style="text-align:center">File Management</td>
<td>CreateFile()<!-- raw HTML omitted -->ReadFile()<!-- raw HTML omitted -->WriteFile()<!-- raw HTML omitted -->CloseHandle()</td>
<td>open()<!-- raw HTML omitted -->read()<!-- raw HTML omitted -->write()<!-- raw HTML omitted -->close()</td>
</tr>
<tr>
<td style="text-align:center">Device Management</td>
<td>SetConsoleMode()<!-- raw HTML omitted -->ReadConsole()<!-- raw HTML omitted -->WriteConsole()</td>
<td>ioctl()<!-- raw HTML omitted -->read()<!-- raw HTML omitted -->write()</td>
</tr>
<tr>
<td style="text-align:center">Information Maintenance</td>
<td>GetCurrentProcessID()<!-- raw HTML omitted -->SetTimer()<!-- raw HTML omitted -->Sleep()</td>
<td>getpid()<!-- raw HTML omitted -->alarm()<!-- raw HTML omitted -->sleep()</td>
</tr>
<tr>
<td style="text-align:center">Communication</td>
<td>CreatePipe()<!-- raw HTML omitted -->CreateFileMapping()<!-- raw HTML omitted -->MapViewOfFile()</td>
<td>pipe()<!-- raw HTML omitted -->shmget()<!-- raw HTML omitted -->mmap()</td>
</tr>
</tbody>
</table>
<p>可以发现，不同操作系统下系统调用是不一样的，所以在不同操作系统上看到的也不一样。了解这些的意义也是在于，我们想要做超过自身能力意外的事情就必须求助于操作系统。</p>
<p>总结，了解系统调用后可以发现这个一个现象：我们的应用程序是被关在权限的监狱中，只能做很少的一些事情，其他的必须拜托操作系统来做。</p>
<p>下期预告：利用工具去观察系统调用。</p>

  

  </div>
</article>
  
  













  
  
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
            repo= "JupiterXue/BlogComment"
            issue-term="title"
            theme="github-light"
    crossorigin="anonymous"
    async>
    </script>
  </div>
  




    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2022  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/go-to-top">Go 语言系列</a></li>
         
        <li><a href="/posts">杂谈</a></li>
         
        <li><a href="/tags">标签</a></li>
         
        <li><a href="/about">关于我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
