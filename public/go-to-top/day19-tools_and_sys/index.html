<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> GO 翻山越岭——系统调用调试工具 | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/day19-tools_and_sys/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="GO 翻山越岭——系统调用调试工具" />
<meta property="og:description" content="了解系统调用就能在业务发生问题时有更多招数，见招拆招。知道了系统调用的概念，有时候我们还需要用工具去实际观察进程是如何发起系统调用，对操作系统做了哪些请求，今天就来聊一聊。
观察系统调用工具 在 Linux 中我们常用用观察系统调用的工具是 strace，在 macOS 系统上常用的是 dtruss
案例1，通过 strace 可以看到一个 Go 进程的启动过程到底调用了哪些系统调用，这里有个例子（具体代码不用关注）：
使用 strace 指令 &#43; 可执行文件x，看到了有哪些系统调用函数被调用。execve 执行哪个二进制文件，arch_prctl、sched_getaffinity 设计 CPU 亲和度，oepnat 加载相关文件，mmap 系统映射，gettid 获取线程 ID。
案例2，通过 strace 还可以查看一些软件的做了哪些系统调用，比如查看 nginx 的：
我们知道 nginx 在平时不服务的时候都是阻塞的状态，即阻塞在某个系统调用上。使用 strace 指令 &#43; -f 参数 &#43; nginx 可以观察它启动的过程。如果这个软件需要创建多个进程，就需要这里的 -f 的 flag 参数，跟踪所有刚启动线程创建的其他进程。最后我们可以发现 nginx 阻塞在 pid 为 224 的 epoll_wait 上。
注意：在 docker 中用这个命令可能会遇到一些问题，可以参考这个链接《Why strace doesn&rsquo;t work in Docker》https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/
案例3，通过 strace 观察一个 Go 语言 Hello world 程序生命周期中系统调用情况。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/day19-tools_and_sys/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-09-09T22:43:41+08:00" />
<meta property="article:modified_time" content="2021-09-09T22:43:41+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GO 翻山越岭——系统调用调试工具"/>
<meta name="twitter:description" content="了解系统调用就能在业务发生问题时有更多招数，见招拆招。知道了系统调用的概念，有时候我们还需要用工具去实际观察进程是如何发起系统调用，对操作系统做了哪些请求，今天就来聊一聊。
观察系统调用工具 在 Linux 中我们常用用观察系统调用的工具是 strace，在 macOS 系统上常用的是 dtruss
案例1，通过 strace 可以看到一个 Go 进程的启动过程到底调用了哪些系统调用，这里有个例子（具体代码不用关注）：
使用 strace 指令 &#43; 可执行文件x，看到了有哪些系统调用函数被调用。execve 执行哪个二进制文件，arch_prctl、sched_getaffinity 设计 CPU 亲和度，oepnat 加载相关文件，mmap 系统映射，gettid 获取线程 ID。
案例2，通过 strace 还可以查看一些软件的做了哪些系统调用，比如查看 nginx 的：
我们知道 nginx 在平时不服务的时候都是阻塞的状态，即阻塞在某个系统调用上。使用 strace 指令 &#43; -f 参数 &#43; nginx 可以观察它启动的过程。如果这个软件需要创建多个进程，就需要这里的 -f 的 flag 参数，跟踪所有刚启动线程创建的其他进程。最后我们可以发现 nginx 阻塞在 pid 为 224 的 epoll_wait 上。
注意：在 docker 中用这个命令可能会遇到一些问题，可以参考这个链接《Why strace doesn&rsquo;t work in Docker》https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/
案例3，通过 strace 观察一个 Go 语言 Hello world 程序生命周期中系统调用情况。"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/go-to-top">Go 语言系列</a></li>
      
        <li><a href="/posts">杂谈</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于我</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p><strong>了解系统调用就能在业务发生问题时有更多招数，见招拆招</strong>。知道了系统调用的概念，有时候我们还需要用工具去实际观察进程是如何发起系统调用，对操作系统做了哪些请求，今天就来聊一聊。</p>
<h1 id="观察系统调用工具">观察系统调用工具</h1>
<p>在 Linux 中我们常用用观察系统调用的工具是 strace，在 macOS 系统上常用的是 dtruss</p>
<p>案例1，通过 strace 可以看到一个 Go 进程的启动过程到底调用了哪些系统调用，这里有个例子（具体代码不用关注）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092303708.png" alt="image-20210909230308944"></p>
<!-- raw HTML omitted -->
<p>使用 strace 指令 + 可执行文件x，看到了有哪些系统调用函数被调用。execve 执行哪个二进制文件，arch_prctl、sched_getaffinity 设计 CPU 亲和度，oepnat 加载相关文件，mmap 系统映射，gettid 获取线程 ID。</p>
<p>案例2，通过 strace 还可以查看一些软件的做了哪些系统调用，比如查看 nginx 的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092317098.png" alt="image-20210909231712937"></p>
<!-- raw HTML omitted -->
<p>我们知道 nginx 在平时不服务的时候都是阻塞的状态，即阻塞在某个系统调用上。使用 strace 指令 + -f 参数 + nginx 可以观察它启动的过程。如果这个软件需要创建多个进程，就需要这里的 -f 的 flag 参数，跟踪所有刚启动线程创建的其他进程。最后我们可以发现 nginx 阻塞在 pid 为 224 的 epoll_wait 上。</p>
<p>注意：在 docker 中用这个命令可能会遇到一些问题，可以参考这个链接《Why strace doesn&rsquo;t work in Docker》https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/</p>
<p>案例3，通过 strace 观察一个 Go 语言 Hello world 程序生命周期中系统调用情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092324898.png" alt="image-20210909232448820"></p>
<p>使用 -c 的 flag 参数，可以看到有哪些系统调用。</p>
<p>在往期文章中讲解“Go 内置数据结构-Timer”时，我们在对 Go 1.13 和 Go1.14 进行对比时用到的就是 strace。</p>
<p>如果官方说对 Go 的 runtime 中做了许多优化，比如 time.Sleep 中用到的 syscall 相比以前少了很多，那么我们同样可以用这个工具去查看。通过运行一定次数 time.Sleep 看前后的结果是否真的有什么区别。</p>
<p>需要注意，strace 的实现其实也依赖了 ptrace 这个 syscall，所以本质上我们要去追踪一个 syscall 还需要依赖一个 syscall（有点套娃）。另外，调试器（如 delve）也是大量使用了 ptrace。因此 <strong>ptrace 不仅可以做跟踪工具，还能做调试工具</strong>。</p>
<h1 id="go-语言中的系统调用">Go 语言中的系统调用</h1>
<p>了解了这么多基础概念，还是要回到我们的 Go 语言，看看它有哪些内部系统调用。</p>
<p>首先我们要区分一下，在系统调用中有一个简单分类：有一些是阻塞的，有一些是非阻塞的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092340838.png" alt="未命名文件"></p>
<!-- raw HTML omitted -->
<p>假如我们对一个网络 fd 去做 read 操作，而连接中没有数据，就会阻塞在这里。其实 read 还是有费阻塞模式的，所以也不太好区分。read 操作的底层通过调用 io_control 之类的系统调用，变成了非阻塞的的调用方式。</p>
<p>在我们用户状态去做阻塞应用的话，其实底层都会转化为非阻塞调用。</p>
<p>还有一部分系统调用没办法做成非阻塞调用。这种情况一定会阻塞。在往期文章讲“调度”的时候，对于 runtime 的 Go 来说没办法去做拦截的一类阻塞。</p>
<p>这两种类型的系统调用最终在底层也会被翻译成不同的函数调用，在底层的函数调用中还是有一些细节区分的，像后面有数字 6 的就是一种派生函数。</p>
<p>问题来了，为啥还要有个 6 后缀？这里其实也是遵循了 Linux 编程中的常见规范。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092348692.png" alt="image-20210909234809637"></p>
<!-- raw HTML omitted -->
<p>很多 Linux 函数都是带有数字的，6 其实说的是 6 个参数。很多系统接口也有类似的命名发，如 wait4，accept4。</p>
<p>这里列举一下和 Syscall 相关代码所在的具体位置：</p>
<ol>
<li>OS 相关的基础⽂件，在 syscall package 中：https://golang.org/src/syscall/syscall_linux.go</li>
<li>使⽤脚本⽣成的⽂件，在 syscall package 中：https://golang.org/src/syscall/zsyscall_linux_386.go</li>
<li>不对⽤户暴露的特殊 syscall，不受调度影响，在 runtime 中：https://golang.org/src/runtime/sys_linux_amd64.s</li>
</ol>
<p>我们知道了系统调用分为阻塞和非阻塞的。还需要注意的是：阻塞的系统调⽤，有特殊的逻辑去把 P 和 M 解绑定，即修改 P 的状态：running -&gt; syscall。这样在 sysmon 中才能发现这个 P 已经在 syscall 状态阻塞了。不过解绑定也是有前提的，如图红色两行代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092354413.png" alt="image-20210909235424347"></p>
<!-- raw HTML omitted -->
<h1 id="系统调用发展历史">系统调用发展历史</h1>
<p>最后，系统调用的发展历史，可以用一张图简单说明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092356006.png" alt="image-20210909235643954"></p>
<!-- raw HTML omitted -->
<p><strong>参考资料</strong></p>
<p>[1] Linux strace命令, 博客园</p>
<p><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html">https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html</a></p>
<p>[2] [译]strace的10个命令, 鸟窝</p>
<p><a href="https://colobu.com/2021/04/30/strace-commands-for-troubleshooting-and-debugging-linux/">https://colobu.com/2021/04/30/strace-commands-for-troubleshooting-and-debugging-linux/</a></p>

  

  </div>
</article>
  
  













  
  
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
            repo= "JupiterXue/BlogComment"
            issue-term="title"
            theme="github-light"
    crossorigin="anonymous"
    async>
    </script>
  </div>
  




    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/go-to-top">Go 语言系列</a></li>
         
        <li><a href="/posts">杂谈</a></li>
         
        <li><a href="/tags">标签</a></li>
         
        <li><a href="/about">关于我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
