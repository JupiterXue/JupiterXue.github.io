<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 木夜星空的个人博客</title>
    <link>http://jupiterxue.com/tags/go/</link>
    <description>Recent content in Go on 木夜星空的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>JupiterXue</copyright>
    <lastBuildDate>Sun, 15 Aug 2021 09:38:51 +0800</lastBuildDate><atom:link href="http://jupiterxue.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>http://jupiterxue.com/go-to-top/go-top-day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/go-to-top/go-top-day6-parse/</guid>
      <description>上回我们说到 8 个常见 Go 业务场景，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础”
回顾 Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，我们可以通过这句代码，编译一段简单的 “Hello World！” 程序看到：
1go build -x hello.go 编译原理基础 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 println(1 + 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var x int = &amp;#34;abc&amp;#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &amp;ldquo;abc&amp;rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>http://jupiterxue.com/posts/go-top-day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/posts/go-top-day6-parse/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接。看似简单，但其中蕴藏着极大的能量，尤其在面对不能一时半会就解决的业务场景中，稍微深挖编译与链接的过程就有奇效。今天我们就来聊聊 “Go 语言中编译原理的基础”。
上期文章提到了 8 个常见 Go 业务场景，虽说都是业务场景，但在代码性能、数据结构转换和系统设计中偏细颗粒度的实践中我们通常感到茫然和繁琐。这是因为在平时开发中，编译器会自动帮我们屏蔽掉代码编译的过程，我们只用关注最后的 ELF 可执行文件。那么我们就来看看，编译器会帮我们做些什么工作，进一步理解我们所写的程序发生了什么样的转化。
编译原理概述 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 println(1 + 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var x int = &amp;#34;abc&amp;#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &amp;ldquo;abc&amp;rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>http://jupiterxue.com/go-to-top/go-top-day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/go-to-top/go-top-day5-problem/</guid>
      <description>上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调试啊。关于业务，写代码当然可以，而当我们面临性能问题时，就需要涉及算法与数据结构。糟糕，你一说到算法我就心虚。如果你算法基础薄一点，没关系，东方不亮西方亮，算法走不通，我们走查看修改底层代码做起，仅需要细心和逻辑推理就能解决部分问题。因此，今天的主题是“探究 Go 语法背后的秘密”。
常见业务场景 你说写业务不用关心底层，OK，那我们今天先讲原理，直接上业务场景。
场景1，这两段代码运行速度怎样？第一个比第二个快？
1// 代码1 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var a = &amp;amp;person{111} 10 fmt.Println(a) 11} 1// 对比代码2 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var b = person {111} 10 var a = &amp;amp;b 11 fmt.Println(a) 12} 场景2，类型转换的原理是怎样的？
1package main 2 3func main() { 4 var a = &amp;#34;hello&amp;#34; 5 var b = []byte(a) 6 println(b) 7} 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>http://jupiterxue.com/posts/go-top-day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/posts/go-top-day5-problem/</guid>
      <description>上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调试啊。关于业务，写代码当然可以，而当我们面临性能问题时，就需要涉及算法与数据结构。糟糕，你一说到算法我就心虚。如果你算法基础薄一点，没关系，东方不亮西方亮，算法走不通，我们走查看修改底层代码做起，仅需要细心和逻辑推理就能解决部分问题。因此，今天的主题是“探究 Go 语法背后的秘密”。
常见业务场景 你说写业务不用关心底层，OK，那我们今天先讲原理，直接上业务场景。
场景1，这两段代码运行速度怎样？第一个比第二个快？
1// 代码1 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var a = &amp;amp;person{111} 10 fmt.Println(a) 11} 1// 对比代码2 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var b = person {111} 10 var a = &amp;amp;b 11 fmt.Println(a) 12} 场景2，类型转换的原理是怎样的？
1package main 2 3func main() { 4 var a = &amp;#34;hello&amp;#34; 5 var b = []byte(a) 6 println(b) 7} 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试2</title>
      <link>http://jupiterxue.com/go-to-top/go-top-day4-run/</link>
      <pubDate>Wed, 11 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/go-to-top/go-top-day4-run/</guid>
      <description>上回我们说到，利用调试工具 readelf 读取我们在 Linux 上编译的可执行文件 hello，并且找到了查看 Go 底层的入口 entry point address，今天我们尝试踏进底层调试的大门，看一看我们平时所说的底层，是否真的很困难，今天的主题是“初探Go底层”
[toc]
实验环境与回顾  操作系统：CentOS 7
Go：1.14.12
调试工具：readelf、dlv
 这里我们同样运行曹大提供的实验环境，并且挂载映射到本地项目，然后进入到这个容器环境中。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 4# 进入项目目录 5cd /project/work/ch01 6# 查看文件 7ls 8 这里的绿色 hello，就是我们 Go 语言编译后产生的 ELF 格式可执行程序（ELF 不知道是什么，可回顾上期文章）
我们一般通过工具 readelf 来找到进入可执行程序底层的入口 entry point address，通过以下命令来实现，这里的 -h 表示去读取 header
 -h &amp;ndash;file-header	Display the ELF file header
 1readelf -h hello 开始底层调试 当找我们通过 readelf 找到了调试入口的十六进制地址码，我们还需要用另一个工具 dlv 才能来调试 Golang 程序。再次之前，来简单说明一下什么是 readelf、什么是 dlv。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>http://jupiterxue.com/go-to-top/go-top-day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/go-to-top/go-top-day3-run/</guid>
      <description>今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我一步步走肯定都能理解。
既然要进行代码实践操作，首先要考虑的就是Go语言编译器（也就是Go）、Go 编程环境以及 Go 代码的调试环境，这里我们需要用到的版本：
 操作系统：CentOS7 或其他 Linux 环境
Go：1.14.12
Go 调试工具：readelf
 是不是有点复杂？如果版本和我的不一样，那么实验结果可能不一样。如果版本比较低，有的工具需要自己去找旧版本的去匹配安装。那有没有什么办法可以简化这些实验环境的搭建呢？用上容器技术——Docker。简单说，当你用 Docker 的时候，就像在自己的电脑中装上了我所说版本的实验环境，里面包括了上面所说的所有东西。你可以用我给出的定制环境（我们称之为镜像），也可以用其他人给出的定制环境，并且可以做到无缝切换。就这么说，在你的 windows 上可以运行 CentOS、Ubuntu，甚至还能在 windows 上运行一个微型 windows，是不是很神奇？OK，我们说回今天的实验，在开始之前希望你能去了解 Docker 是怎样操作的，这里推荐我非常喜爱的 B 站 UP 主“遇见狂神说”推出的 Docker 教程。好，就当你已经会基本操作啦，跟我开始敲代码了：
 搭建实验环境  1docker run -it xargin/go1.14.12-dev bash 这里我们运行了曹大（曹春晖）提供的实验环境，并且进入到这个容器环境中。但是存在一个问题，我们在这里面写的代码在这个容器销毁后就没有了，所以我们需要对容器做一个映射，在容器中写了文件，在我们本地也有一份记录。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 创建目录与文件  在home目录下创建文件夹所有实验目录 work，创建第一个实验目录 ch。（这里的样式和大家不一样是因为 安装了 zsh ，你不一定也要按照，如果感兴趣，请自行搜索安装，当前配色主题是 ys）
实验环境准备完毕。
编写一段简单代码  我们来打开一个叫做 hello.go 的文件，写一段我们最熟悉的代码：
1vi hello.go 1// hello.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>http://jupiterxue.com/posts/go-top-day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/posts/go-top-day3-run/</guid>
      <description>今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我一步步走肯定都能理解。
既然要进行代码实践操作，首先要考虑的就是Go语言编译器（也就是Go）、Go 编程环境以及 Go 代码的调试环境，这里我们需要用到的版本：
 操作系统：CentOS7 或其他 Linux 环境
Go：1.14.12
Go 调试工具：readelf
 是不是有点复杂？如果版本和我的不一样，那么实验结果可能不一样。如果版本比较低，有的工具需要自己去找旧版本的去匹配安装。那有没有什么办法可以简化这些实验环境的搭建呢？用上容器技术——Docker。简单说，当你用 Docker 的时候，就像在自己的电脑中装上了我所说版本的实验环境，里面包括了上面所说的所有东西。你可以用我给出的定制环境（我们称之为镜像），也可以用其他人给出的定制环境，并且可以做到无缝切换。就这么说，在你的 windows 上可以运行 CentOS、Ubuntu，甚至还能在 windows 上运行一个微型 windows，是不是很神奇？OK，我们说回今天的实验，在开始之前希望你能去了解 Docker 是怎样操作的，这里推荐我非常喜爱的 B 站 UP 主“遇见狂神说”推出的 Docker 教程。好，就当你已经会基本操作啦，跟我开始敲代码了：
 搭建实验环境  1docker run -it xargin/go1.14.12-dev bash 这里我们运行了曹大（曹春晖）提供的实验环境，并且进入到这个容器环境中。但是存在一个问题，我们在这里面写的代码在这个容器销毁后就没有了，所以我们需要对容器做一个映射，在容器中写了文件，在我们本地也有一份记录。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 创建目录与文件  在home目录下创建文件夹所有实验目录 work，创建第一个实验目录 ch。（这里的样式和大家不一样是因为 安装了 zsh ，你不一定也要按照，如果感兴趣，请自行搜索安装，当前配色主题是 ys）
实验环境准备完毕。
编写一段简单代码  我们来打开一个叫做 hello.go 的文件，写一段我们最熟悉的代码：
1vi hello.go 1// hello.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day2</title>
      <link>http://jupiterxue.com/go-to-top/go-top-day2-scheduler/</link>
      <pubDate>Thu, 05 Aug 2021 14:45:19 +0800</pubDate>
      
      <guid>http://jupiterxue.com/go-to-top/go-top-day2-scheduler/</guid>
      <description>1package main 2 3// sd1 4 5func main() { 6 // test 7} </description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>http://jupiterxue.com/go-to-top/go-top-day1-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/go-to-top/go-top-day1-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>http://jupiterxue.com/posts/2021-08-03-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://jupiterxue.com/posts/2021-08-03-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>Go 实用小工具</title>
      <link>http://jupiterxue.com/posts/2021-07-26-go-tools-kit/</link>
      <pubDate>Mon, 26 Jul 2021 11:00:46 +0800</pubDate>
      
      <guid>http://jupiterxue.com/posts/2021-07-26-go-tools-kit/</guid>
      <description>Go 小工具 执行命令行 1package main 2 3import ( 4	&amp;#34;flag&amp;#34; 5	&amp;#34;fmt&amp;#34; 6	&amp;#34;runtime&amp;#34; 7 &amp;#34;os/exec&amp;#34; 8 &amp;#34;strings&amp;#34; 9) 10 11func main() { 12	// flag 包使用方法：flag.Type(&amp;#34;flagName&amp;#34;,defaultValue,&amp;#34;help message&amp;#34;) *Type 13	var name = flag.String(&amp;#34;name&amp;#34;,&amp;#34;ls&amp;#34;,&amp;#34;info: 命令&amp;#34;) 14	var args = flag.String(&amp;#34;args&amp;#34;,&amp;#34;-h&amp;#34;,&amp;#34;info: 多个参数&amp;#34;) 15 flag.Parse() 16	fmt.Println(*name) 17	fmt.Println(*args) 18	cmd := *name + &amp;#34; &amp;#34; + *args 19	fmt.Println(&amp;#34;Command: %s&amp;#34;, cmd) 20	out, err := exec.Command(&amp;#34;bash&amp;#34;, &amp;#34;-c&amp;#34;, cmd).CombinedOutput() 21	if runtime.GOOS == &amp;#34;windows&amp;#34; &amp;amp;&amp;amp; err !</description>
    </item>
    
  </channel>
</rss>
