<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>木夜星空的个人博客</title>
    <link>https://jupiterxue.github.io/</link>
    <description>Recent content on 木夜星空的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>JupiterXue</copyright>
    <lastBuildDate>Mon, 27 Dec 2021 22:11:54 +0800</lastBuildDate><atom:link href="https://jupiterxue.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Day43 Web_design_and_project_2</title>
      <link>https://jupiterxue.github.io/go-to-top/day43-web_design_and_project_2/</link>
      <pubDate>Mon, 27 Dec 2021 22:11:54 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day43-web_design_and_project_2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Day42 Web_design_and_project</title>
      <link>https://jupiterxue.github.io/go-to-top/day42-web_design_and_project/</link>
      <pubDate>Fri, 24 Dec 2021 19:14:59 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day42-web_design_and_project/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2021 12 23 Buy_valuables_in_poverty</title>
      <link>https://jupiterxue.github.io/posts/2021-12-23-buy_valuables_in_poverty/</link>
      <pubDate>Thu, 23 Dec 2021 22:36:35 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-12-23-buy_valuables_in_poverty/</guid>
      <description></description>
    </item>
    
    <item>
      <title>软件开发如何选择优秀的框架？</title>
      <link>https://jupiterxue.github.io/go-to-top/day41-how_to_choose_structure/</link>
      <pubDate>Wed, 22 Dec 2021 20:58:12 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day41-how_to_choose_structure/</guid>
      <description>在编程当中，当我们掌握了编程语言的基础知识、经过一段时间编程练习之后会发现三个问题：
  项目复杂。最直接的就是代码越写越多，夸张到所有代码堆积在一个文件，比如单文件 10 w 行代码。这是因为没有培养好的代码习惯、没有软件设计与重构的一些理念，而如果代码素养好一点，我们通常会把代码拆分成几个文件，并根据目录进行分类。
  没有规范。接上一条，也许代码多了我们会开始试着将代码拆分成几个文件，但其实没有一个统一的思想，我们还是容易继续在拆分出的文件中重新写出个 10 w 行代码的单文件，并在需要修改代码的时候东翻西翻找，浪费了时间。
  重复写代码。我们会发现当想要实现几个不同功能的时候，它们的代码是有很大部分一样的结构，比如接口开发中的抽象类。我们很希望有一个模板，也会自己去做一些可以复用的代码模板。
  为了解决这三个常见的问题，于是有越来越多的开发者或团队开发了解决方案，框架。其他开发者可以直接使用这个框架，基于作者设计好的项目架构、文件结构和代码规范，能够在短时间内开发项目更清晰，性能更优越，维护更简单的软件。
而有些框架要么因为太简单，要么因为太复杂，而不能直接拿来用。除非现有的框架中的功能是和我们业务中的需求是完全匹配，而且其中的代码不是复杂、能够很快阅读完，这种框架直接拿来用是非常合适的。但实际中有一个和需求比较契合的框架也是很难找的、甚至没有的，找得到的话那都是运气好的情况了。尤其是大公司，做大了之后，肯定会有和别人不一样自己的定制需求，这个就不在今天讨论的框架范畴内了。
今天来聊聊一些偏主观点的内容，怎么判断框架的优劣？这里我们不讨论具体某个框架、代码写得好不好。有几个框架设计时需要考虑的问题，如果框架符合了，那么说明可能会是优秀的项目：代码规范、自动化、平台化、集成化、组件化、插件化、通用化。如果我们在企业中是扮演企业自研框架的设计者，考虑这几个问题也是很有帮助的。
代码规范 不考虑一个框架的工程质量，如果我们亲自去看，仅凭自己的感受，亲自去看代码的其实比较容易发现代码写得是否好。这里以 Golang 的框架为例，一个代码规范的框架，是老老实实规规矩矩用上静态代码检查工具 GolangCI-Lint 并且遵守着 Go 社区的规范。而不规范的框架虽然声势浩大的，但注释写得很少，代码很乱，随处可见不知道哪里来的下划线的命名（Golang 中的命名是以小驼峰命名法）。
自动化  Layout 代码自动生成（DDD/Clean Atch） 服务上线自动发布 自动生成接口文档 服务接入 SDK 自动生成 常见 code snippet（boilerplate）内置在 CLI 工具内 不要让用户去复制粘贴，我们来帮他自动写好  我们既然要写一个框架，那么写新接口的时候，涉及到大量的重复代码，比如在入口写一个 Controller 或者在 logic 中写一个入口又或者在 Dao 里面又要写一些入口之类的东西等等。这些东西其实都是应该有自动的工具去生成的，通过模板生成工具去实现。
第二点说的是公司中内部的交接需要打通，一旦服务上线之后，就会自动发布到服务注册系统里，不再需要我们人工去做一大堆的申请流程。
自动生成接口文档，这个功能在 Golang 领域最早发现于 Beego 框架。可以直接把 Swagger 集成到里面，通过注解的方式，能把我们开发的接口相应的文档都生成出来。目前，在公司内，有些开发不一定会用到 HTTP，那就需要有一套专门的接口定义，就比如 Thrift 定义的 IDL，gRPC 的 Protobuf。有些新兴公司会用到 gRPC，这种情况还是用 pb 去做服务的定义，因此就需要把 pb 和客户端的生成尽量都做出平台，并且写一些注释，然后自动生成接口文档，做好自动化。</description>
    </item>
    
    <item>
      <title>计算机知识如何指导感情</title>
      <link>https://jupiterxue.github.io/posts/2021-12-21-learn_and_love/</link>
      <pubDate>Tue, 21 Dec 2021 22:04:18 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-12-21-learn_and_love/</guid>
      <description>今天聊的话题我是很感兴趣的，不过也是个敏感而沉重的话题，我担心我所说的会误导你，不过我会尽可能从逻辑层面，从自己对待感情的角度出发，尝试去梳理和分析这个问题。我想，如果你是单身或者在感情中遇到了一些问题，也会对今天的话题感兴趣的，那么，继续往下读吧。
我在读大学的时候，曾经感叹过，为什么从来没有课程是教授我们感情教育的课程。从中学到高中，从来不管是老师还是家长都提倡好好学习，少恋爱或者禁止恋爱。而到了大学，我们会发现遇见的人更多了，对恋爱的约束更少了，甚至说大学便是自由恋爱的开始了。但问题是，大多数人都是第一次开始一段感情，他们完全凭借着自己的第一反应，凭借着自己的直觉来和异性相处。
而问题出现了，男女的差异很快就在交往过程中暴露出来。一般来说，女生会有更多和男生交流或者被交流的情况，在这过程中她们培养出了所谓的“社交直觉”，女生很容易预测男生在想什么；并且女生也会有强大的后援团，自己的闺蜜或者好友，如果在感情中出现什么问题，自己想不通的，会有人支支招。而男性就比较偏保守点，出现了问题都倾向于自己解决。即便他的哥们问到他是否相处不融洽，他也会笑着说她是多么的好、自己多开心。这就是所说的，女生的心理年龄比男生更成熟，直男就是有问题就说多喝热水。
其实说到底也没有什么问题，女生的心智更成熟更容易分辨谁是渣男，谁才是自己的真命天子，男生直来直去的真诚有时也是开启女生心理防线的密码。我们很羡慕那些无师自通的社交恋爱达人，但也不应该妄自菲薄，认为自己现在很差劲，不会被人爱，也不值得被人爱。事实上，我们每个人都有被肯定的时候，都有值得被爱的地方。
最近有个朋友略有伤感地说了一句，我没准备好一个人过一辈子，也没准备好和另一个人过一辈子。我的第一反应是想去安慰，但我知道，我说的其实都是无关痛痒的，比如要多相亲呀或者顺气自然呀。后来转念一想，其实你对感情没有一个明确的预期，前半句你是在说自己想谈恋爱、处对象，后半句是说自己没遇到、或者遇到了但看不到未来的人，然后不知道接下来该怎么办？
这个问题，如果是大学的我，可能还无法回答。不过在持续地学习、持续地写作与思考中，我好像能够尝试来回答了。“生活中本来就有许多智慧，我们要做的就是自己去建立体系、打通关联，通过学习和行动，在头脑中生长出自己的理论体系”这是 S 老师给出的答案。基于此，我的回答是：这是个 NP 完全问题，有一个解就好，你可以积极地去尝试。我想，这可能既能鼓励你，又能安慰你的话了。
NP 完全问题，是在计算机领域中难度很高的问题。这个问题最开始的模型是我想到达一个地方，每个地方只能去一次，问最省力、距离和最小的方式是哪个。意思是说如果你能解出其中一个问题，那你就能解出其中的所有问题。这里的解出是指“有效率”地解出，不是一个一个地去尝试枚举。也就是说，如果要路过的地方有很多，就有非常多的组合可能性。在我们计算机领域中，即便现在的，针对 NP 完全问题，尚无有效的最优解法，也就是说无法有效地找到那个最佳的答案。
但是，我们也有相应的解法，比如近似算法，比如动态规划。前者是说，要么每次选择下一站最省力、距离和最小的，那么总的来说就“相对”最省力，距离最近的。后者是说，我们把去目的地这个大问题拆分成无数小问题，对每个小问题都寻求最优解，最终将所有小问题的最优解整理合并，也是个比较理想的答案。
因此，对应到你的问题，其实也是一样的。你想要找一个伴侣能够陪伴你一生，或者不知道现在的伴侣是否能够和你一起走到最后。你可以根据某些你喜爱的特质尝试去找一个理想的伴侣，又或者你可以在伴侣身上培养你所喜爱的特质，直到你找到和接受当下“最优”的选择。但都需要注意的是，因为你有了需求，容易盲目接受和去要求一些事情，这时候需要的是耐心一点。
也许，你听不懂我讲的计算机知识，但毛大大的话也许对你有启发：
 “同志们要懂得一个道理，这就是世界上的东西，你不去搬它，它就不动，比如这张桌子，我不搬它，它就不走。”——《毛泽东文集》
 讲到这里，其实我也发现，原来大学不教授恋爱课程的原因了。不仅是因为有的同学可能因为单纯钻研这个问题变成了现在市面上所说的 PUA。更是因为他们自己连自己专业上的东西都学不懂，更难理解“爱情”这个延续千百年的复杂问题了。可喜的是，如果我们认真学习，在大学的时候认真学好自己的专业知识，其实也能运用到感情中帮助到自己，但前提是自己是真的理解了。毛大大的文章和语录，多数时候是在谈论战争问题，又或是这里在妇女的教育问题，但无处不透露着生活的智慧。
查理·芒格说过“手中有锤子的人，把世界上的一切都看成是钉子。” 意思是说，当你有一件自己得心应手的工具，你在面对任何问题的时候，都不免想用这个工具来试试看。所有的事情、所有的问题，你都尝试用这把锤子去解决。而很多情况下，这把锤子解决不了问题，或者说，需要更好的工具来解决手头的问题。比如，将钉子从木头中取出来，使用起子会更有效率、更省事。
反过来说，感情问题如果单凭借自己的社交直觉和恋爱天赋，其实是不够的，你需要去学会自己的技能，又或是走更远的路，亦或是了解更多的东西，回首也许才会发现，原来我所认真理解的东西就能解决看似复杂的问题，这无疑是最好的结果了。
后来，你可能会发现，开始也许容易，但维持一段稳定的感情又是漫长的话题了，因为那是两个人的事情，需要你继续发挥自己的智慧了。总的来说，长期共赢是你们的共同目标，仍然是需要去学习和思考的，因为，真爱无坦途。
参考资料
[1] Scalers：为什么你对“半途而废”从来不“半途而废”？
https://mp.weixin.qq.com/s/RZzVBQzDRqkVA6nBFcihDg
[2] Scalers：谈成长中的NP完全问题
https://mp.weixin.qq.com/s/Etj9v1uxG-P_IApuENGxWw
[3] 婚恋大事问《毛选》
https://mp.weixin.qq.com/s/goR-s3MIGUQ5YKl_5m4M3Q
[4] 婚恋大事问毛选 2.0版本
https://mp.weixin.qq.com/s/mGAc3fcmdCea7u_LDXJgOQ</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——并发模型（3）</title>
      <link>https://jupiterxue.github.io/go-to-top/day40-memory_model_3/</link>
      <pubDate>Fri, 17 Dec 2021 07:24:03 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day40-memory_model_3/</guid>
      <description>在 Go 语言的内存模型文档中会专门对 Happen-before 进行描述，网上也有很多分析文章对这个概念进行了阐述，但存在一些场景的误区。那么 Happen-before 到底是什么？有什么特征？在此之前我们先来回顾一下 goroutine 的三个基本特征。
Goroutine 在 Go 语言中，同一个 goroutine 内的逻辑有依赖的语句执行，满足顺序关系。比如我在一个 goroutine 里执行了一个很简单的函数：
1func printA() { 2 a = 1 3 println(a) 4} 只要在其他 goroutine 中没有对这个 a 做修改，那么我们预期和实际的程序运行结果一定是 1，不会是 a=0 的情况。这个过程是个基本的逻辑保证，如果说保证不了的话，相当于我们的代码结果没有办法去做预测了。所以从直觉上我们就能理解这句话。
另一个特征是说：编译器/CPU 可能对同一个 goroutine 中的语句执行进行打乱，以提高性能，但不能破坏其应用原有的逻辑。比如有两个线程，分别会修改 x 和 y 变量的值，第一个线程中修改了 x 的值，并且载入了变量 y。虽然没有修改 y，但提前预加载提高了性能。
最后个特征，不同的 goroutine 观察到的共享变量的修改顺序可能不一样。其实也就是我们在上期文章中提到的内存重排。在 Go 语言中，我们说到同步的时候是指在 goroutine 之间发生的操作，其实在其他语言中是和线程的概念和操作是一样的。说到底，goroutine 在运行的时候就是在线程上去执行的。
上期文章我们还知道了可以通过使用 Litmus 工具测试和观察内存重排，不仅如此，我们在用 Go 语言进行并发编程的时候，如果写的代码不够严谨，在线上产生错误的可能性有 1/100w，那在找 bug 的时候真的是很要命的。
Happen-before 在官方的并发模型文档中，Happen-before 说的是什么呢？
第一个特征：Init 函数一定在 main.main 之前执行：</description>
    </item>
    
    <item>
      <title>暴力破解怎样应用在成长中？</title>
      <link>https://jupiterxue.github.io/posts/2021-12-16-brute_force/</link>
      <pubDate>Thu, 16 Dec 2021 21:04:34 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-12-16-brute_force/</guid>
      <description>生活中我们有时会听到一些大牛说，他经过暴力破解解决了个人成长中的一些问题，比如学英语、学编程、考证书等等。事实上，我们并不完全知道他们说的“暴力破解”是什么意思，因而无法在听到他们说了之后去应用它。今天，就来揭开这层面纱。
什么是暴力破解？ 暴力破解，并不是你所想象的，用很大的力气、用手去撕、用牙齿咬，最终打开锁。
暴力破解原来的英文名称是 Brute force attack，中文又翻译为穷举攻击。这其实是计算机中安全领域其中的密码分析里的一种方法。说的是将密码逐个尝试，直到找出真正的密码才结束。比如你有个小金库里面装了 100 万人民币，并挂上了一个四位数全部由阿拉伯数字组成的密码锁，但是因为时间过去很久，你忘记了密码。怎么办？你不想让人知道，不想损坏箱子，除开开锁匠和把金库砸开的方法，还有什么办法呢？
没错，就是一个一个密码地输入尝试。四位数，每个数字都是 0-9，因此总共也就 10000 种可能性，最多尝试 9999 次也就找到正确密码了。这个过程，便是我们现在常听说的暴力破解。而在计算机中，还有一些方法可以增加尝试的效率，比如字典攻击，就能缩小密码的组合范围。当然这个是后话了。今天我们来讲讲运用这个思路怎样来指导自己去做一些事、学会一些技能。
学编程中的暴力破解 就以学编程为例。0 基础的同学请看过来，你们学编程是怎么开始学的呢？读一本书？读官方文档？听网上老师视频讲课？自己感兴趣尝试写代码？还是因为工作需要参加线下培训班学习呢？
这些方法都有可能，但那一个才是让你真正学会编程的呢？你可能读的第一本关于编程的书是《黑客与画家》亦或者《浪潮之巅》，这些书激发了你对技术的好奇和学习热情。而你第一本接触的编程书可能是《C++ Primer Plus》亦或者《Java 编程思想》，拿到书的时候还很有热情地把介绍部分都读完，可刚开始读第一章，无聊、乏味、说的都是什么等等厌学的情绪向你涌来。算了，看来我是学不会编程了。
某天，当你听说某个程序员朋友的月薪时，不仅羡慕，还在内心呐喊到自己一定要学会，也要找份高薪工作。于是开始在网上找一些零零散散的视频课去学。跟着网课老师一起，一步一步地安装语言环境，安装编译器，最后在编辑器中写下你的第一段代码，然后运行编译器输出了 “Hello World”。你发现原来编程也没有那么难，自己还是能够学会的。于是带着这种热情继续学习了一段时间。
可你还是发现，如果脱离老师的代码，想要自己去写程序，还是很难的，还是很难找一份编程的工作，怎么办？不如报一个编程培训班吧！里面的内容相当丰富、技术都是自己没听说过的，好像都很高大上的样子。于是你花了一两万参加培训。可是呢，中途你还是觉得老师讲的太细了，很枯燥乏味，落下了一节课。在之后的课就一直处于，我上节课还没听完、没听懂，这节课先不听了吧，反正听不懂，于是就又放弃了一节课。
直到最后，老师开始上项目课了，你发现自己的基础不够扎实，项目无法上手，很多地方都不懂。怎么办？既然是培训机构，会宣传他们能够保就业，因此也希望学员都能找到工作帮他们提高声誉，他们怎么办？没学会编程，你想的是还想从头开始学习基础，培训机构想的是没事我们还会开第二期培训班，保证第二期能够让你学会。就这样，你又开始了二进宫。
终于某天，你发现，跟着老师一步一步地操作，学会了看文档，学会了通过搜索自己解决问题。你好像突然就会编程了。让你写个九九乘法表很轻松，让你写个斐波那契数列的递归函数你也能够写出来，你也知道在工程项目当中怎么样去使用框架更高效地完成一系列功能了。
你学会了吗？ 以上，举了学编程的例子，虽然不是很恰当，不过将暴力破解应用在个人成长中的精髓点了出来：如果没学会就换一种方式继续学，直到学会。
所以，如果你还在问 0 基础怎么学编程，看哪本书更好等问题。我建议你想怎么学就怎么学，直接上手去学，如果觉得不合适就换一种方式学，在亲自对比之中选择更适合于自己的方法，在反复学习的过程中逐步加深理解，最终你便学会了。
最后，引用 Scalers 的话结束今天的讨论：
 暴力破解就是从来不怕走错路、走弯路，把弯路走直了，把错路走对了，那就是答案了。
 </description>
    </item>
    
    <item>
      <title>Go 翻山越岭——并发模型（2）</title>
      <link>https://jupiterxue.github.io/go-to-top/day39-memory_model_2/</link>
      <pubDate>Wed, 15 Dec 2021 10:45:03 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day39-memory_model_2/</guid>
      <description>上期文章说到 Go 语言中，单变量的原子的读或写操作，CPU 的多核心使用了 mesi 协议来确保正确性，也就足够了。但是 mesi 协议还存在一些缺陷：如果对某个变量进行先读，然后修改，再写，这样的多步操作，mesi 协议是无法解决的。因此我们需要除了读和写之外的指令，能够保证这种一系列操作的原子性。
内存重排 mesi 能够保证单变量全局顺序的正确性，但其他多变量的全局顺序其实是保证不了的。在 Go 语言的并发编程中，有个叫做内存重排，指的是内存的读/写指令重排。为什么会用到内存重排呢？一些硬件或者编译器会对程序进行一些指令优化，优化后的结果可能会导致程序编码时的顺序与代码编译后的先后顺序不一致。因此，内存重排就专门为其适配，提升程序执行效率，减少一些IO操作。
一般我们可以使用工具 litmus 来验证内存重排，具体暂时不演示了，网上有很多文章。它会模拟本机上一些多线程的读写指令，来对其结果做一些判断。这部分内容不难，刚毕业的学生在面试的时候也会遇到面试官问其中的一些汇编指令是什么意思。其中涉及到的汇编源码，其实我们可以简化为以下的伪代码
关键来了，我们在写并发代码的时候，如何考虑内存重排呢？对大多数程序员来说，不用考虑这个，既然知道在并发的时候诸如以上的操作都可能有内存重排，那么需要保证其顺序性的时候，直接在两遍加上互斥锁就 OK 了。而如果还要考虑更高的性能，就需要使用一些工具。
Memory barrier 如果我们要阻止内存重排的发生，只能使用 Memory barrier。首先，它和内存回收 GC 中的 write barrier 和 read barrier 不是一回事。网上一些文章中会把它们混淆起来，因为它们看起来都有个 barrier。虽然看起来都有 barrier，但其实完全不是一回事。
在并发编程中 ，Memory barrier 是为了防止各种类型的读写重排而专门设计出的工具。比如说 atomic load，在其他语言中都需要加条件，诸如 require、flag 线性一致。
在 GC 中的 write/read barrier 其实是指在堆上的指针修改之前，插入的一小段的代码。
以上的 barrier 其实对于做 Go 应用开发的程序员来说可以不用详细了解，只要知道程序在加锁的时候能够保证正确性就 OK 了。
False sharing 上期文章我们说到了 CPU 采取的是分层存储结构，L1 cache 是 64 个字节。而实际上我们共享变量还不到 64 字节。比如我自定义了一个 struct，它只有 16 字节。但对 CPU 来说，它从内存去在加载这个 struct 的时候，它会把这个 struct 临近的内存也一起加载到 L1 cache 中。</description>
    </item>
    
    <item>
      <title>上班摸鱼应该被消灭？</title>
      <link>https://jupiterxue.github.io/posts/2021-12-14-limit-skiving/</link>
      <pubDate>Tue, 14 Dec 2021 17:48:18 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-12-14-limit-skiving/</guid>
      <description>在我们程序员当中有个关于上班生活的段子：
 你是干什么的？ 程序员。 平时的工作都是在干什么？ 我的工作是摸鱼，顺手写点 bug。
 最后句话好像很浮夸了，工作时间大部分是在摸鱼，其余时间还专门写 bug，其实不是这样的。我们程序员在工作岗位中其实一直都是勤勤恳恳的，一有问题立马响应解决，即便遇到未能及时解决的，在洗澡或上厕所休息期间可能都在想怎么修复 bug。
人是能够在工作中寻找价值和意义的，有个笑话是说：工作这么累，我会少活十年；如果不工作我一天都活不下去。虽然我们程序员会自黑自己是在摸鱼，但事实上绝大部分时间要么是在写代码，要么是在找代码和程序出问题的解决方案，在思考如何解决问题。
在程序开发当中，如果一段代码卡了你很久，问题就是和预期的结果不一样。而当你调通代码的那一刻，便会觉得身心轻松，编程再无什么困难能够阻挠自己。
甚至，有时一段代码卡了你几天，就是无法解决问题。你几乎把能想到的关键词都排列组合，把网页深度优先搜索遍历一遍，在这门技术的各大大群小群问个遍，把所有所有能够解决问题的方法都尝试一遍。这个过程，看起来就好像你只是在单纯地刷网页，在单纯地聊天。所以我们只是看起来在“摸鱼”。
一天，有个小伙伴问我，早上的时候能够写一点算法题、整理一些资料，怀疑是不是我的工作不饱和。我想，就以下方面来讲讲我是怎么“摸鱼”的。
从任务量角度，工作饱和意味着肯定会有工作积压。计算机是能够并行处理任务的，而人是不可能同时处理编程当作的工作的。因此我们可以想一下，如果公司中的工作都堆积在了一个人身上会发生什么？肯定是公司有损失的，因为工作延后了。其次，领导肯定不会放任这种事情的一直发生下去，否则就是他的失职，分配工作不合理。所以英明的领导会在这种事情发生之前，或者事情刚出现苗头的时候就扼杀掉，要么适当拆解将分支任务分配给其他人，要么招聘新人来完成这件事。
从人的生理角度。体力劳动劳动者在长时间进行的工作后，通过补充食物和水能够恢复精力和活力。而编程不仅是一项体力劳动还是一项脑力劳动，虽然也能够通过饮食调节，但脑力的恢复没有体力那么快。可以说编程消耗的是专注力和意志力，需要通过切换工作、听音乐、冥想、散步等其他转移注意力的方式来调节。
工作期间如果一直处于和代码两眼相对的状态，是非常枯燥的。而人是需要社交、需要一定的娱乐休息时间。尤其是在高度专注写代码过程中，是不可能一直坚持写两个小时的，一般半个小时就需要休息一下，刷刷网页、回复些亲朋男女朋友的消息的。
从工作经验角度。如果在工作中我们只做工作职责内的事情，其实大多时候都只是在吃老底，用已有的技能和经验在解决当下的问题。如果工作时间被排得满满的，一方面是这个人没有时间去思考一些优化工作内容的方法，另一方面是他个人如果一直这样发展下去，就没有什么技术的积累了。
事实上，技术的发展非常快，我们程序员也并不是只做一些职责内的事情。有些项目中或多或少有一些技术是自己从未接触过的，只是因为领导感兴趣、外界热门，然后你就懵懵懂懂开始参与了。一些新奇的技术、奇淫的编程技巧也正是你在工作中解决问题的时候学会的。甚至有的程序员会说：一直觉得自己技术很渣，直到离职后开始写简历，发现原来自己已经会了这么多东西了。
从个人成长角度。工作，好比打仗，要随时能打，随时响应。好比 1928 年的年代，毛大大在《中国的红色政权为什么能够存在？》所说。由于当时的中国是一个政治经济发展极不平衡的半殖民地半封建的大国，反革命营垒内部不统一并充满矛盾，因而使许多农村小块革命根据地能够在反革命政权的包围下产生、存活和波浪式地向前扩大。
因此，如果工作重要，打仗重要，就要立即响应。但工作很多时候不可能是完全饱和的，一些程序员可能是真的在摸鱼，刷娱乐视频、玩游戏或者看小说等。但如果你是个有理想、积极的、不甘落后的程序员，你会干什么？你会卷。你会在工作间隙去学习，去看一些技术的书，去练习一些算法题，甚至在工作不忙的时候专门为工作中遇到的问题写一篇技术文章，记录自己的技术影响力。
所以，看到这里，知道摸鱼是否应该被消灭了吧？程序员不是骡子，一直不停地拉磨。反而，程序员是能够的马不停蹄解决公司问题为公司创造价值的，尤其是顶级程序员更是日行千里的汗血宝马，他们需要休息。
最后，引用王垠在《怎样尊重一个程序员》所说结束今天的讨论：
 “他们（程序员）处理的问题比常人的困难很多，费脑力多很多，当然他们需要更好的休息，保养，娱乐。”
 http://www.yinwang.org/blog-cn/2015/03/03/how-to-respect-a-programmer</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内存模型</title>
      <link>https://jupiterxue.github.io/go-to-top/day38-memory_model/</link>
      <pubDate>Mon, 13 Dec 2021 20:06:42 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day38-memory_model/</guid>
      <description>今天聊一聊 Go 语言中的内存模型，这部分内容在对于利用 sync 库在进行应用开发中用处不大，不过我们在面试过程中可能会遇到，这里做个记录。
我们日常的开发中，只要知道使用显示同步就可以保证正确性。也就是说只要发生了并发的情况，那么一定要显示地使用同步手段。显示同步手段，通常是指 channel 或者锁。并且，能够用 channel 和锁的情况下，基本上，只要没有 race 出现，就能够保障程序的正确性。
但我们在开发中有时候会给别人提供偏底层的库，那么需要对底层有了解才能做得出来。因此就遇到了 Memory Model 内存模型。
Memory Model 在具体了解之前，我们先要了解目前的 CPU 架构。现代的 CPU 内部的存储其实都是分级的，比如以下就是个多核 CPU 的典型架构图：
在这个内部，我们可以看到 L1 cache，具体的信息可以通过命令 lscpu 查看到，如下图所示：
L1 cache 有两种类型： L1 Data cache 和 L1 Structure cache。我们平时在编程中经常遇到的就是 L1 Data cache，也就是在修改内存中变量的时候，一定需要从内存中一级一级地把它加载到 L3 → L2 → L1→ core 最终才能让 CPU 核心去处理数据。
L1 cache 又会被划分为多个更细粒度的 cache line，每个 cache line 的大小为 64 bytes。这就是我们为什么在程序中经常会看到，有些数据结构会在其最后不足的情况下补足为 64 字节或 128 字节，都是有可能发生的。我们在 Linux 中也可以再动动手去做些实践尝试一下这个命令：getconf LEVEL1_DCACHE_LINESIZE，可以看到 Data cache 的 cache line 长度，也就是 64 个字节。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见并发 bug（3）</title>
      <link>https://jupiterxue.github.io/go-to-top/day37-normal_sync_bug_3/</link>
      <pubDate>Fri, 10 Dec 2021 21:18:46 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day37-normal_sync_bug_3/</guid>
      <description>这只地鼠又来了，说明今天我又来讲 Go 语言并发中常见的一些bug，看代码咯。
引用传递 1for i := 17; i &amp;lt;= 21; i++ { // write 2 go func() { /* Create a new goroutine */ } // before modify 3 go func(i int) { // modified 4 apiVersion := fmt.Sprintf(&amp;#34;v1.%d&amp;#34;, i) // read 5 }() // before modify 6 }(i) // modified 7} 这里说的是，更改代码之前，我们启动一个 goroutine，这个 goroutine 用的是一个闭包，闭包捕获了外面的变量 i，而这个 i 用的还是地址。而迭代器 for 用的也是同一个 i 的地址，所以到 goroutine 执行的时候，最后 Print 出来的 i 就是最后一个了。</description>
    </item>
    
    <item>
      <title>网络资源应该免费吗？</title>
      <link>https://jupiterxue.github.io/posts/2021-12-09-free_or_not/</link>
      <pubDate>Thu, 09 Dec 2021 22:25:46 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-12-09-free_or_not/</guid>
      <description>16 天前，也就是 11月27日的时候，一款名为 Typora 的文本编辑器正式发布了它的 1.0 版本，作者在更新公告里宣称如果想要使用当前版本，就需要购买签名 License。意味着又一款自2014年以来一直是免费的软件，进入了收费时代。
如果你也是位 Typora 爱好者，可能感到失望，用了那么久的免费软件怎么就突然收费了？明明还有其他免费的 Markdown 编辑软件，凭什么要给你付费。而如果你是为 Typora 重度用户，你会怎么选择，放弃选择其他产品？还是花接近 89 元去购买呢？
了解我的读者应该知道，我是个比较喜爱 Typora 的博主，关于利用 Typora 进行写作、配图已经写过几篇文章了。如果放弃使用它，无异于打脸了，写了些没用的东西。不过有个好消息是，作者虽然宣传正式版 1.0 需要购买才能使用，也宣传之前的版本依然能够正常下载，依然能够免费使用。这对大多数用户来说真的太友好了。
关于 Typora 有什么特性，这里我就不做专门的介绍了。相信你去官网 https://www.typora.io/ 下载一个免费版本，写几篇文章、贴几张图就会深深爱上它。十分简洁、丝滑优雅、非常友好，是我迄今为止对它的最高评价了。而如果不是 Typora 正式发布了 1.0 版本，可能也不会有今天的讨论。我也从来不会去计较那么多。所以今天就是想为 Typora 正名。
其实我是在某 v站 看到了 Typora 更新为 1.0.0 版本，并且开始收费的帖子。但是一个刺眼的标题进入了我的视野“没更新的建议别更新”。你能想象评论中点赞多的是什么情况吗？不是骂 Typora 做得垃圾还收费，关于这个的点赞几乎没有。也不是呼吁大家都去使用免费版的。
点赞最多的是骂这个帖子，骂劝别人不升级的行为。在最后还咒骂了一句：“如果你是一位开发者，那么我祝你这辈子开发的 app 都卖不出去，无人买单！”可能一些读者不是很能理解，而如果曾经有过一段软件开发经历的读者，你的心情应该是和我一样的激动：该挨骂！
想必，做开发的读者应该也用过我们大名鼎鼎的 CSDN 吧。这算是我国国内最大的技术交流社区，还是免费的。各个方向技术领域的大牛、萌新都会在这里更新他们的技术文章、生活感悟以及一些技术故障解决方案。尤其是我们在使用百度来搜索关于技术的问题的时候，几乎百分百在第一页就有 CSDN 中一位博主的解答。
有问题就有解答，这种方式不好吗？好，非常好。但问题是，你点击的几篇 CSDN 的文章都是一模一样的！要么是复制粘贴，要么是引用超链接。如果其中一个不能解决你的问题，其他的基本上全都是无用的垃圾，浪费了你宝贵的时间和精力。
其实 CSDN 的初衷是很好的，它应该是对标国外的 Stack Overflow 这种技术型答疑社区，在这里可以免费创作文章、并且由 CSDN 帮你推广导流。在早期的时候，顶级程序员也会在这里更新它们的博客、去推流。也有越来越多的程序员加入到这个社区来学习。因此 CSDN 上面的文章不仅多，还都是易于理解的中文。
但是，随着 CSDN 越做越大、越做越好，不仅在百度搜索网站中将权重提高了，其网站背后的维护者也在增加。而 CSDN 从那时到现在一直保持着免费创作的初心，从来没有像 Typora 一样，好像“背叛”了创作者和读者。但为了养活网站的维护人员，它也做了些小动作，比如接接广告。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见并发 bug（2）</title>
      <link>https://jupiterxue.github.io/go-to-top/day36-normal_sync_bug_2/</link>
      <pubDate>Wed, 08 Dec 2021 16:20:11 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day36-normal_sync_bug_2/</guid>
      <description>上期文章说到了一些常见并发 bug 的场景，本期文章继续聊聊 Go 语言中常见的一些 bug，继续写 bug（当然不是），并通过代码案例来讲解。
K8S 这里有段一篇论文的代码，这篇论文总结了业界比较知名的 bug，有一些是 k8s、docker 等耳熟能详的应用。因此，我们也可以发现，即便是 Google 的工程师，他们还是会写出来一些 bug，
1func finishReq(timeout time.Duration) r ob { 2 ch := make(chan ob) // before modify 3 ch := make(chan ob, 1) // modified 4 go func() { 5 result := fn() 6 ch &amp;lt;- result // block 7 } () 8 select { 9 case result = &amp;lt;- ch: 10 return result 11 case &amp;lt;- time.After(timeout): 12 return nil 13 } 14} 这段代码的思路其实很简单：我现在想往外部发一个请求，同时要控制超时。如果请求超时那么就会给用户返回一个空。</description>
    </item>
    
    <item>
      <title>为什么会与社会脱节？</title>
      <link>https://jupiterxue.github.io/posts/2021-12-07-disconnected_with_society/</link>
      <pubDate>Tue, 07 Dec 2021 13:31:54 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-12-07-disconnected_with_society/</guid>
      <description>有学生说，担心在学校呆久了，和社会脱节。尤其感到毕业后不会和人交流，找不到工作。如何防止和社会的脱节？自己有点焦虑，像个山顶洞人。
有上班族说，平时我不刷视频、不刷新闻、不刷微博，感觉就和社会脱节了，同事说的梗一句都听不懂，什么 yyds 啊，什么 edg 牛逼。这都是哪儿到哪儿了。
还有个不到 30岁，高中毕业就结婚，现在带俩娃的女青年要找工作。她的朋友推荐她去当打字员，而她说没有做过、没有什么自信。朋友提供了电脑让她试试一分钟能打多少字，结果她一分钟才打了 28 个字。因为打字速度慢，连一份工作的找不到，她觉得和社会完全脱节了。
试问一下，你又和社会有多大的联系呢？不会交流、不刷新闻视频，不会打字，就被视为和社会脱节了？
学生在校园中大多是和年龄相近的人一起学习、成长，不会交流只是因为和别人之间没有合作、没有共事，离开校园步入职场，你会遇到面试官、会和直系领导畅谈，会和同事打招呼。
上班之后，每个人涉猎的方面各有不一。他能说出景德镇陶瓷花纹的具体走势，他能说出太阳系外还有什么行星，她能说出公司团队有哪些人他们之间怎样进行协作。他们都来自不同领域，都有着自己的专业语言。同样的，在网络上流行的语言，也是那些经常混迹各大网络社区、论坛和娱乐休闲平台的人最熟悉。其实他们在接触这些语言后，一开始也不是就懂了，还是自己去了解、在反复遇见中加深理解。后来，他们觉得有意思，便一传十，十传百，网络传递千千万万，也便有了网络热梗。
最后是那位因为打字速度慢而找不到打字员工作的女青年，其实不必苦恼。因为你只是找不到打字员的工作，而 360 行，这行不行可以换一行。平时会照顾两个孩子，有着丰富经验也必定很细心，所以可以尝试为其他新晋宝妈提供建议帮助、提供辅导，或尝试做一快销品零售业务员，或尝试做团队人员之间的沟通人等等。总有一个机会是自己向来就擅长的。
所以，说到这里，其实并不存在所谓的社会脱节。即便有，在我看来可能就是《肖申克的救赎》中那个老布，在监狱住了 50 年，习惯了“监狱的社会”。而监狱把他释放回归到正常社会后，亲人都逝去了，朋友早已没有音讯，自己也没有子女。最重要的是，自己太老了，生活上快要不能自理，适应能力、学习能力跟不上，因此对正常社会的种种感到格格不入，夜里也总是惊慌。
相反，现在的新闻媒体、娱乐资讯才是需要注意的。大多数新闻只能对事件进行粗糙的归类、简单二元地将因果进行关联。对事件背后的本质，他们说不清楚，也不会说清楚，因为需要照顾大多数读者的理解，因为想要火爆，想要红。
并且，新闻提供的论断不能辅助我们进行决策判断，媒体不会把一件事背后所有的厉害关系挑明，他们会为资本卖力，会为流量眼红。他们甚至有时不在意自己说的是否真实，而只要自己是最早说的、自己是最新的，最早触达读者点击的，就是好的。
针对这个问题，已经有个知名作者写过一本小册子《Stop Reading The News》并在卫报发表来解答了。作者劝解我们戒除新闻，而夺取读非虚构的长篇作品，以及研究性的文章。多家注重上下文和思考，避免浮于表面的信息。
其实说白了，多关注自己工作上的事情、关注自己专业上的问题以及在自己能力范围内行事。不必去做些超出自己能力范围、超出认知边界的事情，比如叙利亚为什么又打仗了，哪国总统又会见哪国总理，臭氧层又变薄了等和我们并无直接关系的问题。因为这些问题会无端地消耗我们的心智精神，而让我们在生活中碌碌无为。所以，还是得自己多去思考，多去做点实际有价值有意义的事情。
最后，借助《娱乐至死》一书所说来结束今天的讨论
 娱乐至死的可怕之处不在于娱乐本身，而在于人们日渐失去对社会事务进行严肃思考和理智判断的能力，在于被轻佻的文化环境养成了既无知且无畏的理性文盲而不自知。 —— 尼尔・波兹曼
 </description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见并发 bug</title>
      <link>https://jupiterxue.github.io/go-to-top/day35-normal_sync_bug/</link>
      <pubDate>Mon, 06 Dec 2021 22:30:43 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day35-normal_sync_bug/</guid>
      <description>这期文章来聊一聊 Go 语言中常见的并发 bug 有哪些，并不是说要写 bug，而是在出现这些情况的时候，有相应的解决方案。
死锁 死锁应该是最常见的，来看看代码，应该是最直观的：
1func x() { 2 a.RLock() 3 defer a.RUnlock() 4 5 y() 6} 7 8func y() { 9 a.RLock() 10 defer a.RUnlock() 11 12 // do some logic 13} 这里举的例子都是对对象 a 加锁，可以认为它是个全局变量。a.RLock() 加了读锁，defer 延迟解锁 a.RUnlock()，这时候调用了一个函数 y。进入函数 y 以后，再次执行 a.RLock()和 defer 解锁 a.RUlock()。这个过程相当于递归地执行了两次 a.RLock()，就会发生死锁。
还有段较为简单的代码：
1func x() { 2 a.Lock() 3 b.Lock() 4} 5 6func y() { 7 b.Lock() 8 a.Lock() 9} 有两个函数 x 和 y，都有 a.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——并发编程模式</title>
      <link>https://jupiterxue.github.io/go-to-top/day34-sync_programming_pattern/</link>
      <pubDate>Fri, 03 Dec 2021 20:32:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day34-sync_programming_pattern/</guid>
      <description>通常我们在写 Go 代码的时候，听得比较多的是 Go 和传统并发模式不一样。Go 语言采用的是 CSP 模式，即 &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;
这句英文看起来有些玄乎，但其实是在说，除了 runtime 中的 hchan 结构，没有其他结构能够共享内存。而如果我们想要共享数据的话，就需要 chan 去做任务发送，这时候做的其实是一些拷贝的工作。听起来有点抽象，来看一些别人写的代码示例。
第一个例子 Fan-in 扇入，也就是多个分支合并为一个分支，或合并为少数的分支。
这里的代码意思是要把多个 channel 的结果合并到同一个 channel 中去，这样消费者只用去消费一个就好了。函数中第一行是通过判断输入的 channel 数组的长度来实现的：
 如果是 0，说明递归结束直接返回； 如果是 1，就返回当前的 channel； 如果是 2，就需要调用 mergeTwo 函数。这个 mergeTwo 函数也就是简单的 for 循环 + select 结合来实现的。 最后 default，就是不断对 channel 的长度除 2 ，然后递归地调用 mergeTwo 最终来实现。  一般情况下，我们要合并 channel 的话，数量不会很多几百上千个，常见的是 5-6 个。并且更加实际环境中，每个 channel 还有其具体的名字的，也就只需要写一个 select 就可以了，不用像以上代码中不定长的 channel 实现方式要简单得多。</description>
    </item>
    
    <item>
      <title>最后一个月了，还能再加把劲吗</title>
      <link>https://jupiterxue.github.io/posts/2021-12-02-november_replay/</link>
      <pubDate>Thu, 02 Dec 2021 15:47:56 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-12-02-november_replay/</guid>
      <description>又到了今年的最后一个月，既是激动人心的时候，也是紧张焦虑的岁月。公司里会想着冲冲业绩，考研人会想着最后考试的冲刺。他们都有各自的目标，彷徨又奋力地前行，也许不会那么轻易成功，但都希望明年有个好的开始。是非成败进退难断，举步维艰不断亦难。生有去处，归途又在哪里？我想，出路可能就在，复盘上。
借以此文，来复盘自己 11 月发生的一些点点滴滴，为 12 月做个计划，给今年划上个圆满句号吧。在我 11 月的时候，主要做了两件事，一个是写作，一个是 Leetcode 刷题：
写作 加入小组真的是写作的原动力。还记得 8 月初的时候，加入了一个千字写作小组。以日毕的形式存活到了最后 9 月份结束。那时候基本每个工作日都会更文，即便有一天断了，也会在周末的时候补上并且多写一篇。小组结束后的一周，还能更新几篇文章，并且自认为不需要小组就能继续更文。没想到，，下一次更新文章却是在 10 月中旬的时候了。
 日毕：工作日完成指定的目标，比如写文章，或看书，或做题等。
 也是在 10 月底的时候，又参加了一起千字写作小组。重新捡回了更文的节奏。现在是每天都能准时更新完成文章，没有补的情况，周末偶尔会多写一篇文章的样子。
从上期小组到这期小组，差不多更新了 60 篇文章，也慢慢地形成了我自己更文的一个体系。最开始我认为技术文是很难更得动的，即便是有小组加持还是心有余而力不足。所以采取一天更新技术文，一个更新杂谈（写作/编程/工具/思考）。没想到这个模式一直延续到了现在，我也比较喜欢和适应这个节奏。
技术文 开通公众号，我最想完成的，就是技术的积累和沉淀。所以现在的节奏都是一周有三天都更新技术文，两天更新杂文。在一次线下活动中，我深刻认识到了概念的力量。如果能够用自己的话、或用另外一个体系的话术来阐述一个专业领域的概念。当掌握了 1000个概念了，就可以开直播讲课了。
现在写的技术文章，其实也是来源于曹大开的一门高级工程师的课。当时听课的感觉不是似是而非，不是云里雾里，而是要么腾云驾雾要么如细致入微的核舟记。正课上老师讲的很细，不仅有文字图片，还有超赞的动画。每堂课还有答疑，同学们问的 99% 的问题我都没见过，而老师都能有条不紊、有理有据地回答出来。
曹大 Xargin，大概是我目前见过最厉害的工程师了。一门技术，能够做到有深度已经非常不容易。而要是对众多技术都或多或少有了解，并且能够对各种业务场景提出解决方案，这大概是顶级程序员了吧。
即兴写作 在写杂文的时候，我专门建立了一个文档，用来存放平时生活中产生的灵感、无意间刷到的主题，我把这个文档称之为“即兴写作”。因为主题众多，每次轮到写在我看来是“水文、杂文”的时候，就拿出来看一看。因此每次要写文章的时候，不是技术文就是有明确观点的文章，看到写作小组的同学对没有主题写感到苦恼，而我却会心一笑。
不过最让我惊讶的是，在我看来写得很烂的一篇文章，在发出去当时就想删除的文章。也没做推广，没想到后来有一点阅读量，2w 人阅读了。
其中有几篇文章是我和一些小伙伴在交流当中产生的灵感，随即写的文章，并且，以文交友。这大概是我在写作中最大的收获之一了，如下：
 在写作小组中，我们自发组合了同桌，我的同桌是位国内国籍，在北美结婚暂居的伙伴。她写了一篇关于自己英语学习的经历，总结了一些有用的建议。看了她的文章，和她交流发现她最近在学编程。那么正好，我就模仿她的写作风格来写了自己的编程学习经历。 最开始在公众号写作，我很不适应不用 markdown 来写文章，主要是排版问题。随后找了比如秀米，135。这些模板在我看来虽然功能丰富，但显得花里胡哨，而我只想追求简洁、简约的风格，所以就放弃了。直到想起了之前用的 Typora，就捡起来用到写作当中，然后写了些关于用 Typora 写公众号文章的技巧。后来有差不多 3 个小伙伴都来问我这个的时候，我也写了点偏教程型的文章予以回复。 然后是在 Leetcode 小组中，有个同学看我公众号写作了很多技术文，希望希望我分享一些关于技术的心得体会，我也认真准备了几千字的逐字稿和配图阔爱的 PPT，不负众望。 然后是我无意间告诉了一个非计算机专业同学一点小小的建议，她还来感谢了我。于是又对自己之前的想法做了剖析，并且给出了一些更好的建议。  不足与反思 虽然写文很有收获，但仍然有些很大的短板需要补充，比如：
 自己在文章中思考的还有很多不足。重要的还是概念能力，对现实的抽象，多抽象的描述，对概念的拆解等等。这些东西表现在文章中可能是更加生动的图画，绘声绘色的语言，和引人入胜的故事，都是需要可以去学习、可以去练习和使用的。 推文晚很严重。由于微信公众号每天只有一篇可以群发的机会，如果超过 12 点就会清零重置。而我大多数文章都是写在 23:30 之后的。如果出现些意外容错性真的非常差，好在还没有出现过。并且现在清晰认识到这个问题，在努力克服中。 对读者的理解不多。我写的文章其实没有说专门为了取悦哪些读者，反而更多时候是在取悦我自己。尤其写完一篇几千字的文章，自豪感油然而生。但却忽略了读者想看写什么，措辞是否得当。因此也没有完全写技术文，而是穿插着写杂文。 公众号推广不足。都说微信公众号是个封闭的空间，如果不去推流是不会有人看，不会有新人关注自己的。看到其他的小伙伴专门去诸如朋友圈、简书、小红书、知识星球发文，而我还停留在公众号中，并且连公众号的一些基本功能都没有用熟悉。这些都是我自己的舒适圈外的东西，需要刻意地去打破，否则一直会固守下去。（比如今天学会了开赞赏）  Leetcode 10 月初的时候，我召集了几个学过点编程的小伙伴，组建了一个 Leetcode 刷题小组，随后又运营了二期，三期、四期我都叫由小组的另一位更加积极刻苦的同学来运营，因为我要写文章，没时间管理的原因。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——并发数据结构（3）</title>
      <link>https://jupiterxue.github.io/go-to-top/day33-sync_structure_3/</link>
      <pubDate>Wed, 01 Dec 2021 13:46:40 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day33-sync_structure_3/</guid>
      <description>一个优质的程序、优秀的设计不是凭空产生的，而是经过由简至精，不断迭代产生出来的。在上期文章中，我们了解了 Go 语言中的信号量 semaphore 和互斥锁 sync.Mutex，在此基础上我们还可以实现更加复杂的锁。
sync.RWMutex 读写锁 (sync.RWMutex)，可以来看下它的数据结构和运作逻辑：
可以看到它的第一个结构叫做 w 其实就是互斥锁 sync.Mutex。在这里的作用是为了挡住大部分写操作的 Goroutine，只让第一个进来的能够和其他的读操作的 Goroutine 去做竞争。
现在有一个写 Goroutine writer 进来了，如果还有其他 reader 在做操作，就会把这个进入的挂载在 writerSem 后面的 sudog。如果后面来了新的 writer，前面的 writer 还没有退出的话，那么新的 writer 就需要挂载在之前的互斥锁 sync.Mutex 上的 sudog 后面。同样的 writer 和 reader 也会在不同阶段去做些竞争和唤醒的操作。
一旦有一个 writer 进入并且调用了 lock，那么就会在 writerSem 后面挂载一个阻塞的 sudog，并且把 readerCount 减去一个最大的值，即图中 1 左移 30 的值，最终让 readerCount 变为负数。当 readerCount 变为负数时，reader 在执行 Runlcok 的操作以后，会发现当前已经变为特殊模式了，所以就会后来进来新来的 reader，这些新的 reader 会去调用 Rlock，那么就会挂载在 readerSem 队列中。readerSem 其实也是一个信号量，最终会对应一个等待队列，并且最后的结构 readerWait 的数量其实是和这个等待队列的数量是对应的。
小结一下，一般正常的操作流程是这样的：如果没有 writer 在等待，那么 reader 可以直接去修改 readerCount。readerCount属于正值，readerWait 为 0。一旦有个 writer 阻塞了，那么 readerCount 变为负，readerWait 数量就和 readerSem 队列中等待的数量一致。最终之前来的 reader 它们都执行完之后，会发现 readerCount 是个特殊的值，然后就会把 writer 唤醒，让 writer 去执行它的逻辑。</description>
    </item>
    
    <item>
      <title>为什么学编程要学会抄代码？</title>
      <link>https://jupiterxue.github.io/posts/2021-11-30-why_learning_coding_by_copy/</link>
      <pubDate>Tue, 30 Nov 2021 00:16:11 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-30-why_learning_coding_by_copy/</guid>
      <description>最近有位小伙伴要迎来算法考试了，因为本来不是计算机相关的专业，对编程还不够熟悉。即便在图书馆借阅了一本算法设计的书，还是感到数据结构基础不太踏实。当时我给她的学习建议是先做一些自己能够做的事情，比如抄代码。
外行可能不懂，但一些同行的朋友你们可能要嘲讽了：编程这事，和练字是有区别的。练字训练的是肌肉记忆，而编程训练的是大脑，训练的是思维方式，千万不能教别人做这些类似抄写、背诵、默写等这样的傻事，费力不讨好。再来看看我文章的标题“为什么学编程要，学会抄代码？“
在我读大学的时候，其实我也想过，抄代码真的没意思，又不能理解，最后还不是写不出来。而到了期末实验的考试，那时候发生了一件事真的颠覆了我的想法。当时我们学习的也是数据结构与算法 C++ 版的，这门课不仅是我们计算机学院的同学在上，没想到经济管理学院的同学也在上。也还记得第一堂实验课的时候，老师说，你们都是计算机学院的，考试不用怕！经管学院的同学也在上，她们还不怎么接触电脑呢。
结果，，，老师你不讲武德！最后考试居然是快排！虽然当时能够理解快排的思想，但代码不是很熟悉、不怎么记得。所以在机考的时候就一点点调试，忘不了那个酸爽。奇怪的是，经管的那些大部分同学反而做得比我们学院的快。因为那时是老师检查一个，就打一个分，然后让这位同学离开。陆陆续续有好几个同学都走了，只剩下我和几个同学傻 fufu 地在调试。我就好奇地问老师，她们是都不会做就走了吗。老师笑了笑，别看她们不懂编程，她们会背代码，考试的时候就一个个地敲出来的。这心情就像——17张牌你能秒我？你能秒杀我？17张牌你今天能把我 lbw 秒了，我当场就把这个电脑屏幕吃掉！
现在仔细想来，不管是背代码、抄代码，也是需要掌握时机、掌握方法论的。经管学院的同学因为熟悉编程，单纯凭借理解来“推导”代码，肯定比不上计算机专业的同学，而她们运用了自己擅长的、能做的，背代码。不可否认，在应试教育中，这种模式是值得认可的，从解决问题角度，这种方式是最快速有效的。
思考过这个问题，也对我在最近练习力扣刷题中没有感到迷茫。计算机专业，连二分查找都写不出来，其实也是因为好几年没有经过算法练习。第一遍不会做跟着题解抄，第二遍有点印象写了大部分再看看完善，第三遍得心应手了，并且能够灵活计算中间值和边界条件。在之后遇到更加复杂困难的问题时，也能够耐心地去看题解、将答案多敲几遍来理解推导过程。而不是像刷题评论的一样，一直处于这样的心理状态：
所以在真正开始学习的时候，你会深深地感觉到自己的无知，尤其是在面对最能划分编程能力的算法和数据结构中。而学习的本质是什么？是通过听说读写、思考研究和实践，最终获得知识的过程。能够让你加深对问题的理解，才是有效的。
明白了这个之后，还需要认识到自己对编程的理解到底怎样。如果从来没有接触过编程，那么一个字一个字地抄代码，快速熟悉代码，就能在实践中加深对问题的理解。如果已经有编程经历了，遇到复杂问题可能会浮躁，学不进去，而一个字一个字地抄代码，将阅读速度降下来，将躁动的心平静下来，能够去思考问题的边界、代码所表达的含义。
这还不够。当你做到了会抄代码，你还需要思考编程的本质是什么。程序的执行过程是抽象的，它是不可见的，而代码的编写是需要精细化、具象化的。不是像你想象中的开车或者游泳一样，你一打方向盘就能转弯，腿一蹬就能往前游。假如你是开车转弯，你是要思考的是往哪个方向转，转多少度，手握在哪个位置才能转动，是需要一只手还是两只手转向才能及时。平时我们如果真这么边想边开车，可能都要出交通事故了。
所以，还不能抄代码。想要学会编程，你得理解思想，你得将理论用代码实现出来。这个过程是非常难的。书中的知识，有了小学语文基础就能看懂，我也能给你画图形象化地表述。但你也只能理解大概的意思，还是无法写出代码。那么怎么办？通过大量的练习，来掌握写代码的思路。比如见过几个可以运行的 c 程序代码，你知道要运行需要有 main 函数，要输出需要有 print 函数。
这么一说，好像又很简单了。知道每句代码是什么意思就会编程，了？我现在不想转弯，我想转向了，那你还能知道怎么“编程”了吗？别着急，你已经开始会了。
我们开始学习编程，往往也是从看得见和摸得着的东西开始的。如果现在没有任何办法，感到学习异常困难，可以先尝试抄代码；如果有了编程的感觉，尝试自己去改动代码。在随后学习了分而治之的算法思想后，我们会将复杂问题划分为小问题，一个个解决，将每一处你能够做到的地方完成，时间累积下来。也许某一天，你开始学会编程，开始慢慢理解，抄代码对自己的编程提高，到底是否有用。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——并发数据结构（2）</title>
      <link>https://jupiterxue.github.io/go-to-top/day32-sync_structure_2/</link>
      <pubDate>Mon, 29 Nov 2021 22:39:57 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day32-sync_structure_2/</guid>
      <description>本期文章继续拆解 Go 语言中并发部分的一些内置数据结构，了解它们的运行逻辑，梳理其中的要点。
sync.Pool 上期说到 sync.Pool 结构，它的应用场合非常多，不过主要是用于 GC 标记阶段消耗大量 CPU 或者进程 RSS 占用过高情况。并且通过梳理源码发现它的逻辑是和缓存的机制很像是，都是多级缓存结构的。上期也留下了一个悬念，当 sync.Once 发生 GC 时，sync.Pool 的代码逻辑有有怎样的变化呢？还是看图直观点：
可以看到，当发生 GC 的时候，相当于将 local 和 localSize 直接向下平移，local 赋值给了 victim，localSize 赋值给了 P。如果之前 victim 和 victimSize 有值的话就直接丢弃掉。通过这种方式将以前不需要的、多出来的对象淘汰掉。如果把其中的值刚替换掉，并且又需要从 sync.Pool 中 get 获取对象的时候，local 为空，因此就会去 victim 中去寻找值。其他的逻辑，其实和之前的逻辑是完全一致的。最终，如果 victim 找不到值，就会去 P 中去找值。
一个小插曲。sync.Pool 最早的实现中，操作 shared 是有锁的。而从 Go 1.13 开始，这个锁就直接被干掉了，变成了右下方看起来有点诡异的双端链表，它就可以无锁进行操作。
并且早期的 sync.Pool 在进行 GC 的时候会将其中的对象完全清空掉的。如果我们的程序对 sync.Pool 有重度使用的情况，那么在每次 GC 完成之后，如果正好发生了一个流量请求的数量波动，就会造成应用程序大量地阻塞在一个锁上，会有短时间的延迟波动。
semaphore 信号量 （semaphore），是和所有锁相关的实现基础和所有同步原语的基础设施。可以看看这幅图：
semaphore 它的底层其实可以理解为一个个 waitlink 的链表（先看最下方）。不过这个链表需要在 runtime 中去维护，所以设计了一个 semtable（最上方）。semtable 就是一个定长的数组，这里的长度为 251，也就是锁信号量的地址移进来的。其中每一个元素都是 treap 的数据结构，从字面上来看，“treap”其实就是“tree”和“heap”的合成词，也就是说它既是一棵树也是一个堆：</description>
    </item>
    
    <item>
      <title>Go 语言优势与行业前景</title>
      <link>https://jupiterxue.github.io/posts/2021-11-27-go_advantage_and_employ_prospect/</link>
      <pubDate>Sat, 27 Nov 2021 21:37:16 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-27-go_advantage_and_employ_prospect/</guid>
      <description>在我开始从事 Golang 工作的时候，并没有去了解过 Golang 的前景是如何的。可能是自己的直觉，也可能是对这门编程语言有着迷之信仰，又或者当前 Golang 工程师的薪资待遇稍微高点，就莫名开始从事这么语言的程序开发工作。今天有个机会在小组做分享，也可以将之前落下的功课都补回来，同时我自己也好奇，这门语言的技术生态。
下面我就以六个主题来介绍这门语言，分别是：
 前生今世 多方优势 自身优势 应用场景 市场行情 从业建议  大家在学编程的路上有没有想过一件事，我们学习编程语言的目的是什么？解决问题。解决项目问题，解决公司问题，解决顾客问题，解决社会问题，最重要的是解决我们自己的生活温饱问题或者说学业就业问题吧。
现在各大互联网公司都在极力储备 Golang 的人才，主要还是微服务 docker 的成功，它成为了 Go 语言的第一个 killer 杀手级应用，很多公司都会使用 docker 来部署他们的系统，也会用 Go 来开发许多新的系统。包括谷歌脸书 BAT、美团滴滴七牛云、京东小米360 等也都在招聘 Golang 工程师。
前生今世 当我们选择了一门编程语言，很可能意味着选择了一段历史、一个技术生态。
早在 2007 年，有三位 Google 的大佬程序员在进行一个有趣的讨论，就是下面三位看起来《平凡》的人。
那时候谷歌公司的产品和应用多是用 C++ 来写的，复杂性巨大，了解过 C++ 的同学也知道，相比于现在流行的 Java、Python，非常复杂。并且它们公司那样巨无霸的产品用 C++ 来编译构建速度非常慢，对一些服务端程序的并发支持也不友好。
然后他们三个好基友拍一拍头，握握手，就设计出了 Go 语言，并且第二年也是 Unix 之父的 Ken Thompson （第三位白胡子老爷爷）实现了第一版 Go 编译器，用来验证之前的设计。直到 2009年 11 月 30 日，Go 语言开源了。
Go 语言一经发布后就吸引了一些公司，尤其是云计算领域的初创公司成为了 Go 语言的早期接纳者和布道者。一些公司中还诞生了像 Docker、Kubernetes 这样的“杀手级”或示范性项目，这些项目也让 Go 语言真正地被称誉为“云计算语言”。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——并发数据结构</title>
      <link>https://jupiterxue.github.io/go-to-top/day31-sync_structure/</link>
      <pubDate>Thu, 25 Nov 2021 23:22:55 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day31-sync_structure/</guid>
      <description>我们之所以使用 Go 语言，其中一个很大的原因是它原生支持高并发，通过 Goroutine 和 Channel 完美实现。并且 Go 的并发是属于一种 CSP 并发编程模式的实现。如果我们想很好利用到这个特性，知其然知其所以然，是学习阶段最好的成果，在生产环境中遇到问题才能有的放矢。下面就从它的一些基础数据结构开始讲起。
并发内置数据结构 sync.Once 在 Go 语言的并发结构中，比较简单的是 sync.Once。可以在源码 sync/once.go 中看到代码并不多，但注释很多，还有部分我用省略号隐去了。
sync.Once 只有一个方法，DO。不过其中有一些要点，如果 done 被人修改了，那么就需要做一个初始化；如果是非零就可以直接返回了。也就是说 o.Do 需要保证：
 初始化方法必须且只能被调用一次。 Do 返回后，初始化一定已经执行完成。  以上代码虽然非常短，但我们在开发的时候还是会遇到一些问题。这时还得找官方，为什么一定要有 atomic 操作，为什么 doSlow 函数中一定要用 defer 来处理锁。官方对这些“看似”很基础的问题感到烦，于是就写了非常多的注释，让读者自己去搞懂这些问题（从图中看到）。
这里的功能对于业务层开发的 Gopher 来说比较简单：有个全局资源，只能够初始化一次，需要初始化完成之后去执行一些操作，不过初始化的入口可能会被很多地方调用到。这种情况很常见，一方面是因为我们在做网络编程的时候要处理连接，如果多次 close 连接会出现诡异的错误。所以有很多网络程序中的 Connection 对象再加个 Once 对象，来保证关闭只会执行一次。
sync.Pool 这个结构用的场合非常非常多，不过主要在两种场景使用：
 进程中 inuse_objects 数过多，gc mark 消耗大量 CPU。这种情况多出现于当我们发现程序吞吐量很低时。 进程中 inuse_objects 数过多，进程 RSS 占用过高。这种情况是我们的程序可能运行在比较苛刻的环境下，比如 docker 中内存限制，只有 2GB 的内存。如果超过的话这个进程就会被 kill。  基本的使用方法是在请求生命周期开始时，调用 pool.Get 去获取缓存的 struct 或者 slice，当请求结束时，再调用 pool.</description>
    </item>
    
    <item>
      <title>程序员的终极法宝？</title>
      <link>https://jupiterxue.github.io/posts/2021-11-25-outstanding_tech_or_concept/</link>
      <pubDate>Thu, 25 Nov 2021 15:39:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-25-outstanding_tech_or_concept/</guid>
      <description>也有人说，会搜索就能击败 90% 的人。但是
不可否认，大千世界无奇不有，突飞猛进的方法也许真的存在。 但问题是，你也需要花时间去学习，去尝试、去实践啊。查理·芒格说过，我的剑留给能够挥舞他的人。他有着 100 多个思维模型，又有谁能够全部掌握，又有多少人能够真正理解其中的道理。更可怕的是，有时我们迫切希望现在糟糕的处境能有改观，羡慕别人拥有的自己也能很快获得，所以一些付费课、营销局、诈骗信的妖魔鬼怪都无孔不入。屠龙宝刀无人拿起，屠龙者最终成了恶龙。最终我们是花了钱去学习那些“标题”，最终一无所获。
你想获得的突飞猛进的概念或技术，本质上还是逃不开你人性中想要一夜暴富急功近利的心理。 有些东西真的不是靠一时之间就能改变，它叫做时间的壁垒。
凭什么你花了好几年时间，看了好十几本关于编程的书，练习了几百上千道 Leetcode 的题，而有人十天半个月突击就说他掌握了某些知识或者框架，就能超过你的理论基础、超过你的编码能力？
凭什么你耐心耐心耐心和别人沟通磨合项目，被产品、领导挨骂挨骂挨骂，终于懂得了一点如何去做好一个产品，如何去。
凭什么
这些都是时间的壁垒，一般人无法超过，真的。如果能很快超过你，说明人家本来就和你不在一条赛道的，别人自小聪明，家境优越，师从名师，师出高校。自大小就开始学习编程，参加算法竞赛。别人很快超过你都是有原因的，也正因如此，别人和你的竞争不在单一的努力方向，而是家族、资产、社会地位等等。
所以，年轻人讲点武德，不要好高骛远，不要想着一夜暴富，踏踏实实地做好自己该做的事，上课认真听课，工作认真完成，学习不偷工减料，做事不拖泥带水，你的每次认真付出，就是你最大的法宝。
最后也引用来自 encro 的一句话作为本文的结尾
 既然你允许存在“突飞猛进”，那么也不要怀疑会存在“突然消失”。
 </description>
    </item>
    
    <item>
      <title>Go 翻山越岭——GC 补充与总结</title>
      <link>https://jupiterxue.github.io/go-to-top/day30-gc_lean_and_summary/</link>
      <pubDate>Wed, 24 Nov 2021 21:33:37 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day30-gc_lean_and_summary/</guid>
      <description>最后一篇关于 Go 语言内存管理与垃圾回收的文章，再对之前流程中做一些补充，然后对这期系列文章做个总结。
GC 补充 在 GC 标记流程中有一个环节能够辅助标记：
 Goroutine 中有 gcAssistBytes 字段。 当后台 gcWorker 标记时，会累积 credit，记录在 gcController.gbScanCredit 中   Goroutine 想执行内存分配，要先尝试去 gcController.bgScanCredit 中去借债，如果借到了足够的债，那么就不用协助标记。 如果借不到，那就先协助标记，标记完成后再去分配内存。  在标记流程阶段，堆上对象可能出现引用交叉情况：
 一个是 isMarked 剪枝   另一个是 atomic.Or8  再补充一些零零碎碎的小知识点：
 GC 的 CPU 控制目标是整体的 25%。 当 P = 4 * N 时，只要启动 N 个 wroker 就可以使用。 当 P 无法被 4 整除时，需要吃苦耐劳的 gcMarkWorker 来帮助做一部分工作：  作为全局 GC 员工 Dedicated worker，需要一直干活，知道被抢占。 作为兼职 GC 员工 Fractional worker，达到业绩目标（fractionalUtilizationGoal）时，可以主动让出。 另外一种 IDLE 模式。在调度循环中发现找不到可执行的 g ，并且有标记任务没有完成的情况下，就可以开启 IDLE 模式去帮忙。   Worker 运行模式位于：_p_.</description>
    </item>
    
    <item>
      <title>如何训练逻辑思维？</title>
      <link>https://jupiterxue.github.io/posts/2021-11-23-how_to_training_logic/</link>
      <pubDate>Tue, 23 Nov 2021 22:59:35 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-23-how_to_training_logic/</guid>
      <description>我们总会羡慕那些心思缜密、妙语连珠、出口成章的人，也会在惊讶之后转瞬欣赏那些金句频频、有理有据、一针见血的人。这些人我们在诸如辩论赛场上、突发事件报道记者身上、外交官回复上都或多或少有见到。他们的这些能力，我们习惯性地归纳为逻辑思维。并且我们对生活中许多能够提高逻辑思维的东西趋之若鹜。可惜的是，费时费钱，还是没能将逻辑思维提高到理想中的高度。今天，就来揭开到底什么是“逻辑思维”、怎样训练提高逻辑思维的神秘面纱。
在谈逻辑思维之前，需要先请出它的另外一位朋友“形象思维”，也叫做艺术思维。其实也就是我们平时在生活中眼睛看到的、耳朵听到的、鼻子闻到的、嘴里尝到的以及身体接触感受到的，我们能够对这些“感受”进行理解、描述、表达和记录。因为这些都是实实在在的东西，通过我们的五官能够去体会到。
而逻辑思维不是这样的，逻辑思维也叫做抽象思维。是借助不存在与现实世界中的东西，来帮助我们更好理解、便于记忆、做出结论的思维运动。即我们人在认识事物过程中，借助了概念、判断、推理等思维形式，去将现实抽象为概念、揭示除了事物与现象背后的本质，进而能够认识世界并改造世界。
这么说有点抽象了，再来说说逻辑思维中常用的方法，就能很好理解了，这些方法其实我们从小学就已经开始掌握，只是我今天再把它们都拎了出来。
  分析与综合。分析是在思维中把对象分解为各个部分或因素，分别加以考察的逻辑方法。综合是在思维中把对象的各个部分或因素结合成为一个统一体加以考察的逻辑方法。
  分类与比较。根据事物的共同性与差异性就可以把事物分类，具有相同属性的事物归入一类。具有不同属性的事物归入不同的类。比较就是比较两个或两类事物的共同点和差异点。通过比较就能更好地认识事物的本质。分类是比较的后继过程，重要的是分类标准的选择，选择的好还可导致重要规律的发现。
  归纳与演绎。归纳是从个别性的前提推出一般性的结论，前提与结论之间的联系是或然性的。演绎是从一般性的前提推出个别性的结论，前提与结论之间的联系是必然性的。
  抽象与概括。抽象就是运用思维的力量，从对象中抽取它本质的属性，抛开其他非本质的东西。概括是在思维中从单独对象的属性推广到这一类事物的全体的思维方法。抽象与概括和分析与综合一样，也是相互联系不可分割的。
  最后再来说说，怎样训练逻辑思维？其实方法很简单——写作，认真对待你写的每样东西。如果你写不清楚，那就是代表你没想清楚。
这么说明白了吗？还是不太明白，那么以上我所说的都是白说的，因为前面我的这句话也在引导你进行思考，也是希望你能够组织语言去表达，怎样训练逻辑思维。要想训练逻辑思维，需要的是多去细致地观察生活，借助以上四种逻辑思维方法去用文字记录，最后刻意提炼出对你有帮助、有价值的信息。
通过写作能够锻炼思考，但不一定能提高逻辑性。而不写作的话，在平时是很难说去刻意去提高自己的逻辑思维能力的，毕竟，很多时候我们只想把作业早点完成，把工作早点做完。所以，写吧！</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——现代化标记丢失解决方案</title>
      <link>https://jupiterxue.github.io/go-to-top/day29-morden_write_barrier/</link>
      <pubDate>Mon, 22 Nov 2021 11:49:45 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day29-morden_write_barrier/</guid>
      <description>在 Go 语言 GC 中，为避免对象丢失，可以在所有指针操作中加 Dijkstra barrier，而 Go 官方设计者为了降低 Go 运行环境中的成本，不希望栈上的操作频率很高，所以限制了 Go 不能在栈上操作指针时加 barrier。因此 Dijkstra barrier 和 Yuasa barrier 都失效了。
因为 Go 语言不在栈上去加一个 writebarrier，所以任何一个 barrier 单独拿出来都没办法解决 Go 语言 GC 标记的正确性问题。为了解决这个问题，机智的语言设计者就把 Dijkstra barrier 和 Yuasa barrier 结合起来，做出了集大成者——Hybrid barrier，并且写了一个提案 preposal。网上有很多博客会去解析 writebarrier 的源码，其实就是这张图中的，中和两种算法的集合体。
这里的意思是说，把要修改的指针所指向的老的对象先标灰，然后判断当前栈是否是灰色。如果是灰色就去把新来的对象也标灰。最后再做个赋值操作。
这个算法虽然集成了两种算法思想，但两个算法所遇到的问题正好被有效避免了。虽然作者写个提案 preposal，但后来因为没有时间就没有去实现。后来他们还发现，如果要检查栈的颜色的工作话还需要做一些同步操作，而这个 stack check 动作维护成本太高，所以暂时放弃了，至今也没实现。
但我们亲自去看 Go 语言源码可以发现，它不是内部实现，代码片段如下：
1// slot is the destination in Go code. 2// ptr is the value that goes into the slot in Go code. 3func RealityWB(slot *unsafe.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——GC 标记丢失解决初步方案</title>
      <link>https://jupiterxue.github.io/go-to-top/day28-mark-lost-solutions/</link>
      <pubDate>Fri, 19 Nov 2021 21:31:07 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day28-mark-lost-solutions/</guid>
      <description>Go 语言采用三色标记算法来实现垃圾回收，但标记过程中存在对象漏标情况，最终导致变量被意外回收掉。为了解决这个问题我们需要一个理论基础——强弱三色性。
强弱三色性 强三色不变性和弱三色不变性是解决标记流程中对象漏标或错标的方案，还是看图好理解：左边的强三色不变性意味着所有黑色对象不能白色对象，比如 A → B 就是种非法的情况。只要让程序中不出现这种情况，黑色只能指向灰色，灰色可任意指向，那么 GC 流程一定不会有漏标或错标的情况的，这是一种比较严格的限制。
右边的弱三色不变性是说黑色对象可以指向白色对象，是合法的，但是必须保证还有指向灰色对象的可达路径，比如 A → E，前提是 A → C → E。因为有灰色可达路径，所以黑色对象指向白色对象是合法的，这种方式适当地放宽了强三色不变性的条件，保证了我们的算法可以顺利都执行完。
以上都只是理论，我们要实现这两种三色不变性，最终还是回到了 writebarrier 或 readbarrier（Go 语言中没有）。需要注意：在 GC 中的 writebarrier 和并发中的 writebarrier 不是一个东西。GC 中 barrier 的本质是：指针在编辑之前，可以插入一段代码 snippet of code insert before pointer modify，而 writebarrier 就是指的这段代码：
图中用红色下划线勾出来的意思是说，我们去触发 runtime.gcWriteBarrier 函数时，就是一个指针修改操作之前插入的一个函数调用。我们可以在源码中直接搜索 gcWriteBarrier 找到这个函数。因为反编译也能够看出这句函数调用的源码位置，所以我们可进入确认一下，它一定是一个指针的操作。
可以看到在源码的 252 行，确实是将 waiting 指针指向了空。
强弱三色性的实现例子 以上说了强弱三色不变性和 writebarrier，还都偏抽象、偏基础的，再来看一下强弱三色不变性分别通过哪些 writebarrier 来实现的。首先来一组实现例子：Dijkstra barrier 和 Yuasa barrier。
迪杰斯特拉 Dijkstra 是通过插入 barrier 来实现强三色不变性。（又是他！这个大牛还发明了很多让我们学计算机中痛不欲生的理论）
这个函数中需要注意的是 slot 和 ptr。slot 其实是指类似图 3 中的 waiting 指针，ptr 相当于 waiting 所接收的、等号右侧的值。这段函数的意思是如果想修改 slot ，让它指向新的 ptr，需要先把这个指向的对象先标记为灰。</description>
    </item>
    
    <item>
      <title>沉浸式写作体验——Typora 插图</title>
      <link>https://jupiterxue.github.io/posts/2021-11-18_typora_illustration/</link>
      <pubDate>Thu, 18 Nov 2021 10:16:09 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-18_typora_illustration/</guid>
      <description>最近一位也在写公众号的小伙伴问到公众号有没有什么便捷的方式插入图片，以及是更好的沉浸式写作体验，边输入边搞定排版。这个问题其实之前也有两个小伙伴问过我，我也只是丢给她们怎样使用的链接就“放心”了。没想到后来还会有其他小伙伴也可能用到，既然这个分享的动作也是重复的，那么我就来优化一下，动手写一篇手把手的教学。
虽然本文只是在说如何配置和使用 Markdown 编辑器 Typora，但经过下面略微复杂的操作后，可以做到一劳永逸。刚开始的时候有点麻烦，后来每次在 Typora 中写完文章后就能全选然后 Ctrl C 和 Ctrl V 复制粘贴到公众号，填上标题作者、选上配图打开原创，几秒就能发文章了。
Typora 的安装与使用 安装 首先来介绍一下 Typora，打开官网，可以看到非常简洁的界面，找到右上角的下载，根据你的电脑系统平台选择相应的安装包。
使用 安装好之后，打开 Typora 可以看到一个非常清爽、没有任何干扰的写作界面。
什么是 Markdown，图中也给出了一定的解释。其实 Markdown 也是专门给程序员而设计的语法，通过类似代码的方式来实现文字、排版的不同样式。并且 Typora 采用所见即所得(what you can see is what you can get) 的方式，写入的 Markdown 语法会被直接解析成相应的格式。如果你想看源代码，使用快捷键 Ctrl /，同样的，再次按下 Ctrl /，就能回到原样了。
公众号插图的解决方案 公众号可以直接插图片有三种方式，一中是 QQ 或微信截图，一种是网络图（本地如果上传到了云端就可以直接粘贴过去），还有一种是本地拖入图。它们分别有以下的局限：
  截图能够直接粘贴，但图片大小和位置不能做改动（我是没找到）
  本地拖入的方式虽然还勉强方便，但同样不能修改大小和位置。
  而网络上的图或者从本地上传到微信的图，大小固定，更是不能修改大小。
  有些图我们想修改大小、加上边框、直接粘贴，有没有什么好的办法呢？有的——Typora+Github + PicGo + jsDelivr。通过 PicGo 创建稳定图床 URL 链接，存放在免费的云端仓库 Github，再通过 jsDelivr 来加速访问 Github，最终在 Typora 实现每插入一张图就自动上传到云端、生成可直接复制粘贴的云端图。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——三色标记</title>
      <link>https://jupiterxue.github.io/go-to-top/day27-three_color_mark/</link>
      <pubDate>Wed, 17 Nov 2021 15:16:20 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day27-three_color_mark/</guid>
      <description>上期文章说了很多关于标记的概念、流程，而标记的具体实现今天就来聊一聊。
在了解标记之前我们需要了解三色抽象。在 Go 语言的 MarkSweep 算法中它会把对象分成三类：
 黑：已经扫描完毕，子节点也扫描完毕。(也就是在 mSpan 结构中的 gcmarkbits = 1，位于队列之外) 灰：已经扫描完毕，但子节点未扫描完毕。(也就是子节点大概率是白色，在 mSpan 结构中的 gcmarkbits = 1，位于扫描队列 wbuf1 或 wbuf2 或者全局的 Globally unique work 之内) 白：未扫描，collector 不知道任何相关信息。（也就是 gcmarkbits = 0，并且没有在任何队列中）  这里黑、白、灰，本质上是抽象的概念，在代码中不会找到某个对象，它是表示颜色的。
文字描述还是有点抽象，再来看看图：
最开始有个 root，它是指全局变量或栈上的指针或栈上的对象，它们是整个 GC 扫描的起点 root。可以看出来整个 GC 的过程就是个简单的广度优先遍历算法流程。最开始扫描根对象的时候，会把这些根对象放在 gcWorkBuf 里面，并且把 gcmarkbits 置为 1，这时候就变成了灰色。
然后从 gcWorkBuf 里取出指针，把它们的子对象往队列中放。比如 A 的两个子节点的 gcmarkbits 都被置为了 1 并且进入了队列，也就意味着 A 应该从队列中出来，这时候就会变成黑色。
当 E 的对象被推入到队列中后，它的子对象 F 会变为灰色，E 会变成黑色。按照这个过程一直执行下去，直到所有对象都会被扫描到并且被标记为黑色。
最后可以发现还有个 G 没有被标记到，这就之前说的语法不可达对象，也就是语法垃圾，它最终会被 sweeper 回收掉。
虽然三色标记流程看上去很简单只是一个广度优先算法，但其实它的 wbBuf 设计得很复杂，目的就是为了后期可以进行一定的优化。我们如果从头去实现一个三色标记算法，如果不考虑性能，其实只需要实现一个队列就可以了。</description>
    </item>
    
    <item>
      <title>编程、输入法和打字速度</title>
      <link>https://jupiterxue.github.io/posts/2021-11-16-programming_typewriting_and_speed/</link>
      <pubDate>Tue, 16 Nov 2021 10:52:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-16-programming_typewriting_and_speed/</guid>
      <description>学习编程是否需要好的输入法？是否需要很快的打字速度？编程萌新可能会遇到这两个问题。你可能更更想问学编程是否需要英语？是否需要数学？别问，问就是需要 :）
我们想做一些事的时候，总会担心自己基础不够，那个差、那个也差，这个应该补一补，那个也应该补一补，并且我们非常希望这件事能够在短时间内完成。这意味着什么？意味着我们想通过自己扎实的基础去快速学习、快速完成一件事，如果完不成就会自然而然地放弃，而不是惩罚自己。这是人性，这是人天生自有的速成倾向。
因此我们需要衡量一下，学编程需要多少时间，学输入法需要多少时间，学快速打字需要多少时间？这里隐含的其实是机会成本。什么是机会成本呢？机会成本衡量的是在两种或多种物品直接的利益取舍，为了简化起见，一般是在两个物品直接衡量机会成本。一般我们衡量机会成本不是算立刻拿出的时间或费用，而是根据相对严密的数学运算，进行心理预估，进行抉择时，失去一种物品的收益而接受另一种物品的收益。
我们无法在同一时间内既学习编程又学会高效的输入法，还把打字速度也练得很快。因此我们会进行权衡取舍，哪个的学习成本低、学习收益高，哪个学习成本高、学习收益低。虽然我们都是理性人，会去考虑边际量，比如学会了编程，能够去参加工作、能够做一些工具，能够做有效益的事，并且编程越厉害，越是有更多高薪工作，能做出高效工具。但是，我们也会因为编程有点困难，一时之间无法突破障碍、陷入僵局，不做这主要的 A 事情，而去做 BCDEF事情。结果呢，A 多半没做好，BCDFE 可能做到了，但对 A 没有任何帮助。
在我大学最早接触编程的时候，还是用 C 语言来写 Hello World。因为不熟悉键盘布局，还是尖起两个食指去找字母和符号，比如# {} //。那时我从来没想过会是因为输入法、打字速度影响我学编程。我只知道，如果编程需要用到这些字母符号那么我就会去找它们，如果有自己熟悉的但是很重复的，就会用到 Ctrl+C 和 Ctrl+V 。后来，我在学习编程的时候，一边听老师上课，一边跟着老师敲代码，真的就不知不觉会去按那些原来看起来很陌生的字母，打字速度就是在编程的练习中提高的。
后来的后来，我想精进自己领域的技术，还是得去看一些书，做一些笔记。我尝试去抄书来深度学习，但即便是用键盘打字，没有手写还是很费力。因为我还是用的拼音输入法，错字率不仅略高有时输入一个拼音需要翻一两页找，而且有时还会切换英文去输入字母。切换翻页切换翻页，这么下来效率很低。于是我去找了找有什么输入更高效的输入法。还真找到了，网上说的是拼音输入法的输入效率最低，然后排名分配是 双拼 &amp;lt; 五笔 &amp;lt;= 二笔。听说有时五笔最高效，我经过几天尝试还是没能掌握，二笔也是因为没有找到个合适的学习材料终止。但现在想起来，输入法还真没有成为我在编程上的障碍，只是我想再跳一跳摘到更高的桃子时的一个垫脚石。既然我没有掌握它，到不如把现在的输入法多加联系，把拼音输入法的石头多垫几层，多用点时间而已。
原来真相是这样：当我做好编程这件事的时候，其他的事情也会跟着好起来，输入法越用越灵活，从两个手指敲键盘到盲打。关键还是从做好一件事开始。
最后，类比英语和数学的基础在编程中的需求情况，现在你是否知道自己需不需要它了？想学编程还是不用关注英语是否扎实，数学思维是否够灵活。重要的还是投入时间去看编程的基础概念，去动手编码验证结果，脱离教材去尝试面对白板去写代码。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——标记流程</title>
      <link>https://jupiterxue.github.io/go-to-top/day26-go_garbage_collection_mark/</link>
      <pubDate>Mon, 15 Nov 2021 09:07:46 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day26-go_garbage_collection_mark/</guid>
      <description>Go 语言使用并发的三色标记（tricolor marking）算法作为其垃圾回收算法，并且在 Go 中的 GC 没有分代，没有压缩，没有对象移动。整个 GC 流程如图：
整个图看起来觉得很复杂，代码很长，但其实里面的关键节点不是很多。左上角可以看到三种 GC 的触发的方式：后台触发，用户主动触发，内存分配触发。
在触发之后会进入 runtime.gcStart 函数。因为很多内存分配器都会进来，但最终只有一个能够进去，所以它会抢一个全局锁。然后启动所有后端标记的 worker 并且把它和每个 P 绑定。每个 P 都会对应一个 BgMarkWorker，但不一定每个 worker 都能全部启动，其实是按比例启动的。所以在 cBgMarkStartWorkers 函数中初始化所有 worker 都会让它们进入一个休眠状态 goPark，它会在执行到 schedule 函数中的 finRunnableGCWorker 时之前休眠的 GC 标记线程唤醒，之后是从 G runing 状态变为 G waiting 状态。
注意，在标记的时候会控制所有标记协程的 CPU，所以不能把所有的 P 上协程全部唤醒，如果全唤醒意味着 CPU 占用中标记就占用了了80% 到 90%，应用程序也就跑不起来了。
gcDrain 是整个标记的主流程。其中，mark 标记根节点，gc work 全局和本地的平衡，scan 对象并进行标灰。整个清扫过程完成之后会，会有一个分布式完成算法进行判断，然后会进入 gcMarkDone 函数。
gcMarkDone 阶段会去把剩余的 write buffer 或 gc worker 里面的工作都清理掉。整个函数中还可能会有回退情况循环情况。标记完成之后就是 gcMarkTermniation ，也就是 GC Mark 的终极阶段。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——Go 语言垃圾回收流程</title>
      <link>https://jupiterxue.github.io/go-to-top/day25-go_garbage_collection/</link>
      <pubDate>Thu, 11 Nov 2021 23:26:35 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day25-go_garbage_collection/</guid>
      <description>Go 语言的垃圾回收机制采用的是标记清扫。这种方法的特点在于：标记清扫完成之后，有些内存没办法被使用的，所以标记清扫很大的问题就是有很多内存碎片。我们在使用标记清扫算法的时候，需要内存分配算法能够一定程度上应对这种碎片问题，之前分析过分级分配的分配器可以在一定程度上应对这个问题。这也是为什么 Go 语言可以使用标记清扫算法，因为它使用了 tcmalloc，在一定程度上能够缓解碎片问题（但也没有解决）。
老版本 Go 语言中，标记清扫大致是以下流程：
 最开始 Off 阶段，应用程序正常执行，可能没有调用 gc。 当垃圾收集开始处于 Stack scan 阶段，会做一些栈扫描，从栈和全局变量中收集到一些基本的根指针，也就是整个对象图的根，在开始收集时需要去开启 write barrier。黄色的矩形标记的是要把 write barrier enable 这种全局变量改成 True，之后所有的指针变量都需要经过这种特殊的逻辑。 在堆对象收集完成之后就开启了标记流程 Mark，其实就是个基础的广度优先算法，也可以当作多叉树来理解也是可以的。 标记结束阶段 Mark termination，因为 write barrier 存在缺陷，所以在标记完成之后还需要对有全局或者已经变更的栈做一次扫描，把已修改的指针重新进行 GC 标记，防止在 GC 阶段发生对象的漏标或者错标情况。 所有对象标记完成之后进入 Sweep 阶段，做一些清扫工作，这段流程之后垃圾就被回收掉了。被垃圾占用过的空间就可以被重新拿来分配。如果不需要那么多内存，那就会把分配器还给操作系统。 完成整个清扫、回收过程之后，把 GC 设置为 Off，也就重新回到应用程序执行阶段。  Go 语言在 1.8 版本以后，通过混合 write barrier 消除了第二个 stw 中的 stack re-scan，也就是说 stw 时间大大减少了。stw 位于图中红白的矩形块阶段，是指这段时间内只有垃圾回收在执行，应用程序是被阻塞住的，两个红色阶段都是被阻塞住的。早期版本的 stw 的时间是比较长的，因为它会扫描所有全局或者变动的栈，这里就非常耗时了。
新版本的垃圾回收流程和原来有些区别：
Go 官方做了些优化，第二个 stw 过程中不用去做全栈扫描，因此时间大大缩短了。整体流程也发现了非常大的变化。如果去看了 Go 语言源码，可以发现每两三个版本垃圾回收模块的逻辑变化挺大，很多内部的实现都变了，有时候两个版本之间可能只有主函数或关键流程差不多。因此我们也可以得出结论：Go 语言垃圾回收的模块是变化非常频繁的，如果不是工作需要或兴趣趋势，简单了解流程就行了。
在 Go 语言中，垃圾回收也会有个入口，位于 runtime 的 gcStart 函数，它会在三种情况下被触发。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——垃圾回收基础</title>
      <link>https://jupiterxue.github.io/go-to-top/day24-garbage_collection_base/</link>
      <pubDate>Wed, 10 Nov 2021 15:18:35 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day24-garbage_collection_base/</guid>
      <description>之前说的内存回收可以用这张全局图来解释，总共 6 个 level 的分配结构，把这几个链路都梳理弄清楚就能有个清晰理解。
垃圾回收的理解更为难，需要一些算法基础，否则在看这部分知识的时候很可能完全看不懂。
在理解垃圾回收之前，首先需要先对垃圾做一个分类，程序当中有两类的垃圾，语义垃圾和语法垃圾。
语义垃圾(semantic garbage)，有时也称为内存泄露，是指从语法上可触达的对象（包括可通过局部、全局变量引用得到的对象），但从语义上来讲他们都是垃圾，垃圾回收器对它们无能为力。
语法垃圾(syntactic garbage)是指从语法上无法触达的对象，这些才是垃圾收集器收集的主要目标。比如有些内存无论用怎样的代码去操作都是无法接触到的。
这里有几个例子有助于理解：</description>
    </item>
    
    <item>
      <title>我的编程之路——关于Python 学习的回忆</title>
      <link>https://jupiterxue.github.io/posts/2021-11-11-my_programming_road/</link>
      <pubDate>Tue, 09 Nov 2021 10:16:37 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-11-my_programming_road/</guid>
      <description>本来今天想写点关于“编程、打字速度、刷入法”的一个讨论，因为一个朋友建议，希望我能写写关于编程的学习经历。不如就在今天吧。谈一谈我是如何学习 Python的。
要说我现在写 Python 的水平，可能还只是停留在使用框架和包上，距离真正的 Python 大神还差一段距离。不过像爬虫 Scrapy、requests，后端 FastAPI，数据分析 Pandas、Numpy，还是能够信手拈来。从 Python3.4 到 Python3.8 每个版本更新有怎样的迭代都有个了解，一些魔术方法、奇淫技巧用得较少偶尔能够抖个机灵。因此我现在大多数时间还是在用 Python 做一些 CRUD 增删改查的工作、衔接多种数据库做数据处理以及其他大数据组件的调用插件。至于 Python 算法的能力，那又是另一个无关编程语言，而是算法与数据结构的能力了，到目前为止仅刷过了 283 道题，还需继续努力。
所以我所说的可能对你没有什么帮助，如果你感兴趣，可以接着往下看。
初次接触编程—还是那个 C 语言 在大学以前我其实还不知道有编程这回事。直到上了第一门编程课，遇见了那本到今天也想骂又念念不忘的红皮书《C 程序设计-谭浩强著》。
当时学编程的最直接感受就是当时老师说的一句话：暂时不用管这个 #include 、main 是什么意思，我们 C 程序都需要这样的格式才能够执行代码。
1#include &amp;lt;stdio.h&amp;gt;2 3main() { 4 printf(&amp;#34;hello world\n&amp;#34;) 5} 不求甚解，大概是当时止步于编程大门前一个绊脚石。
结识好伙伴 Java 大二的时候，我有个室友，从大一开始就和我是同一专业、同一个班，后来我和他一起转专业，从物联网转到软件工程，我们俩也神奇地分到同一班、同一个寝室。我们都对实验室感兴趣，于是去找到了当时做 Web 方向的实验室。室友他其实从高中就开始学习编程，自己在没有任何外力的情况下啃了一大部分《Java 编程思想》，因此在大学期间已经具备了 Java 编程的基础，不仅在 C 语言中考得高分，在实验室中也收到了指导老师的看重。
某一天，因为实验室有众多不同领域的老师，开始分方向进行小组学习。一个是有大好前景的 Java Web，一个是 Python 视觉处理。室友虽然一直在向我传达选什么方向都可以，但还是透露出他希望我选择 Java 方向，因为实验室主导老师擅长这个，室友他也熟悉。也正是因为于此，我不甘一直在他的带领下，我希望能够和他，站在一起。所以还是选择了些许陌生、迷茫的 Python。（即便当时大一下的暑假我自己看完了大部分《Java 从入门到精通》，还是坚定地做出了选择）后来，我们俩回顾当初这段经历，依然觉得我可能选错了，但我，还是不后悔。也不得不说，当时通过对比学习了两门编程语言基础语法，也为我快速学习 Python 奠定了良好基础。基础语法如隔层纱，只要花时间去阅读、去尝试就能了解与理解。
结识新朋友 Python 其实当时也抱着很高的热情想学 Python，第一本看的 Python 书便是《Python 编程入门》。得益于有点 C 和 JAVA 基础，这本书我拿到的第一周就把基础都看完了，只有三个实践项目因为都不是很感兴趣就没看下去了：一个是打飞机游戏、一个是 Django 后台，还有一个是 GUI 可视化。后来也有没有接触过 Python 的同学，希望我能推荐一本入门的书，我也毫不犹豫地推荐了它。对了，现在这本书已经有第二版了，相信也不会差。</description>
    </item>
    
    <item>
      <title>为什么公司更多用 CentOS 而不是 Ubuntu</title>
      <link>https://jupiterxue.github.io/posts/2021-11-09-why_more_centos_rather_than_ubuntu/</link>
      <pubDate>Tue, 09 Nov 2021 10:08:30 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-09-why_more_centos_rather_than_ubuntu/</guid>
      <description>想做个类似鹤老师经济学一样的专栏，无关他的观点是否正确，仅就他能够尽量从经济学的角度来看现实问题就值得学习。所以也想利用到经济学的工具，对自己领域的一些东西做分析。既是加深自主学习的理解，也从另外一个角度去理解自己领域的一些概念。
作为开发者，我们经常会用到的操作系统更多的可能不是 Windows 而是 Linux，而 Linux 目前已经发行了几百种操作系统，但主流的也就那么两个 CentOS 和 Ubuntu。一般而言，公司倾向于用 CentOS 而不是 Ubuntu。为什么会有这种局面呢？明明感觉 Ubuntu 更友好，界面更美观，为什么公司还都是用黑窗口的 CentOS？
网上有很多人也在讨论这个话题：
 这就跟许多国内互联网公司喜欢用 go 一样，说不出什么道理的。
本质上是谁有钱，谁更稳。CentOS 的背后是 Redhat 。
历史习惯问题，由于某些原因，centos 在中国流行，高校用、企业用，用的人多了一传十十传百，长年累月下来用户体量保持一定优势。
 还有摘自网友 namelosw 的一个梗，就图一乐：
 服务器：要说还是 CentOS 牛皮，Ubuntu 就图一乐 编程语言（以前）：要说还是 C++ 牛皮，Java 就图一乐 编程语言（现在）：要说还是 Java 牛皮，Go 就图一乐 建模：要说建模还是 AutoDesk 牛皮，Blender 就图一乐 引擎：（不太久前）要说引擎还是 UE 牛皮，Unity 就图一乐 引擎：（估计不久以后）要说引擎还是 Unity 牛皮，Godot 就图一乐 桌面（ 03 年）：要说还是 Win 98 牛皮，2000 XP 的什么叼玩意 桌面（ 10 年）：要说还是 XP 牛皮，Win 7 什么叼玩意 桌面（ 16 年）：要说还是 Win 7 牛皮，Win 10 什么叼玩意</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——Go 内存管理（2）</title>
      <link>https://jupiterxue.github.io/go-to-top/day23-go_memory_management_2/</link>
      <pubDate>Sat, 06 Nov 2021 16:55:34 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day23-go_memory_management_2/</guid>
      <description>Go 语言在内存管理中申请使用稀疏堆时，使用系统调用 mmap ，因此可以分配出不连续的地址（而不是通过系统调用 brk 来调整虚拟空间里堆的 program break 来分配连续内存地址）。在使用稀疏堆时，整体的堆内存怎样增长的呢？
较大的内存块 arenas 其实是个大的指针数组，每个指针就是 mheap arena 结构，它会指向具体的 64 MB 的内存，在当前的 mheap 结构中还会维护最后一个起始位置和结束地址。一旦分配内存的时候真实结束地址超过了 mheap 结束地址时，说明还需要从操作系统要更多虚拟内存，这时还是执行 mmap 再分配一个 64 MB 的地址空间，并且维护好当前的数据结构，把原来的 n 变为 n+1 相当于增加了一个元素。
在 Go 语言中除了从操作系统申请内存的方式以外，在分配时还要区分内存大小，有三种分配大小分类：
 Tiny：size &amp;lt; 16 bytes &amp;amp;&amp;amp; has no pointer(noscan) Small: has pointer(scan) || (size &amp;gt;= 16 bytes &amp;amp;&amp;amp; size &amp;lt;= 32KB) Large: size &amp;gt; 32KB  并且，内存分配器在 Go 语言中为了做一些优化，维护了一种多级结构：
 mcache：与 P 绑定，本地内存分配操作，不需要加锁。 mcentral：中心分配缓存，分配时需要上锁，不同 spanClass 使用不同的锁。 mheap：全局唯一，从 OS 申请内存，并修改器内存定义结构时，需要加锁，是个全局锁  在距离应用代码最近的 P 的位置，每个 P 都绑定了 mcache 结构，这个结构会有大小相应的缓存。本地分配内存时会优先从 mcache 中找，如果找不到就要从全局的缓存中去找，如果还是没有相应的内存块可以用的话，就需要去全局唯一的 mheap 请求，从操作系统重新划分一部分内存出来。不过 mheap 还有 area 结构，如果 area 还没有用完的话还是会从 area 里面去切分，如果用完了就会去操作系统中去申请。</description>
    </item>
    
    <item>
      <title>学点马克思主义哲学</title>
      <link>https://jupiterxue.github.io/posts/2021-11-05-learn_some_marxist_theory/</link>
      <pubDate>Fri, 05 Nov 2021 15:12:11 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-05-learn_some_marxist_theory/</guid>
      <description>前段时间组织了几个学过一点编程的小伙伴一起刷 Leetcode，在小组结营直播中，我向大家传递了陈云的思想“不唯上、不唯书、只唯实，交换、比较、反复”，并以此作为我们小组的核心思想。可能部分小伙伴会感到疑惑，一个刷题的小组还整些什么思想，老老实实刷题就好。老老实实行动是没有错，可问题就在于准备不充分、容易受挫、坚持不下去，几天下来就放弃了。
刷 Leetcode 题就像做数学题，会做就是会做，不会做就是不会，答案一看都懂，自己一做都错。同样的，在刷题的过程中也是，一学就废，一做就飘红。究其原因，还是思想方法不对。那么什么思想方法是对的，什么思想适用于刷题？陈云归纳的这几句话很适用。
在延安时期，他和毛大大有几次密切的谈话。因为大家都年轻，陈云当时认为，自己犯错误的原因在于缺少经验，而毛大大却说，犯错误的主要原因不是缺少经验，而是思想方法不对头。这样类似的话向他强调了三次，并建议他去学习点哲学。后来陈云果真开始认真研读马克思主义理论，尤其是马克思主义哲学；为进一步提高学习效果，他也成立了一个学习小组，并亲自担任组长。最初，这个小组只有十几个成员、30 多位干部旁听；后来，这个小组持续学习了四年多，也就是 3 阶持续行动，并被中共中央评为模范学习小组。
延安的学习活动给了陈云源源不断的好处，最大的收获就是掌握了维护辩证法的思想，他经过提炼和总结归纳出了 15 个字的核心思想：不唯上、不唯书、只唯实，交换、比较、反复。实事求是，是马克思主义的根本观点，是人认识世界、改造世界的基本要求，也是工作方法和领导方法。交换意见、集体讨论是达到全面认识的重要方法。通过比较能够弄清事物的本质。反复才能真正做好一件事。
虽然一般的刷题小组都强调务实，但善于务虚的刷题小组，很大可能性能够稳定进步，持续行动，刻意学习，原因就在于掌握了类似这样的正确思想方法。在我的小组中也是采取这种模式。
只唯实。个人成长的核心是持续行动与刻意学习，如果能够找到相同志趣的伙伴、感兴趣的领域、能够结合自身专业的技能，将这些结合在一起无疑是对自己帮助最大的、最有价值的。而如果没有这样的小组怎么办？那就自己来做吧。
交换。我和小组的一位同学交流过，发现她原来也有开小组的想法。第一个是因为这位同学探索出了专题学习的方法，也推动了小组自我评价的节奏。其次是因为我最近开始更文了，可能时间分配不够在管理上。所以就让她接替我继续运作小组。
**比较。**我对学习材料的选择也不是非常有把握，但有个比较清晰的思路。
1、找资料先想到平台，刷题在哪些平台很流行呢？
2、其次看评论，这里要注意的是保持平常心。就像买东西一样。会有好的评价也有不好的评价。关于好的看是否有自己很需要的，关于不好的亲自去看材料、去简单操作一下再来客观评价。
3、最后认真去学习材料，有看不懂的地方很正常，再去看其他解释直到学懂，就能拼凑出 “属于自己最好的学习材料”了。
**不唯上、不唯书。**小组采取短期运营，持续刷题的理念。每期小组存续期不超过一个月，也就开展到了第三期。刷题期间我们用了不一样的学习材料，通过对比知道了哪个材料的哪些部分更好。更重要的是，我们不能完全按照别人的攻略前进，所以也会偶尔回顾自己刷题的情况，再调整刷题的进度。
反复。我们小组采取了代码截图打卡和 自我评价 QA 的模式回答问题。这个过程大家能看到你的思路与困难，并且给予评价与帮助。每日打卡任务，我们采取作业分级制度。分为必做题和选做题。一般必做题都是一道 leetcode 题，选做题可能是一个或两个，包括：制定计划/专题练习题目/刻意学习学习材料/复盘预准备/辅助工具尝试使用等等。
总之，掌握了马克思主义的思想理论，让我们在刷题中不再感到些许迷茫，差的只是时间的积累和耐心的等待。
最后，如果你也位技术人，不妨学点马克思主义哲学，不会错的，指不定哪天当你拔剑四顾心茫然之时，想起这些实干家的思想，也能拨开迷雾见青天。
参考资料
[1] 何云峰：陈云——善于务虚的实干家，党的文献
https://mp.weixin.qq.com/s/q3in_4xWLoEqC91-FY1Tig
[2] 彭庆鸿、吴晓荣：陈云关于经济建设的几个思想和工作方法, 党的文献
https://mp.weixin.qq.com/s/BOE9Byofo72yPfl-MhFRpQ
[3] 缅怀陈云：新中国“掌柜” 一生清正廉洁（组图）,中国共产党新闻网
http://dangshi.people.com.cn/n/2015/0612/c85037-27145890-7.html</description>
    </item>
    
    <item>
      <title>像经济学家一样思考——烧焦的烤肉能不能吃？</title>
      <link>https://jupiterxue.github.io/posts/2021-11-03-why_cant_eat_burned_meat/</link>
      <pubDate>Wed, 03 Nov 2021 07:23:56 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-03-why_cant_eat_burned_meat/</guid>
      <description>前段时间读了一点点经济学的教材，其中一个话题很有意思“像经济学一样思考”。可问题是作为普通人我为什么要像经济学一样呢？读完我略有明白，因为经济学存在于生活的方方面面，大到国家政府，小到家庭开支与情感关系，都可以用经济学的思维去理解。
在此期间我没有搞懂一组概念 “内生变量和外生变量”，也不是能够说清楚“归纳法与演绎法”的本质与区别。又回去看了些视频才豁然开朗。借此机会认真分析了一个常见的问题“烧焦的肉能不能吃？”，最后来揭晓答案。
经济学是什么 曼昆认为经济学是研究社会如何管理稀缺资源，同时也是研究商品和服务在生产、分配以及消费时的社会科学。其实经济学也是门科学哲学，因为涉及到科学的理论，从观察到理论再回到现实去验证理论。它也有两个基本的准则：针对理论研究要讲逻辑，针对经验研究要讲证据。
所以《经济学原理》主要针对的是经济学理论，而《计量经济学》主要针对经济学经验的研究。这便是经济学的两条腿走路，既需要一些理论上的定理、推导、证明，也需要数据上去验证这些既定的理论是否符合现实。
在理论方面，比较常见的方法是构造假设，通过假设构造简化的经济学模型，才能去模拟现实，去预测问题的结论。
在研究现实问题时，选用正确的经济模型对于理解经济变量之间的因果关系至关重要。所以关键的是，当看到了一个现象之后它背后隐含的经济模型是什么。
当我们看到中国经济增长，收入差距在扩大的时候，背后的理论是什么？是收入差距带来了经济增长吗？还是经济增长带来了收入差距增大？数据，往往不能直接告诉我们因果关系，而需要人们去想办法，或构造一个理论模型，能够解释经济增长就能带来收入差距。或用更加严格的数据方法来区分因果关系与相关关系，进而得出二者的关系结论。
生活中常见的谬误 现实当中我们经常把因果关系和相关关系混淆，第一个原因是因为常常存在被忽略的变量。举两个例子：
 癌症是由打火机引起的吗？ 疾病是由肥胖引起的吗？  第一个例子中，研究者收集了大量、成千上万的数据来做统计分析，最终得出一个结论是：癌症是由打火机引起的。所以研究者就呼吁用打火机有害健康。这合理吗？显然这里犯了很简单的错误，因为忽视了吸烟，忽略了这第三个变量。目前我们主流的共识都是，吸烟引起了癌症、吸烟引起了家里有打火机，这才是更合理的解释。
而第二个例子疾病与肥胖的关系更为复杂了。既可能是疾病导致了肥胖，也可能是肥胖导致了疾病，还有可能是基因导致了疾病、缺乏运动导致了肥胖。
这里引出了，混淆关系的第二大原因——因果关系可能互换，也就是存在双向因果关系，尤其是错误地选择经济模型可能导致反向因果关系的错误。当我们看到一个 X 与 Y 正相关或负相关的关系时就要警惕了，究竟是 X 影响 Y 还是 Y 影响 X 呢？更加需要我们用逻辑去分析。还是举两个例子：
 警察数量的增加引起了暴力犯罪的上升吗？ 献血有利于人体健康吗？  很明显上面的结论是错误的，暴力犯罪上升才是引起警察数量增加的原因，人的身体健康了才更有利于献血。
所以当我们遇见一个结论的时候，第一反应不是看它说了什么，而是搞清楚里面有哪些关系，尤其重要的是搞清楚哪些是因果关系，哪些是相关关系。如果是因果关系的话，原因是什么，结果是什么，不要搞反了；如果是相关关系的话，第三变量是什么，还有没有其他因素导致了现在的结果。
回到最开始的问题“烧焦的肉到底能不能吃？”这里其实隐含着，吃下烧焦的肉是否有危害，更常见的一个生活传谣是“烧焦的肉会致癌吗？”。这个问题是不是呼应了以上的推理？没错，我们首先可以发现其中有两个变量，肉烧焦的程度和致癌可能性，并且可以明显知道致癌可能性不会导致肉烧得更焦，所以我们需要关注的是，是否有第三个变量更能够解释这两者的变化。
时间。肉烧焦需要一定时间，致癌需要一定时间累积。如果长时间食用烤焦的肉，那么很可能会致癌。而短期内食用少量烤得不太焦的肉，是没有太大致癌的可能性的。
这时化学家们又坐不住了，只要是肉烤焦了就会产生 XXX、YYY，那些都是致癌物。算了吧，要是吃一点就致癌了，我们茹毛饮血好不容易生起火的先辈们，在就在美味的烤肉中“灭绝”了。你看这个靠的金黄酥脆的五花肉，是不是很馋？没错，你的胃告诉我，你需要它。</description>
    </item>
    
    <item>
      <title>Day22 Go_memory_management</title>
      <link>https://jupiterxue.github.io/go-to-top/day22-go_memory_management/</link>
      <pubDate>Wed, 03 Nov 2021 07:20:48 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day22-go_memory_management/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go 翻山越岭——进程与虚拟内存的分布</title>
      <link>https://jupiterxue.github.io/go-to-top/day21-virtual_memory_management/</link>
      <pubDate>Tue, 02 Nov 2021 22:19:25 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day21-virtual_memory_management/</guid>
      <description>没想到继续更文已经是一个月半以后了。立个小小的 flag，到年底把 Go 基础与浅层的内核过一遍。保持两天一更的节奏。还是继续接着上期说的内存管理。了解了内存管理抽象的基础概念之后，来看一下一些具体的实现。
虚拟内存的分布 首先来看一下虚拟内存是如何布局的，这部分其实算是操作系统的内容。在《The Linux Programming Interface》这本书中提到了一张图，描述了 32 位操作系统大致的虚拟地址空间的分布是怎样的：
因为是 32 位操作系统，所以总的地址空间是 4 GB。可以看到上方是高地址，下方是低地址，所以可以看到以下几个特征：
 栈 Stack 是从高地址向低地址增长的。 堆 Heap 是从低地址向高地址增长的。 调整堆顶一般来说是调整的 Program break。  然后再来看看我们常用的 64 位系统中进程虚拟内存的分布是怎样的，摘自网络：
这张图可能不是很准确，感兴趣可以去官方文档，描述更加详细：https://www.kernel.org/doc/html/latest/x86/x86_64/mm.html 。
可以看到 64 位操作系统可使用的虚拟内存空间是增加的，并且基本上都是以 TB 为单位。但通过对比功能可以发现，其实 64 位内存的整体布局和 32 位的内存布局大差不差。
前面说到的都是单线程的情况，而在 Go 中我们会经常用到多线程，那么多线程的情况下，进程虚拟内存又是怎么分布的呢？一图就懂：
相比单进程，可以看到栈的变化最大。主线程的栈还是从上往下增长，但是其他的线程会分布在中间，并且中间会穿插动态链接库 Shared libraries、共享内存 shared memory。
而堆空间没有什么变化，但也意味着它对其他线程来说都是公用的。所以线程要访问堆上的东西都一般是需要加锁的。
OK，了解了虚拟内存地址分布情况，那么是谁来对内存进行分配呢？没错，有请下一位主角登场。
内存分配器 内存分配器 Allocator，理论上分为两种：
 线性分配器 Bump / Sequential Allocator 空闲链表分配器 Free List Allocator  线性分配器在分配内存时都是从虚拟内存中扒一点出来，下次还要分配又继续扒，继续扒 &amp;hellip; 如果中间有内存释放掉了 free，这些线性分配器也不会对这些被释放掉的内存进行复用。而如果我们现在的需求就是要对空间进行复用的话，就需要额外的链表来维护被释放掉的块，这也叫做空闲链表分配器。
一般线性分配器由于自身的局限，应到的地方少，所以我们继续深入研究一下空闲链表分配器。我们在看一些网文或博客的时候经常会看到，实现它的算法会有很多中类型，不过大致也就以下四种：</description>
    </item>
    
    <item>
      <title>放弃是正常的，不放弃才是奇怪的</title>
      <link>https://jupiterxue.github.io/posts/2021-11-01-five_up_is_normal/</link>
      <pubDate>Mon, 01 Nov 2021 23:04:34 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-11-01-five_up_is_normal/</guid>
      <description>今天在知乎看到一个话题《到底应该如何培养一个优秀的小孩》，其中一个回答是，关于兴趣爱好的培养。某答主的回答是：“非常简单，就是让小孩多去尝试。放弃是正常的，不放弃才是奇怪的。他很擅长了，但没有父母的要求或鼓励，他还是会经常做这件事。一般，这个就是大脑自然分布上的优点，就可以培养了。”看到这个回答我也很拍手称快。但反过来，试问我们成年人如何培养一个兴趣爱好。或许，更恰当的是，成年人如何找到自己长期想做的事？
小孩子可以经过无数次地尝试，直到找到自己感兴趣的事情，乐在其中。而成年人也有无数的无奈，直到看见别人做到了自己想做的事情，而自己没做到，低头叹息。但我想说，不必自己限制自己。小孩可以随意放弃一件事，成年人也可以放弃一些事。毕竟，放弃是常态。
昨天参加了一个活动面试，本来提前和负责人联系好、高高兴兴地准备了自我介绍，提前 10 多分钟到场。没想到轮到我的时间参加面试时，活动负责人拉我进了群，说了一句不是我，就又把我踢出去了，后来也没有什么解释。又什么都没做等了 10 多分钟，才有消息说轮到我了。
本来看上去是一件小事，因为活动繁忙将顺序弄错了，导致时间错乱、人员安排出错。但这个模式没想到就触发了我过去的经历所带来的创伤。从被踢出去开始，我就开始胡思乱想，为什么时间会差这么大，为什么没有人通知这种情况，为什么我会受到这种待遇。质疑、愤怒迅速冲上大脑，这股情绪一直延续到了晚上才得到好转。
后来在我冷静下来后，向负责人说，我想放弃这次活动，并说明了我的情况，她们也立刻前来道歉，并安慰和鼓励我，要走出过去的经历，不要让情绪和遭遇影响现在和未来一段时间。我也再次再次冷静下来，思考了这个问题。因为我当时就没有特别好的办法解决，也只是让时间过去慢慢好起来。而现在又触发了这种场景，第一反应也只是强烈的情绪。
关于情绪，还是需要自己给自己疏导。也许就像负责人说的，放弃这次活动并不能解决问题，但每个人都有每个人的生存法则，以支撑他们顺利渡过难关。客观评价了我自己还需要一定时间恢复，所以就放弃了这次活动。
不过，东方不亮西方亮。没有参与这个活动，还可以参加其他的活动，此处不留爷自有留爷处。我其实已经开展了两期刷 Leetcode 的小组，带领几个做技术的小伙伴，每天会保持一两道题的量，目前已经经过了一个多月，差不多刷了近 百道题。也逐渐开始想通最开始的问题。
成年人的崩溃可能是无声无息的，但总有能够克服的事情，自己愿意去做。也许为了生活，也许为了失去的梦想，也许还是不甘。成年人做成一件事其实也很简单，只要持续去做。
无论学习也好，健身也好，早睡保持健康饮食也好，这些都是逆人性的。在别人看来，你就是变态，可是你做到了，别人没做到，你持续去做，你就能把这件事做好。以变态作为常态，新常态替换旧常态。
这便是在我看来，成年人最后的倔强吧。</description>
    </item>
    
    <item>
      <title>读论文《Escape from Escape Analysis of Golang》</title>
      <link>https://jupiterxue.github.io/posts/2021-10-25-escape-from-escape-analysis/</link>
      <pubDate>Mon, 25 Oct 2021 23:20:11 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-10-25-escape-from-escape-analysis/</guid>
      <description>首先感谢谢大，推荐了这篇技术论文，我也很乐意读下去，因为一看到论文的标题 “Escape xxx Escape &amp;hellip;”，就立刻联想到了我最喜爱的乐队——逃跑计划。所以这篇论文也是很和我的“胃口”。
最近在练习 Leetcode 的过程中，会去阅读攻略教程，并且边读边看，边打开 process-on 思维导图-大纲模式去记笔记，也越来越能接受用思维导图去学习一个东西，这篇论文我也采取的这种模式，如下：
这篇论文是用 Go 语言实现，通过编译和更改源码来优化堆内存使用和降低垃圾回收内存使用率。并且提出了一个验证方法，将该“解释器”应用于 10 个开源项目、16个字节跳动的工业级项目中，结果表明，在开源项目中，堆分配平均降低了 8.88%，堆使用率平均降低了 8.78%，时间消耗平均降低了9.48%，垃圾回收的暂停累积时间平均降低了 5.64%。在工业项目找到了 452 个可优化的案例。别小看这些百分之几的优化，对于大公司来说，业务量都是在千万用户级别，能够降低百分之几可以说节约了好几斤钞票，又可以给员工发福利了。
对我来说，这篇文章标题很新颖，话题很新颖，论证也很新颖。所以有很大的热情能够读下去，即便是英语也没遇到太大的困难。不过后面的几个章节都还没概括出来，还需要再读一读，以后再多做这样的训练。
最后，地址都放在这里了，大家感兴趣可以康一康。
论文：http://www.wingtecher.com/themes/WingTecherResearch/assets/papers/ICSE20.pdf
Github 源码：https://github.com/wangcong15/escape-from-escape-analysis-of-golang</description>
    </item>
    
    <item>
      <title>Leetcode 刷题初探</title>
      <link>https://jupiterxue.github.io/posts/2021-10-13-leetcode-thinking/</link>
      <pubDate>Wed, 13 Oct 2021 23:04:46 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-10-13-leetcode-thinking/</guid>
      <description>题外话 已经有刚好一个月的时间没有写文章了，其实每天都会想着要写些什么，包括 Go 高级技术、《DDIA》的阅读进展，以及一些零散的即兴写作。其实之前写文章有接近日毕的好习惯，这真的是沿袭成长会的优良传统。虽然文章不一定写得好，但只要持续每天写，总有时间去做得更高，而不是一直在等自己状态好，一些补完所有学习/写文章等想法。
还有一点是我参与了成长会的写作日毕小组，借此机（ya）会（li）能够尽可能达到每天写文章的状态。而上个月的今天，也就是小组结束的时候，我也没有让自认为建立起的日毕习惯带动我继续写文章。还是得承认，我是个懒人。
但我也没有闲下来，这一个月的时间，刷了一些 Leetcode 题，一些思考和感悟和大家分享一下，包括为什么想刷题，如何刷题，学习材料，刷题的收获、小组氛围和自己的一些见解等。
开启刷题之路 为什么想刷题 其实很直白的就是为了大厂的面试。每个小程序员心中都有个纯粹地去大厂的梦。但发自内心还是想把算法能力提高，增加对编程语言的理解。然而在今年成长会中，暂时还没有适合自己的技术类小组，既然没有就自己做吧。我也是第一次尝试建立小组，想调动做技术类同学的一个学习氛围。
如何刷题 其实我是调研了许多 github 项目、知乎、简书上的攻略，然后总结了如下一个要点：
（1）短期大量训练。虽然小组是短跑，但想要提高必然要大量练习，不如在这个小组的压力下多 push 一下自己。一天中有时间就去刷一道题。
（2）刷题顺序。由于长期没有刷题的习惯，对算法生疏，对平台的机制不熟悉。先找简单题摸索，多通过些题，既培养刷题感觉、自信，也慢慢培养刷题的好习惯。刷通一遍简单提后，刷中等题。（据了解，大厂出题难度也就中等）
（3）刷题习惯，做难事必有所得。首先脱离一切，去看问题，写代码尝试，直到想不清楚逻辑、彻底忘记了某数据结构，然后先复习数据结构再刷题。还是没通过，找答案通过，然后手抄一遍并标记下来。
（4）学习习惯。每天精读一篇《刷题攻略》/ 刷一集刷题视频 / 一篇公众号博文 / 关注博主随便看看。
学习材料 已经开展了两期刷题小组，学习资料都是源自 github 中 star 很多的项目。
第一期我们用到的是 《LeetCode 刷题攻略》https://github.com/youngyangyang04/leetcode-master ，第一期简单刷了大部分后发现，这个材料还是零零散散。
所以第二期换了学习材料，用的是 《LeetCode Solutions》https://github.com/azl397985856/leetcode ，让我有点意外的是以下几点：
（1）相比上期材料，题目罗列更清晰，更有条理，也更好用来出题。
（2）没想到刷题还有浏览器插件，调研和试用了两个不错的：
	- **Leetcode Editor**，作为 JetBrains 全家桶中的编辑器能够按照插件，可以直接选择题目，并打开题目模板，不用自己再复制。（强烈推荐）  	- **leetcode cheatsheet**，作者给出的插件，提供了一些解题的模板，可惜只有 js 和 py 版本。（一些树、图、动态规划等题目可以先用起来）  （3）一直想了解一下 Anki，都没一个感兴趣的主题，没想到 Leetcode 也有，而且意外发现非常适合。
刷题收获 （1）刷题量，两道简单一道中等还行，但多一道中等就有点难受了。
（2）粗略复习了八种数据结构（数组、链表、哈希表、字符串、栈与队列、树、回溯、排序）和两种编程语言的常用基础语法（Python 和 Go 都用到了）。总结了：链表、哈希表、回溯、树类型题目中的关键步骤。
（3）尝试用不同编程语言实现算法，增加了对算法思想的印象、加深了对编程语言的熟悉度。 （4）掌握了一天当中刷题的节奏：</description>
    </item>
    
    <item>
      <title>2021 09 19 Ddia Chapter4</title>
      <link>https://jupiterxue.github.io/posts/2021-09-19-ddia-chapter4/</link>
      <pubDate>Sat, 18 Sep 2021 22:20:31 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-19-ddia-chapter4/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内存管理</title>
      <link>https://jupiterxue.github.io/go-to-top/day20-memory_management/</link>
      <pubDate>Sun, 12 Sep 2021 10:01:17 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day20-memory_management/</guid>
      <description>发生内存泄露时，要知道内存如何进行分配，垃圾回收要找出哪些对象有用，哪些对象无用。尤其当系统到达高并发瓶颈时，更需要垃圾回收这一角色做好风险把控，否则就是大型灾难现场。今天就来聊聊内存管理与垃圾回收。
背景介绍 垃圾回收 Garbage Collection ，我们一般称为 GC。在现实世界中，说到垃圾，指的就是那些不读的书、不穿的衣服等。在计算机中，GC 把程序不用的内存空间视为垃圾。但究其本质，GC 本身也是一个程序，如果满足两项功能的程序，我们就可以叫它 GC：
 找到内存空间中的垃圾 回收空间，让程序员能够再次利用这部分空间。  在没有 GC 的年代，像 C 语言程序员必须自己手动去分配内存，必须确保申请多少大小的内存空间，在程序执行完释放不再需要的空间。因为在当时计算机的内存资源是稀缺和昂贵的，现在我们买一个 G 内存条的价格相当于当时买 1 KB 的价格，所以程序员写代码时操作都是小心谨慎的。
人为操作，难免有疏忽的地方。如果忘记释放内存空间，该内存空间就会发生泄露。意味着这块空间将会继续维持被使用的状态，无法被使用。一部分内存泄露放任不管，直到所有内存被占满了，整个系统也就崩溃了。
另外，在释放内存空间时，如果忘记初始化用于释放内存的指针，这个指针就会一直指向释放完成的内存空间。更有甚者，释放的空间错误，导致下次程序使用这个空间时发生故障。这些内存上的 bug 都是难以确定真实原因的，因为与内存分配时疏忽造成的 bug 和真实场景下发生的位置（或时间）是不一致的。
为了略去以上种种的麻烦与困难，聪明的人们研发了 GC，即把内存管理的工作交给计算机，程序员就不用想着什么时候要释放内存，不用再担心忘记释放内存所导致的 bug，从而大大减轻负担，将更多精力和注意力放在业务开发上。
在学习难度上，如果说内存分配难度在 2 ，那么垃圾回收的难度就在 4，相比之下难度翻倍。并且学习垃圾回收必须掌握扎实的理论基础，否则难以读懂代码，不知道在干什么。有三本关于垃圾回收的书，可以去读一读：《垃圾回收的算法与实现》、《垃圾回收算法手册-自动内存管理的艺术》、《深入 Java 虚拟机》。
 实际上，Go 官方的 runtime 作者中能够去维护 GC 代码的人也很少。
据说，GC 是因为 Java 的发布而一举成名。
 基础概念 我们在学习内存分配的和 GC 的时候需要经常去问自己一些问题，顺着问题的思路去找代码会方便些。如果直接埋头去看 Go 语言内存相关的代码肯定会很蒙蔽的，毕竟内部数据结构真的很多。
 内存分配：
 内存从哪里来？ 内存要到哪里去？  GC 中标记流程：
 标记对象从哪里来？ 标记对象到哪里去？  GC 中清扫：</description>
    </item>
    
    <item>
      <title>2021 09 12 Ddia Chapter3</title>
      <link>https://jupiterxue.github.io/posts/2021-09-12-ddia-chapter3/</link>
      <pubDate>Sun, 12 Sep 2021 00:07:08 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-12-ddia-chapter3/</guid>
      <description>已经读完第三章，这里对前面三个章节做个总结，与其说是讲如何设计技术架构，不如说分布式技术的一些常识：
 后端和服务端都值得学习分布式 日志以追加写入更高效，分文件存放便于检索 图模型  第三章笔记 </description>
    </item>
    
    <item>
      <title>读经典《DDIA》-第二章</title>
      <link>https://jupiterxue.github.io/posts/2021-09-11-ddia-chapter2/</link>
      <pubDate>Sat, 11 Sep 2021 23:02:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-11-ddia-chapter2/</guid>
      <description>已经看完第二章《DDIA》，说下我是怎么抄书的，以及我有什么收获。
0.什么？抄书？没错，我是边抄边写笔记。因为我就和你一样，看不进书（当然你比我更自律点）。开玩笑啦
1.当你不想看书的时候，就抄书；当你抄书抄到不想抄了，就想看了。虽然这句话被 S 老师作为段子来传颂，但我看到了有人抄过化学，有人抄过高数。我没有这种经历，也想亲自去实践一下到底有怎样的魔力。其次，我认为好的书是浅显易懂，深入浅出的，值得揣摩。
2.求其上者得其中，求其中者得其下，求其下着无所得。刚开始抄书是一件有点兴奋的事，因为抄这个动作是比较轻松的，因为理想中这是不怎么动脑子的。实际上由于你的专注，你会不由自主地关注作者在说些什么（虽然有时也会走神不知道作者在说什么）。并且由于抄书，你会开始对作者某个词语进行或多或少的思考。而抄书的困难也正是源于此，认真看和思绪漫游会导致你的阅读速度极大地降低，尤其在你发现抄了一两个小时，连一半都没有的时候，心情是有点绝望的，好在，你还可以明天抄嘛：） giao！
3.实事求是，实地考察。抄书中，你会发现作者写的话有多少冗余、多少用词不当。尤其我看的这本书原版是英文，翻译过来连句法还是英语的语法，根本不符合中文逻辑。所以我会将这句话进行汉译汉，转化为我自己能够理解的。大家都认为看技术不要看中文，因为中文和蹩脚，是的。但我再补充一句，你可以自己把蹩脚化为流畅。
4.简明扼要，提高速度。一直这么慢的抄写肯定不行，我在抄的过程中也逐步掌握了一些技巧：着重摘录抽象句式和实用句式，代码复制（看代码其实是最直接和方便的），详细参数说明忽略，图能动就不抄，不能动就用文字描述，不能用文字就截图、先摘录一二级标题，然后一个个攻坚（会有点成就感）。
5.暴力破解，巨无事细。抄书意味着会对每个地方都看一遍，找出是否有价值的地方。所以会对每个文字做一次简单的“有什么有用，是否摘要”的编码动作，这不同于看书。看书的时候，我很有可能是在想“这个不重要，过”。所以抄一遍下来，老师如果问哪一页哪个知识点，虽然你答不上来在哪里，但你知道，我确实看过，而不是看，过了。
6.建立根据地，逐步发展。即便中文的技术书读起来不是很顺畅，但大体意思作者是能够把握。最重要的是，当我看完了中文，我会对原书作者讲了什么内容有个大概的把握。所以看起英文来就更加流畅。
最后，这篇文章不是给看中文技术书洗白，只是想表达我在参与过程中的收获和感受。按照成熟的技术方法来说，看书、看文档还是以官方为准，以原版语言为准。地道的语言和没有信息损失的一手材料，才是好的学习资料。毕竟，高级食材，我们都吃原材料。
和小伙伴讨论章节内容，一个意外收获：
  我说：几种 Datalog 方法都没有听过，没有见过。好像是在说图结构有哪些处理方式，怎么表示更简洁、更高效
Helios 回复：主要还是场景不一样。
场景说得好，看完就局限在代码层面，一下又跳了出来。
  第二章笔记 第二章
数据模型在软件开发中最重要。不仅影响软件编写方式，还影响解题思路。
多数应用用使用层层叠加的数据模型构建，关键问题：如何用低一层数据模型表示。例如：
\1. 用对象或数据结构以及 API 来建模现实世界。
\2. 用数据模式表示存储结构。如 JSON、XML、数据库表、图，
\3. 用内存、磁盘或网络字节表示 JSON/XML/关系/图数据，进而来查询、搜索、操作。
\4. 在更低层次，用电流、光脉冲、磁场或其他东西表示字节。
复杂应用程序有更多中间层，如 API 的 API。但思想仍一样：提供明确数据模型来因此更低层次复杂性。这个抽象使得不同人员能够参与协作。
选择一个适合数据模型非常重要。因为种类很多，易用但不易支持，可操作但表现差，数据转化有的自然有的麻烦。
关系模型与文档模型
最著名数据模型——SQL。1970年 Edgar Codd 提出关系模型：数据为关系，关系是元素的无序集合。
关系数据库起源于商业数据处理，今天来看显得很平常：典型事物处理。
&amp;gt; 如：将销售或银行交易，航空公司预订，库存管理信息记录在库）和批处理（客户发票，工资单，报告）
并且当时数据库迫使开发者必须考虑数据库内部的数据表示形式。关系模型解决的是在实现细节隐藏在更简洁的接口之后。
网络模型和分词模型在 70、80 年代的主要选择，但关系模型随后占据主导。对象数据库在 90 年代由盛而衰。XML 数据出现于 21世纪初。
2010 年，NoSQL 开始萌芽，虽名字没有涉及任何技术，最初只是 Twitter 标签，2009 年非关系数据库开源会上这个术语的出现，迅速得到了传播。NoSQL 被重新解释为不仅是 SQL（Not Only SQL），NoSQL 流行的几个因素：</description>
    </item>
    
    <item>
      <title>GO 翻山越岭——系统调用调试工具</title>
      <link>https://jupiterxue.github.io/go-to-top/day19-tools_and_sys/</link>
      <pubDate>Thu, 09 Sep 2021 22:43:41 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day19-tools_and_sys/</guid>
      <description>了解系统调用就能在业务发生问题时有更多招数，见招拆招。知道了系统调用的概念，有时候我们还需要用工具去实际观察进程是如何发起系统调用，对操作系统做了哪些请求，今天就来聊一聊。
观察系统调用工具 在 Linux 中我们常用用观察系统调用的工具是 strace，在 macOS 系统上常用的是 dtruss
案例1，通过 strace 可以看到一个 Go 进程的启动过程到底调用了哪些系统调用，这里有个例子（具体代码不用关注）：
使用 strace 指令 + 可执行文件x，看到了有哪些系统调用函数被调用。execve 执行哪个二进制文件，arch_prctl、sched_getaffinity 设计 CPU 亲和度，oepnat 加载相关文件，mmap 系统映射，gettid 获取线程 ID。
案例2，通过 strace 还可以查看一些软件的做了哪些系统调用，比如查看 nginx 的：
我们知道 nginx 在平时不服务的时候都是阻塞的状态，即阻塞在某个系统调用上。使用 strace 指令 + -f 参数 + nginx 可以观察它启动的过程。如果这个软件需要创建多个进程，就需要这里的 -f 的 flag 参数，跟踪所有刚启动线程创建的其他进程。最后我们可以发现 nginx 阻塞在 pid 为 224 的 epoll_wait 上。
注意：在 docker 中用这个命令可能会遇到一些问题，可以参考这个链接《Why strace doesn&amp;rsquo;t work in Docker》https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/
案例3，通过 strace 观察一个 Go 语言 Hello world 程序生命周期中系统调用情况。</description>
    </item>
    
    <item>
      <title>读经典《DDIA》-第一章</title>
      <link>https://jupiterxue.github.io/posts/2021-09-08-ddia-chapter1/</link>
      <pubDate>Wed, 08 Sep 2021 23:25:30 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-08-ddia-chapter1/</guid>
      <description>算是等了好久，终于有机会来读这本书《Designing Data Intensive Applications》，中文名《设计数据密集型应用》，我们一般简称《DDIA》或者猪书（因为书的封面是一头野猪，Hog Riderrrrr～！）。读完这本书第一章，我也想极力向推荐给计算机和互联网行业做后端和服务端的同学。阅读背景 最初了解这本书是在曹大（曹春晖）的第一堂课上。曹大说自己看了那么多书，只有这一本是最好的，也推荐给大家（当时听完就有点热血沸腾）。后来我还发现，draveness 大佬在它的《程序员可能必读书单推荐（一）》https://draveness.me/books-1/ 中最后一本也提到了此神书。再后来，又去豆瓣看了看，中英文都是 9.7 分：
简单介绍一下，读《DDIA》能够 帮助我们建立一个分布式系统的全局概念，但还需要根据自己所在行业、所处业务和所面对的需求。前面一些章节和 rpc 有关系，中间一些和存储关系比较大，后面将大数据和流式计算。内容比较全，看完就知道分布式系统有哪些问题。
一个人可以走得很快，而一群人能够走得很远。读这本书，其实我是参与了一个小组的 github 读书项目，如果你感兴趣也可以联系我，我们一起参与这次读书之旅。
好，话不多说，开始卷！（以下为我简明扼要摘录的笔记，可以快速浏览）
第一章笔记 为什么要设计 现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。
CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。
数据密集型应用：
- 存储数据
- 缓存
- 索引
- 流处理
- 批处理
看上去平淡无奇是因为数据系统在抽象层面做得非常成功。工程师常常直接拿来用，而不是自己去做开发，因为数据库已经足够完美。
然而现实中还有各种不同的需求：多种缓存，多级搜索。重要的是有必要先弄清楚最适合当前业务的工具和方法。当单个工具已经解决不了我们的问题时，组合使用也有些难度。因此本书在探索如何设计数据密集应用的方法，以实现可靠、可伸缩、可维护的数据系统。
数据系统的思考 按我们的常识，为认为数据库、消息队列、缓存这些工具都是有差异的，但我们还是归类为 数据系统当中。虽然新出现了许多数据存储工具和数据处理工具，但类别之间的界限越来越模糊，比如：数据存储可以作为消息队列（Redis），消息队列带有类似数据库的持久保证（Apache Kafka）。
当单个工具不足以满足所有数据处理和存储需求，就需要将总体工作拆分成一系列能够被单个工具高效完成，并且通过应用代码缝合起来。如缓存（Memcached）和全文搜索（ES）结合将主数据库剥离，由应用代码来让缓存或索引和主数据库保持同步。
一个可能的组合使用多个组件的数据系统架构
多个工具组合提供服务，服务的接口或应用程序编程接口 API 会向客户隐藏实现细节。
设计 DIA 会遇到问题：系统故障，如何保证数据正确性和完整性？系统退化降级，如何给客户提供始终如一的良好性能。负载增加，如何扩容？什么样的 API 是好的？
影响设计的因素：参与者技能和经验、历史遗留问题、系统路径依赖、交付时限、公司风险容忍度、监管约束。
本书重点讨论：
- 可靠性。在 adversity 中（包括：硬件、软件、人为 故障或错误）仍可以正常工作。
- 可伸缩性。合理应对系统增长（数据量，流量，复杂性）
- 可维护性。不同参与者，在不同生命周期都能高效地在系统上工作（适应新的应用场景）。
可靠性 常见期望：
- 符合用户期望的功能
- 允许出错，还能正常使用软件</description>
    </item>
    
    <item>
      <title>GO 翻山越岭——Go 常见系统调用</title>
      <link>https://jupiterxue.github.io/go-to-top/day18-go_and_sys/</link>
      <pubDate>Tue, 07 Sep 2021 07:28:31 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day18-go_and_sys/</guid>
      <description>系统调用，是操作系统内核为应用提供的 API。今天继续来讲一个系统调用案例和 Go 中常见系统调用
   arch syscall NR return arg0 arg1 arg2 arg3 arg4 arg5     213 epoll_create man/ cs/ 0xd5 int size - - - -    来源：https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit
这是 Linux 中的系统调用，编号是 213，我们可以从一下代码了解更多信息：
1# define SYS_epoll_create 213 2 3TEXT runtime.epoll_create(SB), NOSPLIT, $0 4	MOVL	size+0(FP), DI 5	MOVL	$SYS_epoll_create, AX 6	SYSCALL 7	MOVL	AX, ret+8(FP) 8	RET 编号 213 按照调用规约会被存储在 rax 寄存器中，也就是这里的 AX 寄存器。epoll_create 只有一个阐述传递，也就是 int 类型的 size。SYSCALL 直接进入内核去了。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——系统调用基础</title>
      <link>https://jupiterxue.github.io/go-to-top/day17-lang_and_sys/</link>
      <pubDate>Mon, 06 Sep 2021 20:26:32 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day17-lang_and_sys/</guid>
      <description>编程语言和操作系统之间的桥梁，也就是我们所说的系统调用。今天来聊聊，系统调用的基础概念。
什么是系统调用 我们在了解系统调用之前，需要对操作系统有个简单的了解。操作系统（operating system,OS）是资源的管理器，也是计算机系统的内核与基石，其管理的资源都是经过了抽象。而对计算机来说，资源是硬件信息：CPU、RAM 内存、I/O 设备，以及进一步抽象的软件资源，如进程。
为什么说操作系统是对资源进行了抽象呢？因为操作不方便、操作不安全，我们平时接触到的不是直接的硬件，比如磁盘操作，不会去操作扇区（嵌入式系统除外）。而我们所面对的都是这些：
 磁盘抽象：文件夹 内存抽象：虚拟内存 CPU 抽象：时间片  有了操作系统，我们对计算机的调度还是不够的。说白了，操作系统也是一个应用程序，底层还是一堆代码和汇编指令。这时候，我们需要由硬件提供支持，在应用和操作系统之间进行一层或多层隔离。
CPU 已经为操作系统提供了特殊的安全支持——分级保护域（protection ring）。操作系统内核运行在特殊模式下，即图中的 ring-0 ，而应用运行在 ring-3，但权限被严格限制。因此，在代码中我们没办法直接去调用系统资源，就需要操作系统帮助我们去调用，并把相应的操作抽象成 API 来供我们使用。
 Intel64 有四个特权级别，不过实际上只用到了其中两个 ring-0 和 ring-3。ring-1 和 ring-2 本来计划是为了驱动程序和 OS 服务用，不过流行的 OS 们都没有接受这个方案。
 说到这里，答案已经揭晓。系统调用，是操作系统内核为应用提供的 API。可以理解为内核为应用提供服务，操作系统就位我们的上层应用程序提供了一系列“标准库”。比如我们常见的后端服务：APP 发起请求 request → 操作系统 Operating System 接收、处理并响应 → APP 接收 response。
 对于应用来说，系统调用可以实现超出自己能力以外的事情。
 那么 Go 语言中的系统调用是怎样的呢？在此之前，还需要提及 Go 语言调用规约。我们在做函数调用的时候没有使用寄存器，而是将参数都放在栈上。但在其他编程语言中做参数传递和函数调用都是用到了寄存器。举个例子：
1func hello() { 2 x, y, z := 1, 3, 3, 3 3 a, b, c := multi(x, y) 4} 5 6func multi(x, y int) (a, b, c int) { 7 r, s, t := 1, 2, 3 8 return x+1, x+2, x+3 9} 这段代码的调用规约如下：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Context</title>
      <link>https://jupiterxue.github.io/go-to-top/day16-data-structure_context/</link>
      <pubDate>Sun, 05 Sep 2021 15:48:38 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day16-data-structure_context/</guid>
      <description>Go 语言在 1.16 版本之后加入了新的内置数据结构 Context，虽然在代码中使用都比较简单，但语言内部还是做了许多区分，今天来分析一下 Context。
Context 虽然在使用 context 的时候，看起来都是 context.* 的结构，但 Go 语言内部做了这样一个区分：
具体说明如下：
 emptyCtx：所有 ctx 类型的根 valueCtx：主要为了在 ctx 中嵌入上下文数据，一个简单的 k 和 v 结构，同一个 ctx 内只支持一对 kv，需要更多的 kv 的话，会形成树形结构。 cancelCtx：取消程序的执行树 timerCtx：在 cancelCtx 上包了一层，支持基于时间的 cancel  这里有个例子
1package main 2 3import ( 4 &amp;#34;context&amp;#34; 5 &amp;#34;fmt&amp;#34; 6) 7 8type orderID int 9 10func main() { 11 var x = context.TODO() 12 x = context.WithValue(x, orderID(1), &amp;#34;1234&amp;#34;) 13 x = context.</description>
    </item>
    
    <item>
      <title>反法西斯胜利，再读《毛选》</title>
      <link>https://jupiterxue.github.io/posts/2021-09-03-anti-jp-victory/</link>
      <pubDate>Fri, 03 Sep 2021 23:00:50 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-03-anti-jp-victory/</guid>
      <description>今天是个特殊的日子，9月3日更是个特殊的日子，从1945年开始的到今天、以后每年的9月3日也是最为特殊的日子——中国抗日战争胜利纪念日、世界反法西斯战争胜利纪念日。虽说是纪念战争胜利，但那个人伏案奋笔疾书的样子依旧在我心头萦绕，他就是我们可爱的毛委员。
大家都习惯尊称他为毛主席称，其实毛主席更希望群众称他为“毛委员”。在1927年3月完成的《湖南农民运动考察报告》后，他提到：“我到各处，常常遇到这种人，这样向我求情：‘请省里来的委员作保！’，自此大家都开始称他为，毛委员。
再读《毛选》 今天又重新翻了翻折满边边角角的《毛选》，按照时间线简单梳理了几篇比较耐看的文章：
第一卷：
 《中国社会各阶级的分析》	《湖南农民运动考察报告》
《中国的红色政权为什么能够存在？》 《星星之火，可以燎原》
《反对本本主义》	《论持久战》
《论反对日本帝国主义的策略》	《中国革命战争的战略问题》
《实践论》	《矛盾论》
 第二卷：
 《〈共产党人〉发刊词》	《新民主主义论》
 第三卷：
 《论联合政府》
 想到了什么 谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。——《中国社会各阶级的分析》
在真实世界有很多以上类似的情况，一个东西的表现和本质有差异。我们应该更多地在于发现一个事物它本来的样子，然后去接受它本来的样子，而不应该以我们自己的设想去看事情。
许多农民运动的道理，和在汉口、长沙从绅士阶级那里听得的道理，完全相反。——《湖南农民运动考察报告》
当你开始做一些事情的时候，有些东西和成长励志故事的逻辑是相反的。
有些同志在困难和危机的时候，往往怀疑这样的红色政权的存在，而发生悲观的情绪。这是没有找出这种红色政权所以发生和存在的正确的解释的缘故。——《中国的红色政权为什么能够存在？》
有些人会害怕走弯路，但只要花费了脑力、体力一定会有收获的。尤其做难事必有所得。
我们在红军中工作的人，一遇到败仗，或四面被围，或强敌跟追的时候，往往不自觉地把这种一时的特殊的小环境，一般化扩大化起来，往往不自觉地1把这种一时的特殊的小环境，一般化扩大化起来，仿佛全国全世界的形式概属未可乐观，革命胜利的前途未免渺茫得很。—— 《星星之火，可以燎原》
有些时候我们遇到小问题，会把它推演的过于悲观
中国全国都布满了干柴，很快就会燃成烈火。—— 《星星之火，可以燎原》
任何前进的方向，都有失败的可能。但对未来的良好信心，来自于一个基本面的判断。当抓好了基本面，就不怕上上下下的起伏。
结语 其实，《毛选》不仅仅是军事战略者常看的书，现今天的创业者也很热衷于此，更让你我没想到的是，还有一篇文章叫做《婚恋大事问毛选》。可以说《毛选》已经进入了我们家家户户，承载了我们中华文明最灿烂的一刻。
推荐大家去看一部电影，最能近距离感受到毛委员的亲切——《古田军号》。故事情节紧凑，人物细致，尤其细节做得很好，陈毅反复划窗以表思念、毛泽东得了疟疾而党员们在想怎样给他弄到金鸡纳霜治疗、朱毛会师时双手握手的交付，新泉会议时朱毛同板凳共思想屁股决定脑袋等等。
最后，感谢毛委员，给了我们这样一个盛世。</description>
    </item>
    
    <item>
      <title>业界大数据备份，还看爱数</title>
      <link>https://jupiterxue.github.io/posts/2021-09-02-bigdata-backup/</link>
      <pubDate>Thu, 02 Sep 2021 23:28:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-02-bigdata-backup/</guid>
      <description>随着进入信息时代，各行各业的数据都在爆炸性地增长，给人们带来便利的同时，也给人们对安全的担忧更胜一筹。目前，数据容灾备份领域呈现蓬勃发展，尤其在大数据软件灾备板块现实出了极大的市场潜力，比较知名和具有潜力的灾备公司有：爱数、精容数安、鼎甲科技。今天就来聊聊行业龙头“爱数”的大数据保护方案 Anyway。（图没有放，感兴趣可以看看参考资料）
行情介绍 市场情况——大数据平台市场规模持续增长
全球规模：4813.6亿 RMB
中国大数据软硬件：677.3 亿 RMB
中国大数据软件：92.2亿
预计未来5年大数据平台市场平均增长率为 25%
大数据分析业务，很重要，也是主要业务之一
应用行业
金融、医疗、电力、交通 等等各行各业
风险
一旦丢失，业务连续性无法得到保障！
三个主要问题：
  风险无法预测
  物资无法调配
  应急调度无法指挥
  挑战与常见问题（各行各业）
- PB 级数据，如何在有限的备份窗口内完成备份？
- 长时间保留海量大数据备份副本，如何降低成本？
- 如何确保备份数据的安全存储与合规保留？
- 如何实现精准备份和异构版本兼容？
爱数——AnyBackup 大数据平台保护方案 整个方案可以为不同大数据平台提供备份和恢复的能力，包括：Apache Hadoop、华为 Inside、CLOUDERA CDH、星环科技 TDH。
在这些大数据平台下，爱数能够提供的备份能力：面向表级别粒度的备份恢复、数据一致性问题、基于 hdfs、hive 等不同组件来实现永久增量备份和多节点之间并发备份，还提供重复数据删除等基本能力。
提供的恢复能力：表级粒度恢复，多并发恢复，任意时间点恢复，不同大数据平台之间异构的恢复能力，
爱数还提供的独有能力：96 倍备份效率，90% 存储资源节省，数据安全存储和规范，面向不同的大数据平台、不同大数据组件提供全面保护
具体说明-爱数的特点
 提升 96 倍以上备份效率  传统备份方案，全备数据量要备份 1PB，备份时间在 6-7 天。
爱数完成全备后，后续都是增量备份，并且以 10T 为单位。在更短的备份窗口中完成全备
节约 90%存储资源  通常在给用户做备份策略配置的时候，是保留一个月备份数据。其中会进行四次全备，每天实现增量备份。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Map</title>
      <link>https://jupiterxue.github.io/go-to-top/day15-data-structure_map/</link>
      <pubDate>Thu, 02 Sep 2021 23:23:12 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day15-data-structure_map/</guid>
      <description>Map 有时能够返回一个值，有时候能够返回多个值，这是 Map 的特权语法。今天继续从底层角度来聊聊 Go 语言内置数据结构，Map。
Map Map 中大量类似但又冗余的函数，原因之一便是没有泛型。
1package main 2 3var m = make(map[int] int, 10) 4 5func main() { 6 v1 := m[1] 7 v2, ok := m[2] 8 println(v1, v2, ok) 9} 利用之前提到的工具 go tool objdump 能够获得反汇编后的函数：
 make → runtime.makemap 10 → hint m[1] → runtime.mapaccess1_fast64 m[2] → runtime.mapaccess2_fast64  以上这些过程都是编译器帮我完成的，编译器判断赋值语句，如左边有一个值就翻译为 runtime.mapaccess1_fast64， 需要注意以下三点：
 当 hint 大小大于 8 时，采用的是 makemap 当 hint 小于 8 时，采用的是 makemap_small map 分配栈上时，不一定会调用 makemap  为什么一个 Go 语言内置数据结构就有这么多情况，那如果 Go 的 20 来个内置数据结构都有这种判定，岂不是底层就有差不多 60 个不同判定结构？确实是这样的，map 中存在大量类似但又冗余的函数，但不至于把性能拉低很多。这种问题主要是原因之一是 Go 语言在 1.</description>
    </item>
    
    <item>
      <title>关于借钱那点事</title>
      <link>https://jupiterxue.github.io/posts/2021-08-31-borrow-money/</link>
      <pubDate>Tue, 31 Aug 2021 18:24:02 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-31-borrow-money/</guid>
      <description>人家跟你借钱的时候，你怎么办？这是个我很感兴趣的问题。因为现在没遇到，以前多半碰到过，以后也很有可能发生。这里先谈一谈我的观点，再谈谈思想大家的观点，最后来看看热心网友的观点。
我的观点 被借钱
 走在繁华街道上有人借，不管男女绝对不借。（上过两次当） 同学可以借，小额起步；有借有还，再借不难；小都还不起，就以昔日情谊来安慰自己，忍痛删除拉黑。 亲戚、很好的朋友，借，数目稍大还是要做好欠条、语音记录与确认。 同事借有个心理预期，不超过你对他的心理预期。 陌生短信、电话一律不借。 P2P 放贷，有平台担保，可放出小额，赚一点点。千万别放多了。 借钱学习、买课，不建议，不提倡，不支持，但自己可以做，所有风险自己抗。  以上所有都基于量力而行，其他情况一般不借。
去借钱
 优先找父母借，还钱要以 1.5倍以上还；不定期无理由给他们大半月工资（虽然父母都说是帮你存着）。 花呗、白条、美团月付赶紧关，除非实在抽不开再用。月初先关闭。 P2P 借贷绝不能碰，利滚利一家人都拉下水。 房贷优先考虑用公积金。 不找同事、不熟悉同学借钱，免得搞坏自己的名声。 向好朋友借，理由充分，有欠条和留底。  以上所有都基于维持生存，其他情况自己克服。
国学大师的道理 来看看国学大师，曾仕强老师是怎么说的：
借钱给别人的原则有两个：
一、对朋友有通财之义
这要看平常有没有交情。有的人向你借钱是最亲密的，叫你一声大哥、表哥让你舒舒服服，但借了钱后一个电话没打过，一个消息都没发过；过了两年又来，哥~。这种人借钱给他干什么，他平常根本不把你当朋友。
二、救急不救穷
穷救不了，救急可以。朋友在一关通过了，在另一关卡住了，你就帮帮他一下。你这次帮他，他还没有过关，下次还是没有过，那么你干脆让他置之死地而后生，那是他的事了。
这两个原则，都应该作为教育，传承下去。
我们每个人进入社会开始赚钱，一定要定期地、定量地，奉养父母。不管父母多有钱，父母可以津贴你，是双轨进行。当我们有经济困难、学业困难，父母自己即便再拮据，一般来说都会想办法来资助我们。而如果我们赚了钱，都自己藏起来自己用，到时候向父母借，恐怕父母也不会相信的。
还有一个场景。朋友问你身上有没有钱，你说没有多少，那是多少？五百，好，那借我三百。你就全完了。更好的回答是，你身上有没有带钱，没有。什么事情就都没有了。因为你没有权力问我有没有钱，是这个人的错，不是这个人骗人。我们常常把这个倒果为因，不会保护自己，最终害死自己。
而如果你的朋友告诉你，我是想给妈妈买点菜，出门忘了带钱，只需要三百，明天就还给你。那么即便你不借，其他人也会很乐意借的。这是知所先后
热心网友怎么说 ansonsiva：20 岁还想着委婉点，35 岁就直接说不借，45 岁我就要说滚了
Xushet：连一句“没钱”都说不口？
kindjeff ：
我很理解你的困难，如果我有的话，肯定会帮你的，我现在都是借网贷，现在每个月过的是东借西还的日子，如果你确实困难，你也可以借网贷周转一下 一般在大卖场冷冻柜区域有试吃煎饺馄饨之类的，卖平底锅的地方也会随机刷新试吃点 商场内肉干或蜜饯试吃，美珍香之类的肉脯常年试吃，可以吃一点含嘴里，回去下饭 大卖场熟食区 19：00 以后半价，烤鸡 9.9 左右可入，下饭能吃两天 住宅小区内有橘子树的建议全部摘光备用 幼儿园一般会种植一串红，花芯有蜜，可以补充糖分 献血可以喝到牛奶 给男生介绍女性朋友可以蹭饭一顿，建议多点一些，这时候男生不会阻止
no1xsyzy ：“如果有人借钱给我，就是把这段时间中我用这笔钱赚的钱送给了我”——本杰明·富兰克林
Jirajine：
法一：不回复。微信虽有千般不好，不显示已读倒是个优点。
法二：反向向对方借钱。
法三：趁机推销网贷，还能拿到 aff 赏金。
AngryPanda：和他说要给利息。就可以了。
kop1989 ：
1 、拒绝。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Timer</title>
      <link>https://jupiterxue.github.io/go-to-top/day14-data-structure_timer/</link>
      <pubDate>Mon, 30 Aug 2021 23:13:54 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day14-data-structure_timer/</guid>
      <description>上期 Go 文章说道了 Go 内置数据结构，从底层源码角度简单地描述了 channel。今天继续分析其他的内置数据结构 Timer。
Timer Timer 在 golang 1.14 版本以前比较简单，整个 Timer.go 文件中代码 才 700 行左右。整个代码就是一个数据结构和许多 goroutine。但 golang 到了 1.14 版本以后，由于官方的升级维护就变得非常复杂。所以这里笔者简单讲一下 Timer 的迭代历史，状态机制不会涉及到。
从这张图可以看到**，最早的 Timer 就是一个四叉堆**。我们平时写算法的时候二叉堆见得比较多，那是不是理解这个更困难？不是的，我们着重看 Timer 的结构和演进。像最早的 time.Sleep 或者 time.After 这两个函数，实际上我们创建了两个 Timer 类，这个 Timer 会最终加到我们的 runtime 维护的四叉堆里面。这个四叉堆其实是很好理解的，其实是有个基准的。
堆顶要放什么元素，元素如何排列？都是以触发时间为准。也就是说离当前时间最近的，一定是在堆顶的。如果来了一个新的 Timer ，它是在这个时间之后，它就会继续往堆下面走。如果比堆顶小就会涉及到对当前四叉堆的调整了，这个和写二叉堆调整算法很类似。
最老的 Timer 实现全局只有一个四叉堆，这个四叉堆专门启用一个叫做 timerproc 的 goroutine。这个 goroutine 的逻辑也不复杂，就是用一个 for 循环。这个 for 循环会不断地检查堆顶元素是不是已经到期了，如果到期了就会触发，在触发的同时会逐渐地调整堆，直到把所有需要触发的 Timer 都触发完毕为止，继续去休眠。
但这种单一的四叉堆会有一个问题。当前 Go 程序所有的 goroutine 在执行 Timer 相关操作的时候都需要去抢占操作这个堆的全局锁，而其实这个锁都是写锁。如果并发量很高，那么就会导致程序整体的吞吐量下降。全局锁对于任何程序来说，性能影响都比较大，这个问题导致了 go 程序在多核处理器上性能不佳，有人专门提了一个 issues：https://github.com/golang/go/issues/15133。（就 python 来说， 虽然 python 支持多进程，也支持多线程。但因为 GIL 全局解释器锁的存在，python 的多线程程序在同一时间只有一个线程在运行。所以多线程 Python 程序只是并发，而不是并行）</description>
    </item>
    
    <item>
      <title>2021 08 29 Two Meal</title>
      <link>https://jupiterxue.github.io/posts/2021-08-29-two-meal/</link>
      <pubDate>Sun, 29 Aug 2021 18:24:02 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-29-two-meal/</guid>
      <description>昨天闲来无事，历时3小时，自己动手做了两道菜：酸汤肥牛和清炖排骨。自己很少做菜，也几乎没怎么做过菜，没想到第一次做出来味道也还可以，但也有几个踩坑的地方，今天来复盘一下。
买菜篇 一是被推荐有个小程序“叮咚买菜”，二是平时通勤发现外卖小哥都有专门送叮咚买菜的车和衣服，三是因为是新人注册，有满减优惠券。有了网上买菜+配送，打消了我不想出门、不想到处逛选菜的麻烦；有了满减优惠，让我忍不住多买了些食材：
 肥牛卷 300 g，24 玉米 550g，9 山药片 200g，6.5 鹿茸菇 125g，2 番茄 500g，3 猪肘块 350g，10 绿豆芽 300g，2 排骨 300g，20 金针菇 200g，5 酸汤肥牛调味料 95g，12 贴心调味组合（小米辣+蒜+姜） 120g，4 泡菜组合（小米辣+豇豆+青菜）850g，6.5 蒜蓉酱 240g，12  新人卷 45-20、49-19，所以最后开销为 77 元，真的没想到自己买菜来做这么便宜，两个菜的食材价格能够顶得上外面一个菜的价格。
小细节 网上下好单，叮咚买菜的小哥过了大概30分钟就提着大包小包送到了我的家门口。像易碎的蒜蓉酱（瓶装）还单独给我装了一个轻拿轻放提醒的袋子，隔绝了其他菜。小哥还很热心地自我介绍了一波。
食材处理篇 提前在 B 站上看一两个做菜短视频，熟悉了清炖排骨整个流程。
因为买了排骨和猪蹄肉块，担心有腥味。所以先用冷水+一点料酒提前浸泡了一个小时，然后跑到一遍去玩了：）
轻煮肉块。将浸泡料酒的肉冷水下锅煮，煮到没有血色就捞起。这里失误了，因为没有加姜葱蒜一起去腥，所以重新来了一遍，把肉捞起来，加入姜葱蒜，再煮了一会儿。
香煎肉块。锅热倒油，将煮好的肉块放入进去，煎到有点紧实和焦黄。
小火慢炖。往煎好的肉中加入少量料酒，再导入热水，盖上盖子小火炖煮一个小时。
在这个期间开始准备另一道菜，同样的先看了看两个酸汤肥牛的短视频，然后动动手了。
先将玉米切块，番茄分别切块（给清汤）和切碎（给酸汤），山药片和鹿茸菇都直接洗出来。金针菇和绿豆芽也直接洗出来，但总感觉不放心，去分别看了看大厨怎么处理这两个食材的。然后我也把金针菇的根切掉很多，把绿豆芽的头和尾都掐掉。
40分钟小时后将切好的玉米、山药、蘑菇都加到了清汤里和排骨猪蹄一起炖煮。
在这期间把肥牛拆开用冷水浸泡一分钟，过滤掉血水。烧热水，在锅中过5秒豆芽，过5秒金针菇。这里金针菇应该过 15 秒，所以捞出来看起来还有点生。
准备肥牛汤。锅热导入少量油，然后放入干辣椒、蒜蓉酱、姜、蒜，爆炒1分钟的样子，然后加入清水，把干辣椒、姜都捞出来。等到水热后加入肥牛汤料。
烹饪 清汤排骨猪蹄。在合着玉米、山药、蘑菇煮了一个小时后，加入番茄块煮10分钟。然后加入一点盐和鸡精。美味就起锅啦！
酸汤肥牛。在肥牛汤准备好后，加入肥牛煮熟，不需要多久。因为担心金针菇没有熟，就在肥牛煮熟后放进去再煮了一会儿，再加入绿豆芽。这里也弄错了，导致肥牛吃起来很老，应该先把肥牛、金针菇单独煮好，然后放进热汤中。
最后，两道菜就都成功啦。吃到我撑了，还想再吃一块排骨或者一夹脆脆的绿豆芽与金针菇。
总结总结  网上买菜非常方便，新人还有巨大优惠（快薅羊毛）。 处理肉类时，用到姜蒜葱和料酒一起提前煮可以去腥味。并且，料酒还是个煮汤的好伙伴。 易熟的菜和肉不能久煮，最后起锅、开动前再加入即可。 自己做菜自己吃，健康好吃还能吃，就是有点费时间。  </description>
    </item>
    
    <item>
      <title>2021 08 29 Minimalism</title>
      <link>https://jupiterxue.github.io/posts/2021-08-29-minimalism/</link>
      <pubDate>Sun, 29 Aug 2021 18:21:22 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-29-minimalism/</guid>
      <description>前几天看到 “S522-花样”同学写的一篇文章《极简=极奢》，今天想来谈谈自己对于“极简主义”的想法和认知。
乔舒亚在《极简主义》中的概括为：极简主义不是要你一无所有，而是要你穿越物质的海洋，找到真正重要的东西。
虽然极简主义起源于 60 年代，但真正蓬勃发展，我想很大可能是因为史蒂夫·乔布斯。
最初了解到“极简理念”是在李善友老师的《第一性原理》中讲解“乔布斯专题”中的一个苹果公司动画，当时这个动画真的惊艳到我了，怎样的设计理念才能做出如此佳作，仅仅是黑白线条、原点和文字，就能尽情表达：行云流水，自然流畅、灵动跳跃、坠落与水流、突破预期、如吹自然界的风、如朋友间的沟通。话不多说，你可以康康：《苹果广告——至繁归于至简》https://www.bilibili.com/video/BV1Rs411E7Pw?from=search&amp;amp;seid=13506173852847306812
因此，我从18年到现在，就一直很喜欢关于“极简主义”的话题。尤其在看《乔布斯传》的时候特别痴迷，《乔布斯在他的家中，1982年12月15日》，这幅图片一直印象深刻（虽然每次看都像是汤姆·克鲁斯），每当我想到极简生活就会联想到：https://o.aolcdn.com/images/dar/5845cadfecd996e0372f/81062ddbeaac7699cf47b901b18adebdb48c046d/aHR0cDovL3d3dy5ibG9nY2RuLmNvbS9jbi5lbmdhZGdldC5jb20vbWVkaWEvMjAwOS8wMS8wNjJiLmpwZw==
![u=1816380262,1947610985&amp;amp;fm=173&amp;amp;app=25&amp;amp;f=JPEG (1)](C:\Users\Xfavor\Desktop\u=1816380262,1947610985&amp;amp;fm=173&amp;amp;app=25&amp;amp;f=JPEG (1).jpg)
这张照片拍摄于乔布斯27岁，并登上《时代》杂志封面。正如乔布斯给这张照片写了题词：&amp;ldquo;这是一个经典时刻。我独自一人，所需要的不过是一杯茶、一盏灯和一台音响。你知道，这就是我的全部。&amp;rdquo;
很喜欢像乔布斯当时所处的环境，一盏灯、一个什么都没有的空荡荡的房间，当时在大学就在想，我以后的生活，也想这样过。后来，现在自己也确实在这样做（当然遭罪的是自己）。然后慢慢体会到，极简是从最简单开始，而生活不是苦修，需要什么再慢慢添加什么。
再后来，读到一篇王垠对苹果手机 Home 键的批判中终于脱离了这种类似宗教的信念。王垠说到，虽然苹果手机在界面上之保留了一个按钮，给用户带来了极大的简化，但内部的细节无疑非常复杂，给维护的人员造成了极大的复杂。所以，极简一说也有对象之分。
不过，现在的极简主义的理念也逐渐被商业化了。相比于消费主义和物质主义，无疑减少自己的欲望、少购物是极简主义所倡导的。但商业总是无孔不入，商业是制造需求。既然我们那么崇拜极简主义，那么就推出看似极简的产品与服务让你购买。并且这些产品旁通常还放有单一色彩的广告语“拥有的越少，生活过的越有意义”之类的语录。正是这种类别划分，将极简主义完全商业化。越来越多自称为“极简主义者”的人忙着营销和收割。
如今，大家都在提倡极简，时尚极简、家具极简、生活极简，甚至精神极简。这些都没有问题，甚至是好事，因为在这样一个复杂度不断增大，熵不断增加的世界，有人在反向探索。探索社交的初心，探索生活的放心，探索精神的静心。商业社会虽然会把种种妖魔化，但并不阻碍探寻真相的勇士逆流而上，找到那个本源，找到那个一。
[1] 从苹果产品的设计错误学教训, 王垠
http://www.yinwang.org/resources/ciia1.pdf
[2] 极简主义, 豆瓣
https://book.douban.com/subject/34901087/
[3] 极简主义真的能让我们更快乐吗？
https://www.thepaper.cn/newsDetail_forward_7120725</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Channel</title>
      <link>https://jupiterxue.github.io/go-to-top/day13-data-structure_channel/</link>
      <pubDate>Sun, 29 Aug 2021 14:47:52 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day13-data-structure_channel/</guid>
      <description>内置数据结构是一门编程语言的基础核心，了解基本语法就能够让我们进行简单的开发。今天开始，就来系统地研究 Go 语言内置数据结构。
首先，先来看看所有的Go 语言所有内置数据结构都有哪些，如下图所示，列出了思维导图：
既然是系统地研究，这里就需要用到暴力破解的思想——把每个数据结构都遍历吃透。
Channel 之前的文章中提到了通过反汇编调试工具来查看 Go 语言的源码。还提到了三种情况会导致 panic 的关键函数 chansend、chanrecv，下面来进行源码逻辑分析。忽略一些细节实现，来看看 chansend 的流程图：
图上省略了：
 select dafault 的情况。 逻辑执行时碰到 ch 已 close 的情况。  从流程图，能够清晰地看到 在 chansend 的内置函数中，Go 语言是如何处理我们发送的数据。紧接着我们再来看看 chanrecv 的流程图：
图上也省略了：
 select default 的情况。 逻辑执行时碰到 ch 已经 close 的情况。  对比发现，两个流程差不多，因此 channel 的发送和接收的逻辑都是差不多的，都要判断是否为空，是否阻塞，然后看缓存情况，一个明显不一样的特征是 chansend 要判断满，chanrecv 要判断空。
我们常说Go 语言中 channel 是并发安全的，什么意思呢？从上面的流程可以发现：chansend、chanrecv、closechan 都是要加锁的。即便如此，从代码层面我们还是看不到这些锁，那我们能否通过代码来看，“并发安全”具体而言是什么意思呢？下面罗列了三者的源码：
1// chansend 源码 2func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { 3 if c ==nil { 4 if !</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译器应用（3）</title>
      <link>https://jupiterxue.github.io/go-to-top/day12-parser_app/</link>
      <pubDate>Sat, 28 Aug 2021 15:14:37 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day12-parser_app/</guid>
      <description>上期说到两种复杂的 Parser场景，通过借鉴业界成熟的技术方案，能够大大节约我们自己的时间。今天再来谈谈最后一个 Parser 应用场景和 Parser 总结。
客户定制需求  场景8，我们公司是做 ToB 的服务，我们的软件会先编译完再卖出去，比如我们公司是用 Go 开发的，假如我们是卖 gRPC 服务的，而用户想要在此基础上做一些定制，他们也有自己的开发人员，比如说实现内部的 RPC 协议。用户想定制，而我们想不给他们源代码并且能够支持他们的定制需求，这就需要些技术手段来解决。（特别是 Go 语言的生态还不是很完善，并且每个方案都有自己的缺陷）
 我们在给客户交接系统的时候，客户想要自己的 RD去做些开发工作（一般指研发工程师）。而我们知道，Go 程序需要编译成二进制文件才能使用，因此让 Go 模块去做热更新是非常难的。为了满足这样的需求，我们应该怎样来做扩展呢？业界目前有四种方案：
 RPC go-plugin REPL，社区的解释器方案 WASM  以上四种方案都有不足，具体还是要看我们在真实业务场景中能够接受哪种折中的。
RPC 中，在两个系统之间定义好交互的 API，要做扩展那么就将新系统中所有的扩展做成 API，要实现这个扩展，就在原系统中调用一下就好。但 RPC 自身也有一定性能问题，如做些网关之类的扩展就不适合。
go-plugin 在Go 1.8版本就有，但也是有缺陷的：不同版本编译不兼容。用户编译出的 plugin 和我们的原始二进制文件必须要用相同的版本去编译才能通过。
REPL，社区的解释器方案例如 gopherjs、gopherlua，这些都是不错的项目，在可以在线上去用这些东西，并给用户提供局部热更新的功能。但问题就在于，有些业务需求不一定社区有。
WASM（webAssemble）是一种不针对特定平台的二进制格式文件，也是目前比较新的方案。理论上在每个语言直接互相调用没有性能损失的，但 Go 语言版本不是很完善，所以这个方案也是在调研阶段。有些公司只是在做些宣传、
Parser 总结 OK，到目前为止，我们了解了编译和反编译工具去找 Go 程序的语法具体实现，以及用到 Parser 知识可以在实际公司的业务里面去做些探索。但说到底，如果我们掌握了编译原理的知识就能够在很多场景下找到比较灵活的方案。
对于像笔者一样大学毕业工作不久，因工作需要转到用 Go 语言，而 Go 语言入门又没多久的同学来说。大学期间我们学习编译原理感到 枯燥、困难，略有些脱离实践，因此学习得不扎实，勉强通过。而工作期间又确确实实需要这方面实打实的知识，怎么办？边做边看。既然大学的时光已经过去，一去不复返，那么能抓住的就是现在。业务上需要什么我们去看什么，同时多去逛逛技术社区和论坛，比如汇总整理了几个有意思 Parser 项目的项目：https://github.com/cch123/parser_example，将自己的技术面拓宽，尽可能地边实践，边回顾理论。
之前总结了 8 个 Parser 场景，其实我也只经历了两个的样子。经验非常受到局限，但是我们通过学习，通过学习技术前辈曹大所经历的、所见识的，就能让我们也坐上通往技术前方的高铁。不知道，不擅长没关系；先了解，多了解，以后总还有可能遇到。到时我们就不再是愁思苦想，而是胸有成竹了。
参考资料
[1] Go进行wasm编程, 博客园</description>
    </item>
    
    <item>
      <title>Github_action 和 Review_dog</title>
      <link>https://jupiterxue.github.io/posts/2021-08-25-github_action-and-review_dog/</link>
      <pubDate>Wed, 25 Aug 2021 23:10:23 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-25-github_action-and-review_dog/</guid>
      <description>最近在写微信公众号的同时，也在同步开通 Hugo 搭建的个人博客。在曹大的课上了解到了两个开源工具：Github Action 和 Reviewdog，都是和 CI/CD 自动化相关的。而我最早是在 B 站一个 UP 主“遇见狂神说” 的 10 分钟短视频讲解中了解到的 CI/CD。惊奇地发现 Hugo 搭建的博客特别适合用到这两个工具。于是怀着特别的兴趣和好奇，去了解了一下。今天仅简单地来谈谈这两个工具的相关介绍。
CI/CD 首先，什么是 CI/CD？其实说的是三件事情：持续集成 (Continuous Integration, CI)、持续交付(Continuous Delivery)、持续部署 (Continuous Deployment)。其实这里单独一件事拎出来做也能做个不错的项目，不过三者搭配食用，风味更佳。
持续集成 (Continuous Integration, CI)，通常是指在程序员合并 merge 代码的时候不断对代码变更进行验证。一般用于集成时跑单元测试或者接口测试，如果未通过，那么工作流会用社交软件或者邮件通知相应的开发者。更重要的是，CI 流程中的测试代码既保证了新代码不会破坏老的业务功能，还保证新代码能编译通过。预期输入应该能够得到预期输出，如不符合的结果要报错飘红。
持续交付(Continuous Delivery)的目的是最小化部署或释放过程中固有的摩擦。它的实现通常能够将构建部署的每个步骤自动化，以便任何时刻能够安全地完成代码发布（理想情况下）。
持续部署 (Continuous Deployment)，是一种更高程度的自动化，无论何时对代码进行重大更改，都会自动进行构建/部署。能够将部署流程平台化，可以按照天、周、双周发布。发布只需要点一个按钮，就可以把代码部署到测试或者线上环境。并且即便每次改动都很小，部署流程也能够在有问题的时候及时发现。目前大多数公司都在使用这种流程。
GIthub Action CI/CD 持续集成可以玩很多有意思的东西，比如自动抓取数据、定期测试代码、一键打包项目自动登录远程服务器并发布到第三方服务等等。
作为全世界最大交流平台，GitHub 在这方面有一定话语，把这些操作统称为 actions。GitHub 注意到，由于许多操作在不同项目里面是类似的，且可以实现完全共享。于是想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，这样其他开发者也可以使用。如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 就好。因此，整个持续集成过程，就变成了一个 actions 的组合。
Review Dog reviewdog 是一种可以与任何代码分析工具持续集成的自动化代码审查工具，无论是什么样的编程语言都可以接入。
reviewdog 提供了一种特殊方法，通过与任何linter工具轻松集成，自动将审查意见发布到代码托管服务。它使用 lint 工具的输出，并在发现需要审查的补丁时将其作为评论发布。正如其名字所说，拥有一只能够做代码评审的狗勾，让你的代码库保持健康。
结语，后面有机会对这两个工具的使用做一个详细的介绍，敬请期待。
参考资料
[1] 【狂神说】CI/CD到底是什么？十分钟理解企业级DevOps, Bilibili
https://www.bilibili.com/video/BV1zf4y127vu?from=search&amp;amp;seid=15753722902113310493
[2] 什么是 CI/CD？Linux.cn
https://linux.cn/article-9926-1.html</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——解释器</title>
      <link>https://jupiterxue.github.io/go-to-top/day10-parser/</link>
      <pubDate>Sun, 22 Aug 2021 22:51:00 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day10-parser/</guid>
      <description>上期文章遗留了一个问题“三个 panic 在 runtime 代码的具体哪个位置输出”，如果通过汇编调试工具找出来。今天来动手实践，并且尝试解决另一个业务问题。
问题回顾  分别有三种情况的 panic：
 往已经关闭的 channel中写入数据 关闭一个是 nil 值的 channel 关闭一个已经是关闭状态的 channel   要找出它们在 runtime 代码中具体位置，首先我们先写几个小型代码，来完全模拟这几种情况。
情况1：往已经关闭的 channel中写入数据，文件名 send_to_close.go
1package main 2 3func main() { 4 var ch chan int 5 close(ch) 6 ch &amp;lt;- 1 7} 1go tool compile -S send_to_close.go | grep &amp;#34;send_to_close.go:6&amp;#34; 通过反汇编和文本搜索，找到了关键信息 runtime.chansend1(SB)
情况2：关闭一个是 nil 值的 channel，文件名 close_nil.go
1package main 2 3func main() { 4 var ch chan int 5 ch = nil 6 close(ch) 7} 1go tool compile -S close_nil.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——语法分析实现</title>
      <link>https://jupiterxue.github.io/go-to-top/day9-parsing_implementation/</link>
      <pubDate>Sun, 22 Aug 2021 08:34:33 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day9-parsing_implementation/</guid>
      <description>之前的文章提到：Go 程序编译和链接涉及到工具 go tool compile 、go tool objdump 和 SSA func build 将源代码转化成静态单赋值形式的中间代码。这些工具都可以直接上手玩一玩，即便对编译原理的理论不熟悉，在实践后还是会逐步明白的，Go 的工程化在这方面做得挺不错。今天来讲一讲“GO 语言语法分析的具体实现”
调试工具回顾 通过命令 readelf -h 可以查看 ELF 可执行文件的头信息，发现调试入口的十六进制地址码，然后用 dlv 来调试 Go 程序。
在 dlv 中，打断点有三种常用方式：
 b * 地址 b 函数名 b 文件名:行数  指令 c 是从一个断点跳到另一个断点。如果打多个断点，那么可以做连续代码的跳转。
指令 si 是单步调试，调试汇编时常用于使用 si 到 jmp 目标位置，即一步步跳转。
我们用工具 go tool objdump 来做反汇编，而它输出的是 plan9 形式的汇编。其实在 dlv 中内置了反汇编工具，disass，不过它输出的是另一种形式的汇编。这里，我们可以掌握多种调试工具，平时就用自己擅长点的，而遇到了没弄明白的，也许另一个工具换来使用有不一样的效果。
之前我们都是遇到问题搜资料，我想系统学习 dlv 怎么办呢？就像上期文章讲到的，还是去看官方文档：https://github.com/go-delve/delve/tree/master/Documentation/cli
简单浏览一下官方文档可以发现，官方也在逐步添加新的功能。比如说，现在有一个地址，我可以直接用 dlv 中的 x 指令查看一段连续内存里存储的值，这个有点像 gdb 中的 x（另一个调试工具，用于查看内存地址的值）。这个指令在 runtime 中有些开头是 len，然后跟着 unsafe pointer 之类的，我能看到 unsafe pointer ，但它后面的结构直接调试可能看不到，这时候用到 x 指令就可以看到它后面内存里存储的是什么值了。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——反编译</title>
      <link>https://jupiterxue.github.io/go-to-top/day8-disassembly/</link>
      <pubDate>Sat, 21 Aug 2021 15:25:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day8-disassembly/</guid>
      <description>Go 语言常用的两个查看汇编代码的工具是 go tool compile 和 go tool objdump。上期文章说到通过 go tool compile -S 可以查看实现相同功能，两个不同的代码在性能上有什么区别，可从反编译出的汇编代码看出，二者的性能一样。今天再来聊一聊另外一个工具的使用。
 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？
 在解决这种类似问题之前，我们其实可以查阅官方的资料 spec，国外源地址：https://golang.org/ref/spec ，国内看这个：https://golang.google.cn/ref/spec
这个 spec 讲述了 Go 语言内部的语法可以怎么用。在 spec 中出现的东西，也就是官方认为是正确的东西。而如果一个用法没有在 spec 中提到，那么我们就没有办法去依赖输出结论。
举个例子，我们用到一个函数，这个函数用到了指针和 Error，如果这个返回的 Error 是非空的时候，我就不能依赖它的指针返回值。我们要依赖这个值，就需要 Error 是空。这种情况就是语言的确定性，如果我们依赖了有 Error 的结果，那么就是非确定性的。这个非确定性，我们会经常看到一个名词叫做 Undefined Behavior。我们初学 Go 语言，或者习惯于写动态语言，如 Python 的同学，会非常依赖这种写代码习惯，这其实是非常危险的。它可能会给我们带来隐藏的线上 Bug，很多时候都是难发现的，特别是在做语言 SDK 升级的时候，可能会导致比较严重的问题。
所以我们要去查询 Go 语言内部的函数或者结构的用法的话，一定要去看官方的资料。不要去看网上的博客来作为自己的结论，因为别人写的不一定对，尤其是当我们使用了错误的博客内容来操作，会给业务带来更多麻烦。
OK，打开 spec 网址，我们来看看，哥们，你这瓜多少钱一斤？
spec 告诉我们，make 可以用在三种结构上的：slice，map，channel。也就说明，我们要研究 make 的实现，就去看这三种结构上执行 make 具体会执行哪个函数就好。
我们来实现这段代码，文件名为 make.go
1package main 2 3func main() { 4 // make slice 5 // 空间开的比较大，是为了让这个 slice 分配到堆上。空间小的话会默认分配到栈上，而栈上的 slice 和堆上的 slice 底层实现会不一样。 6 var sl = make([]int, 100000) 7 println(sl) 8 9 // make channel 10 var ch = make(chan int, 5) 11 println(ch) 12 13 // make map 14 var m = make(map[int]int, 22) 15 println(m) 16} 1&amp;gt;&amp;gt;&amp;gt; go build make.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译与反编译</title>
      <link>https://jupiterxue.github.io/go-to-top/day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day7-assembly/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。
重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。
 Quote
 1package main 2 3func main() { 4 5} 具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）
编译与反编译工具 我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。
1go tool 这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：
 几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。
 再让我们看看这两句指令在具体场合下都是什么意思：
 go tool compile -S main.go # 反编译代码为汇编代码。
  go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）</description>
    </item>
    
    <item>
      <title>编译与反编译</title>
      <link>https://jupiterxue.github.io/posts/2021-08-19-go-top-day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-19-go-top-day7-assembly/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。
重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。
具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）
编译与反编译工具 我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。
1go tool 这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：
 几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。
 再让我们看看这两句指令在具体场合下都是什么意思：
 go tool compile -S main.go # 反编译代码为汇编代码。
  go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）
go tool objdump [-s symregexp] 二进制 # Objdump 打印二进制文件中所有文本符号（代码）的反汇编。如果存在 -s 选项，objdump 只会反汇编名称与正则表达式匹配的符号。</description>
    </item>
    
    <item>
      <title>性感、美食和学术？</title>
      <link>https://jupiterxue.github.io/posts/2021-08-18-sex-research/</link>
      <pubDate>Wed, 18 Aug 2021 22:01:22 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-18-sex-research/</guid>
      <description>当我们的开始看论文、接触到学术研究后会形成一个感知：科研工作往往都是在进行复杂的实验、写出带有各种样式的图表和复杂的数学公式，最终生成的长篇大论。但今天我彻底颠覆了这一刻板印象——做科研也是“性感”的。？？？对，你没有看错，今天想来讨论中国知网推出的《研究生科研素养提升》系列学术讲座的其中一期。
介绍 这期讲座是在 2021-08-18 15:30~17:10 开展的。主讲人是北京交通大学教授、博导师，华国伟。他的主讲题目是《做最“性感”的研究》，一看到题目，是不是就觉得有点意思？
华老师开篇讲到，“性感”这个词常用于表达吸引异性的场合，而他的讲座并没有这个裸露的含义，而是隐喻：我们做学术也可以吸引其他做学术的人。同时，华老师还提到了一个小故事：
 有本书，名叫 《How to change your wife in 30 days》，一个星期之內售出200万本。直到作者发现，书名拼写错误，正确的应该是： 《How to change your life in 30 days》。改正后整整一个星期，只卖了3本。
 华老师希望我们来听他的讲座不是因为他的主题名字吸引了我们，而是真正对科研感兴趣，对科研是“性感”的、如何做好科研这个话题感兴趣来听的。
华老师为了做这场讲座看了许多论文和书籍，也推荐我们去看两本书：《靠近点 科学史最性感的世界观》、《性感的公司》
然后明确了这期讲座的三大言简意赅的提纲，向我们提出了三个问题：
开始正经 好，华老师开始正经地讲授科研了，大家严肃一点！
（缓冲区）
（缓冲区）
（缓冲区）
同学们，我们做学术是要有预期的，最开始我们是&amp;hellip;
不敢相信，这是科研讲座？？
哎呀呀，同学们，你们一定要记住，科研的三条秘籍：勤奋！勤奋！勤奋！连最聪明的人都在用着这个最笨的办法，但这还不够，做科研还要 欲望！冲动！血脉喷张！
这。。。我们做科研要像毛！血！旺！
小插曲 由于其他同学听得太用心，已经开始产生了幻觉，上演了一场买瓜好戏？
知网官方：同学们不要讨论其他与学习无关的东西
那么你的问题来了，买大西瓜还是小西瓜合算呢？
（两块钱一斤！哈哈哈，作为理科生的我，羞耻地去搜了搜答案）
做有价值的工作 华老师对我们科研宝贝们的论文比喻简直了，一个字，绝！
看论文我们要看看国外是怎么做的，这又会遇到一个问题：
（这么一堂科研学术讲座，活生生地做成了一趟美食之旅，让公屏后面的同学们都馋哭了吧）
写论文的要点，老师比喻地真是无懈可击。
我们看到数字对比能更加敏感，看到图片能够直观感受，听到老师的段子会忍不住哈哈大笑。
引用的故事在老师讲起来真是太搞笑了吧。
以上都是在听讲座过程中随手截取的图。
最后，华老师以优雅的姿态结束了本次讲座，惊艳了我们所有人：
（华老师结语祝福，希望你能看懂）
为什么这堂讲座口碑这么好 华老师在课间答疑说道：这个 PPT 其实在 2008、2009 年就有了，但新书一直都没有憋出来。也想出一个课程，希望能够对大家感兴趣、有困难的科研部分提供一些帮助。并且在这次讲座之前已经有300页的 PPT 内容，近好几个小时的演讲量。而为了这次讲座，将 PPT 极力压缩到了 80 页左右，为期 一个半小时讲座时间内完成。
后来，我思考了为什么华老师的讲座口碑这么好？华老师在讲授期间金句频繁，绘声绘色、有段子还有图片。背后是老师长达十多年的积累、对生活的热爱、对时尚潮流的关注以及对科研最崇高地尊敬。虽然老师有的比喻不是很恰当，略有点直白和低俗，但可以发现老师将他科研毕生所学的抽象概念都融汇在了我们生活点点滴滴的真实案例中。我们缺少阅历，但并不妨碍我们能够像老师学习，学习换位思考，尽可能地去设想另一个学者、编辑、作家、医生在想什么、做什么。并且我们能够在华老师这么一堂声色俱佳的讲座上重新捡回做科研那份初心，始终不忘如何探究、如何概括和总结。
最后，讲座不用我强烈推荐了吧，看图就好了，记得关注老师的微博“我是华国伟”，关注老师出书和课程的最新动态。放一下讲座 《华国伟 - 做最“性感”的研究》源地址：https://k.</description>
    </item>
    
    <item>
      <title>写技术文章的要点</title>
      <link>https://jupiterxue.github.io/posts/2021-08-16-tech_write/</link>
      <pubDate>Mon, 16 Aug 2021 22:52:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-16-tech_write/</guid>
      <description>磨刀不误砍柴工，程序员在写代码、写文章之余还是值得去了解重构代码、测试代码、如何写文章等辅助性的技能，虽然有时有点务虚，但从长远看却是实打实地有用。今天讨论的主题是“写技术文章有哪些要点”。
首先，我们需要对技术文章进行一个分类：
 知识总结。  比如你在公司内想要做个什么系统，你不知道，就去 Google 用英文搜一下。把第一页都消化吸收了就能出一篇总结性文章了（也就是老板常说的去调研一下）。业务问题 → Google 搜索 → 消化内容 → 总结 最近对流式计算感兴趣，我也可以 Google 去搜 &amp;ldquo;stream processing&amp;rdquo;，不过搜出来的知识点都比较零散。而我想要更完整的知识体系，那么我就去亚马逊搜书 &amp;ldquo;stream processing&amp;rdquo;。大致了解到有哪些关键词后，我们就去更加专业的渠道去阅读它——learning.oreily.com/library，然后就可以输出笔记了。 流式计算感兴趣 → 读书 → 读书笔记。   项目总结。  公司项目 → 完成之后 → 调研更高级项目 → 复盘总结。 公司问题提炼。业务脱敏，只把关键技术部分整理出来 → 输出。   教程指引。翻译官方文档，补充一些在使用时候会遇到的坑。  Yutube 上很好的国外的视频分享 → 怕忘记、感兴趣 → 结合自己的理解记下来。 内容翻译。medium，lobster，acm 里不错的新论文，acm queue，macm 杂志上的文章，都是不错的翻译目标。    小插曲：注册 ACM 会员再用同样的账号去注册O`reily，能够免费阅读里面大部分的书。价格为 25 刀，可以搞个双币信用卡呀，招行就行，现在学生账号可能不行了，不过用绑了 paypal 的卡就行好像。
 如果对电子书不排斥的话，目前比较经济的选择是申请一个国内的 ACM 会员，并且用该会员去注册oreily 在线书店。一年大概 20 美元，可以及时地阅读到大部分出版社的技术出版物。因为现在出版社的网站大多还支持 early preview，所以你甚至可以在书籍还没有上市之前就预先学习内容，第一时间获取整个业界的一线情报，能够帮助你站在时代的潮头。——曹大</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>https://jupiterxue.github.io/go-to-top/day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day6-parse/</guid>
      <description>上回我们说到 8 个常见 Go 业务场景，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础”
回顾 Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，我们可以通过这句代码，编译一段简单的 “Hello World！” 程序看到：
1go build -x hello.go 编译原理基础 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 println(1 + 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var x int = &amp;#34;abc&amp;#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &amp;ldquo;abc&amp;rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>https://jupiterxue.github.io/posts/2021-08-15-go-top-day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-15-go-top-day6-parse/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接。看似简单，但其中蕴藏着极大的能量，尤其在面对不能一时半会就解决的业务场景中，稍微深挖编译与链接的过程就有奇效。今天我们就来聊聊 “Go 语言中编译原理的基础”。
上期文章提到了 8 个常见 Go 业务场景，虽说都是业务场景，但在代码性能、数据结构转换和系统设计中偏细颗粒度的实践中我们通常感到茫然和繁琐。这是因为在平时开发中，编译器会自动帮我们屏蔽掉代码编译的过程，我们只用关注最后的 ELF 可执行文件。那么我们就来看看，编译器会帮我们做些什么工作，进一步理解我们所写的程序发生了什么样的转化。
编译原理概述 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 println(1 + 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var x int = &amp;#34;abc&amp;#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &amp;ldquo;abc&amp;rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>https://jupiterxue.github.io/go-to-top/day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day5-problem/</guid>
      <description>上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调试啊。关于业务，写代码当然可以，而当我们面临性能问题时，就需要涉及算法与数据结构。糟糕，你一说到算法我就心虚。如果你算法基础薄一点，没关系，东方不亮西方亮，算法走不通，我们走查看修改底层代码做起，仅需要细心和逻辑推理就能解决部分问题。因此，今天的主题是“探究 Go 语法背后的秘密”。
常见业务场景 你说写业务不用关心底层，OK，那我们今天先讲原理，直接上业务场景。
场景1，这两段代码运行速度怎样？第一个比第二个快？
1// 代码1 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var a = &amp;amp;person{111} 10 fmt.Println(a) 11} 1// 对比代码2 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var b = person {111} 10 var a = &amp;amp;b 11 fmt.Println(a) 12} 场景2，类型转换的原理是怎样的？
1package main 2 3func main() { 4 var a = &amp;#34;hello&amp;#34; 5 var b = []byte(a) 6 println(b) 7} 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>https://jupiterxue.github.io/posts/2021-08-14-go-top-day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-14-go-top-day5-problem/</guid>
      <description>上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调试啊。关于业务，写代码当然可以，而当我们面临性能问题时，就需要涉及算法与数据结构。糟糕，你一说到算法我就心虚。如果你算法基础薄一点，没关系，东方不亮西方亮，算法走不通，我们走查看修改底层代码做起，仅需要细心和逻辑推理就能解决部分问题。因此，今天的主题是“探究 Go 语法背后的秘密”。
常见业务场景 你说写业务不用关心底层，OK，那我们今天先讲原理，直接上业务场景。
场景1，这两段代码运行速度怎样？第一个比第二个快？
1// 代码1 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var a = &amp;amp;person{111} 10 fmt.Println(a) 11} 1// 对比代码2 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var b = person {111} 10 var a = &amp;amp;b 11 fmt.Println(a) 12} 场景2，类型转换的原理是怎样的？
1package main 2 3func main() { 4 var a = &amp;#34;hello&amp;#34; 5 var b = []byte(a) 6 println(b) 7} 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？</description>
    </item>
    
    <item>
      <title>七夕荐电影《当男人恋爱时》</title>
      <link>https://jupiterxue.github.io/posts/2021-08-13-when-man-love/</link>
      <pubDate>Fri, 13 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-13-when-man-love/</guid>
      <description>明天就是七夕节了，本来今天应该更技术文章，暂时放一放，让美好暂留一天，今天来聊一部爱情电影。
爱情并不完美，而爱情电影往往都是那么天真浪漫，这和现实生活产生了巨大的冲突和矛盾，即便如此，依就阻止不了我们对于美好爱情的向往和憧憬。《重庆森林》已经被我看过4、5遍，里面没有讲述重庆、也没有讲述森林，而当你想恋爱了、当你失恋了，这部电影就很贴近你的生活，就和你有关系了。即便是1994年的老电影，至今 2021 年仍然爱不释手。但今天要说的不是《重庆森林》，而是另一部听名字就有点意思的电影——《当男人恋爱时》。
发现 最初了解到这部电影的时候是无意间看到的一篇影评，2021年6月11日在中国大陆上映了电影《当男人恋爱时》[1]，这篇影评不仅讲述了电影中的情节，还将另外一部于2014年1月22日上映的同名电影的故事情节和剧照都晒了出来。真的是没有对比，就不会知道自己喜欢哪个。当我一看到这副剧照，我就知道，我喜欢老版本的电影！（左图）
感受（略有剧透警告） 这是一部出产于韩国出产的电影，我们都知道前些年，韩国在爱情无论是电影还是电视剧上都是比较俗套的，但这个俗套不是贬义，而是说韩国做的挺好，对于爱情剧情的理解以及形成了套路。虽然抱有一点，烂俗韩剧的心理去看电影，但看完之后真的让我忍不住想推荐，尤其是很难找到那么清新脱俗的痞子。
剧中饰演男主的黄政民，是个混混老大，但他看起来并没有我们刻板印象中的傲慢不羁或者凶神恶煞。而一如反常的是呆萌的形象，你能想象，兔子生气了冲撞你吗？哈哈。不过确实，黄政民大叔在剧中的代入感真的太强了，从收租要钱打架斗殴，到温文尔雅绘图签字，再到二人对视哭泣，每一幕的演技都细致入微。前部分塑造的粗犷暖男形象，和后半部分营造出的密集泪点效果都简直出神入化。就像一位评论者所说：“来为黄政民大叔写个影评 这片要是换个帅哥演，我真不一定看。 ”
剧情我就不介绍了，仅用几句电影中的话，来表达我在整个电影的直观的感受：
 喂！我都说爱你了，你什么感觉都没有吗？！
  哥，你倒是知道什么是爱情吗？最起码不是这样的，以后利息钱我会汇给你，不要再联系了！
  以前其实我差点结了婚的，但是我他妈的给搞砸了
  （花大钱给妹妹买了新的店外装饰）这是我妈给你的（钱），怕你没钱用，说要跟我爸保密。。这是我把给你的，还说要更我爸保密。。我爸我妈完全不沟通，这是个事啊。
  （一边吃着泡面一边和他爸爸交待身后事）因为她是您儿子这一生最爱的女人啊
 原本我以为爱情电影都是这样的狗血，剧情都会多少有煽情、有泪点。已经有心理防备的我，在感受到剧中男主女主面对面那份伤心时，也忍不住眼睛红了。我想，如果你是个泪点低的，那么这部电影真的可以算上，好好哭。
总之，这是一部很 man 、很直男、很浪漫、很悲催而又很美好的爱情电影，至今也让我回味无穷，所有的剧情可能都忘了，但还是忘不了看起来萌萌的男主说出的那句表白的话：“我爱你，妈的”。 哈哈，真是率真又可爱。
最后，可以去豆瓣点个在看，点评一下看过的电影或者看过什么书。如果你和我读过、看过的有相同，那可真是幸运，欢迎关注我的书评、影评：Jupiter 的个人主页-豆瓣
资料
[1] 台韓男人的浪漫大戰？《當男人戀愛時》與原版《不標準情人》有何不同？穆光光, marieclaire, 2021-05-03
[2] 当男人恋爱时, 豆瓣
[3] 如何看待黄政民在电影《当男人恋爱时》中的表演？知乎
[4] 影迷评《当男人恋爱时》：演技精湛 催泪感人, 新浪娱乐, 2021-06-08</description>
    </item>
    
    <item>
      <title>论—如何看论文与写技术文章</title>
      <link>https://jupiterxue.github.io/posts/2021-08-12-write/</link>
      <pubDate>Thu, 12 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-12-write/</guid>
      <description>最近成长会的小伙伴推荐了一个系列讲座“2021年“研究生科研素养提升”系列公益讲座”，看到这个题目，不禁联想起自己大学最初的梦想，如果，如果没有当初也便没有现在的自己，就不多说了。翻了翻里面有哪些主题的课程讲座，发现最让我感兴趣的是徐铭梓老师推出的“中国知网辅助论文读写效率提升”，今天讲的主题就是“论—如何看论文与写技术文章”。
这里又不得不提及，在我们成长会中，每年 Scalers 老师都会亲自带队，在为期几个月的时间内带我们进行专题性阅读。什么是专题阅读？比如这期的主题是“经济学”，我们会从曼昆的《经济学原理》的微观与宏观开始看，再到《经济思想史》和《解读中国经济》。像《经济学原理》都是经贸领域同学的本科专业教材，都是大部头，不过我们也是按照每天一章、两章的阅读量在阅读。光阅读还不够，我们每天还会回答 S 老师布置的问题，当天看书当天答题，我们社群有个全新的文化——日毕。我参加过几期这样的专题读书活动，也深刻感受到 S 老师出题之深刻，就比如：调研和概述中国近20年的财政情况、股票市场是否存在稳赚不赔的方法、2018年中美贸易摩擦到现在的变化情况，以及搜集近五年政府工作报告分析财政与货币在政策上的变化等。这些问题无一不是好几篇研究生甚至博士生所研究的问题，因此我们在回答这些问题的时候会经常性地去关注学术论文是怎样看待这些问题的。
既然要看学术论文，有没有什么常识或者说常用的套路呢？回到最开始提及的那位老师，徐铭梓。我好奇地拿着她的名字在谷歌上搜了一下，没想到直接找到了她在去年4月份在知网上发表的一篇免费教学PPT——《论文阅读与写作入门》，里面详细地讲述了作为一个科研人员，需要保持什么样的做学术和看论文的正确理念，分类地讲述了不同段位的研究者应该从哪里、看什么、怎样看论文，详尽地阐述了论文的基本阅读方法。
然后徐老师又说到了笔记与文献的摘录，她引用了梁启超先生的一句话：
 读书莫要于笔记，朱子谓当如老吏断狱一字不放过， 学者凡读书，必每句深求其故，以自出议论为主，久 之触发自多，见地自进，始能贯串群书，自成条理。 经学、子学尤要， 无笔记则必不经心，不经心则虽读 犹不读而已。
什么方法呢？极笨极麻烦的， 抄录或笔记 ——梁启超《读书分月课程·学要十五则》
 这里让我联想起了，我们程序员应该怎样来写科技文章。最近在 Go 技术群里，在热烈地讨论一个问题“作为程序员，自己知道点东西，但写着就感觉别扭，于是就写不下去。并且大多时候都像是知识储备不够，每次都感觉在抄袭别人的”，大家都表示同感，毕竟东西就是那些。还有有些同学自我安慰道，就觉得是把别人的文章用自己的话说一遍，把别人画好的图自己再画一遍。
在我们群里的技术巨佬，他们是怎么说的：
  把别人文章中的图自己画一遍，不算盗图，并且自己画一遍挺好的。
  程序员写文章整段整段贴代码不合适，贴出来关键核心代码就可以了，然后重点的是要有一些提纲，例如你分析过程，总结这些。
  总的来说，一篇优秀的技术文需要有：
 取好标题，醒目突出中心
图文并茂，适当配图说明
篇幅适宜，不宜过短也避免冗长
格式统一，基本排版规则需要遵守
细节处理，错别字标点处理正确。
   是的，就像我所喜爱的作者王垠所说“每次仇恨一个东西，你就失去了向它学习的机会。”，我们普通人没有经过专门的写作训练，面对一下写几千字是比较困难的，更难得说输出技术文章。在我看来，学习技术都是从模仿开始，不要介意抄袭别人的，不要介意别人已经做过了，要亲自动手，事必躬亲。你要清楚地知道，那是别人的东西，不是你自己的，就像那是装在别人兜兜里的钱，不是你自己能使用的。
关于《论文阅读与写作入门》我就不继续展开来讲了，如果你有兴趣，就去探索吧！好奇心，能够让你学会更多知识与技能！</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试2</title>
      <link>https://jupiterxue.github.io/go-to-top/day4-run/</link>
      <pubDate>Wed, 11 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day4-run/</guid>
      <description>上回我们说到，利用调试工具 readelf 读取我们在 Linux 上编译的可执行文件 hello，并且找到了查看 Go 底层的入口 entry point address，今天我们尝试踏进底层调试的大门，看一看我们平时所说的底层，是否真的很困难，今天的主题是“初探Go底层”
[toc]
实验环境与回顾  操作系统：CentOS 7
Go：1.14.12
调试工具：readelf、dlv
 这里我们同样运行曹大提供的实验环境，并且挂载映射到本地项目，然后进入到这个容器环境中。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 4# 进入项目目录 5cd /project/work/ch01 6# 查看文件 7ls 8 这里的绿色 hello，就是我们 Go 语言编译后产生的 ELF 格式可执行程序（ELF 不知道是什么，可回顾上期文章）
我们一般通过工具 readelf 来找到进入可执行程序底层的入口 entry point address，通过以下命令来实现，这里的 -h 表示去读取 header
 -h &amp;ndash;file-header	Display the ELF file header
 1readelf -h hello 开始底层调试 当找我们通过 readelf 找到了调试入口的十六进制地址码，我们还需要用另一个工具 dlv 才能来调试 Golang 程序。再次之前，来简单说明一下什么是 readelf、什么是 dlv。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试2</title>
      <link>https://jupiterxue.github.io/posts/2021-08-11-go-top-day4-run/</link>
      <pubDate>Wed, 11 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-11-go-top-day4-run/</guid>
      <description>上回我们说到，利用调试工具 readelf 读取我们在 Linux 上编译的可执行文件 hello，并且找到了查看 Go 底层的入口 entry point address，今天我们尝试踏进底层调试的大门，看一看我们平时所说的底层，是否真的很困难，今天的主题是“初探Go底层”
[toc]
实验环境与回顾  操作系统：CentOS 7
Go：1.14.12
调试工具：readelf、dlv
 这里我们同样运行曹大提供的实验环境，并且挂载映射到本地项目，然后进入到这个容器环境中。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 4# 进入项目目录 5cd /project/work/ch01 6# 查看文件 7ls 8 这里的绿色 hello，就是我们 Go 语言编译后产生的 ELF 格式可执行程序（ELF 不知道是什么，可回顾上期文章）
我们一般通过工具 readelf 来找到进入可执行程序底层的入口 entry point address，通过以下命令来实现，这里的 -h 表示去读取 header
 -h &amp;ndash;file-header	Display the ELF file header
 1readelf -h hello 开始底层调试 当找我们通过 readelf 找到了调试入口的十六进制地址码，我们还需要用另一个工具 dlv 才能来调试 Golang 程序。再次之前，来简单说明一下什么是 readelf、什么是 dlv。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>https://jupiterxue.github.io/go-to-top/day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day3-run/</guid>
      <description>今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我一步步走肯定都能理解。
既然要进行代码实践操作，首先要考虑的就是Go语言编译器（也就是Go）、Go 编程环境以及 Go 代码的调试环境，这里我们需要用到的版本：
 操作系统：CentOS7 或其他 Linux 环境
Go：1.14.12
Go 调试工具：readelf
 是不是有点复杂？如果版本和我的不一样，那么实验结果可能不一样。如果版本比较低，有的工具需要自己去找旧版本的去匹配安装。那有没有什么办法可以简化这些实验环境的搭建呢？用上容器技术——Docker。简单说，当你用 Docker 的时候，就像在自己的电脑中装上了我所说版本的实验环境，里面包括了上面所说的所有东西。你可以用我给出的定制环境（我们称之为镜像），也可以用其他人给出的定制环境，并且可以做到无缝切换。就这么说，在你的 windows 上可以运行 CentOS、Ubuntu，甚至还能在 windows 上运行一个微型 windows，是不是很神奇？OK，我们说回今天的实验，在开始之前希望你能去了解 Docker 是怎样操作的，这里推荐我非常喜爱的 B 站 UP 主“遇见狂神说”推出的 Docker 教程。好，就当你已经会基本操作啦，跟我开始敲代码了：
 搭建实验环境  1docker run -it xargin/go1.14.12-dev bash 这里我们运行了曹大（曹春晖）提供的实验环境，并且进入到这个容器环境中。但是存在一个问题，我们在这里面写的代码在这个容器销毁后就没有了，所以我们需要对容器做一个映射，在容器中写了文件，在我们本地也有一份记录。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 创建目录与文件  在home目录下创建文件夹所有实验目录 work，创建第一个实验目录 ch。（这里的样式和大家不一样是因为 安装了 zsh ，你不一定也要按照，如果感兴趣，请自行搜索安装，当前配色主题是 ys）
实验环境准备完毕。
编写一段简单代码  我们来打开一个叫做 hello.go 的文件，写一段我们最熟悉的代码：
1vi hello.go 1// hello.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>https://jupiterxue.github.io/posts/2021-08-09-go-top-day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-09-go-top-day3-run/</guid>
      <description>今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我一步步走肯定都能理解。
既然要进行代码实践操作，首先要考虑的就是Go语言编译器（也就是Go）、Go 编程环境以及 Go 代码的调试环境，这里我们需要用到的版本：
 操作系统：CentOS7 或其他 Linux 环境
Go：1.14.12
Go 调试工具：readelf
 是不是有点复杂？如果版本和我的不一样，那么实验结果可能不一样。如果版本比较低，有的工具需要自己去找旧版本的去匹配安装。那有没有什么办法可以简化这些实验环境的搭建呢？用上容器技术——Docker。简单说，当你用 Docker 的时候，就像在自己的电脑中装上了我所说版本的实验环境，里面包括了上面所说的所有东西。你可以用我给出的定制环境（我们称之为镜像），也可以用其他人给出的定制环境，并且可以做到无缝切换。就这么说，在你的 windows 上可以运行 CentOS、Ubuntu，甚至还能在 windows 上运行一个微型 windows，是不是很神奇？OK，我们说回今天的实验，在开始之前希望你能去了解 Docker 是怎样操作的，这里推荐我非常喜爱的 B 站 UP 主“遇见狂神说”推出的 Docker 教程。好，就当你已经会基本操作啦，跟我开始敲代码了：
 搭建实验环境  1docker run -it xargin/go1.14.12-dev bash 这里我们运行了曹大（曹春晖）提供的实验环境，并且进入到这个容器环境中。但是存在一个问题，我们在这里面写的代码在这个容器销毁后就没有了，所以我们需要对容器做一个映射，在容器中写了文件，在我们本地也有一份记录。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 创建目录与文件  在home目录下创建文件夹所有实验目录 work，创建第一个实验目录 ch。（这里的样式和大家不一样是因为 安装了 zsh ，你不一定也要按照，如果感兴趣，请自行搜索安装，当前配色主题是 ys）
实验环境准备完毕。
编写一段简单代码  我们来打开一个叫做 hello.go 的文件，写一段我们最熟悉的代码：
1vi hello.go 1// hello.</description>
    </item>
    
    <item>
      <title>微信公众排版</title>
      <link>https://jupiterxue.github.io/posts/2021-08-08-wxpb/</link>
      <pubDate>Sun, 08 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-08-wxpb/</guid>
      <description>已经开通微信公众号两周了，但公众号的发文机制和排版机制让我有些头疼，今天来探讨一下——微信公众号的排版与运作机制，先列出我在这里写作最直观的感受：
 不能用 Markdown 写文章，识别不出来，空行也会被解析掉。 一天只能发布一篇文章，第二天才有新的可发布量。 可以修改文章，但修改后的关注公众号的读者看的文章还是以前的文章。 修改后想让读者看到，就需要重新发一篇，以前的会保留。  所以我的问题来了：
 文本输入不能支持 Markdown 语法那支持什么语法？还是说有什么办法可以转化？ 一天只有一篇文章的发布量，是否有什么方法增加发布量？或者说有预发布功能？ 想要修改文章、能够让读者看见，又不减少发布量，有可行的方法吗？  作为程序员，我们一般习惯用 Markdown 来写文章，因为排版的方式有点类似于代码的方式，并且操作的方式也类似于编码的方式，有快捷键、能插入不同语言代码。如果你想试用，这里推荐你试用一下 Typora，一个看起来非常的美观的基于 Markdown 的编辑和预览器，这个软件还有一个视图查看方式就叫做“源代码模式”。但是问题就出在，直接复制用 Markdown 写好的源代码文章，粘贴到微信公众号却不能直接识别出来，里面的文本和标识符识被识别为了纯文本，空行没有了，文字上的超链接没有了，图片也没有了。真的有点，气急败坏。然后尝试直接复制 Typora 预览模式下的文章到公众号。确实效果达到了，但也出现了一个问题：用了引用的格式却不能删除、多复制了几段空行却不能删除。又是气急败坏，去找了下解决方案，一开始找到了网站 Mardkown 转 微信公众号，经过一次尝试发现有的图片没有加载进去，遂放弃。后来几经折腾发现还是这个网站有用。第一次真的眼睛瞎了，为啥没尽早用到！！
官方怎么说 下午的时候对以前发过的公众号文章做了修改，但是只有自己能够看到。已经关注的粉丝（粉丝竟是我自己）查看文章还是原来的样子。所以去看了看一些资料，惊奇地发现，能改内容，但是：
 已群发的图文消息可以修改，其他类型消息暂不支持。每篇图文支持修改1次，且最多可以修改10个错别字（注：标点、英文、数字、空格都计算在内），支持增删。 如果要修改需要：登录微信公众号电脑端 → 首页 → 已群发 → 消息列表 → 悬停点击已群发单篇图文上有个“改”的按钮，点击即可打开修改页面，修改提交后需要管理员微信扫码验证。 微信官方希望每条推送都是公众号运营者深思熟虑的结果。秉承对读者负责的原则，更好的保证用户的阅读体验，修改五个以下的错别字也是为了尽量避免出现重复阅读时内容上前后不一致的情况。 推送到用户端的内容无修改权限，不仅仅是为了尊重用户前后一致的感知，技术上也不能对用户端的内容做修改。 有两种情况无法修改：一、辟谣：文章被发起辟谣且待审核或文章被发起辟谣且审核通过；二、已删除的文章。  总之，写公众号都是在每次深思熟虑之后再写，并且今天在探索后发现，还有预览的功能。
最后的最后，不要水微信公众号，不然又浪费一天 （的发布量）：）。
一些常识和技巧  不加首行缩进。 默认微信字体 16 号，建议用 15 px。粘贴字体进入微信后，先全选“清除格式”（或者 Ctrl+shift+V，直接祛除格式粘贴），就会变成微信默认字体，再选中 15 px 字体 间距 1.5 当文字之间有图片时，上下空一行。给受众呈现更好的阅读体验。 段落保持在三思行。 两端缩进。更适合手机阅读，看起来更有质感。但不太适合代码阅读，因为展示面小了点。 GIF动图。保存动图时需注意格式应为GIF格式且不能大于2M。 永久链接。即预览文章，如果需要别人帮忙改，预览的链接具有时效性。所以去用户界面找到自己的微信，把你想要预览的文章发给自己即可【注意:48小时内自己与自己的公众号互动才行】  常用编辑器好用推荐   秀米 主要用。 有非常多的漂亮模板，可以粘贴全部或部分。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day2</title>
      <link>https://jupiterxue.github.io/go-to-top/day2-scheduler/</link>
      <pubDate>Thu, 05 Aug 2021 14:45:19 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day2-scheduler/</guid>
      <description>上回说到 Go 的调度流程本质上是⼀个⽣产-消费流程，今天来讲一讲“调度组件与调度循环”，再来回顾一下两个生动的动画 goroutine 的⽣产端, goroutine 的消费端。
当 goroutine 处于生产端时，M 执行调度循环时，必须与一个 P 绑定。并且我们常说的 Work stealing 就是说的 runqsteal -&amp;gt; runqgrab 这个流程。
当 goroutine 处于消费端时，执行的是一个循环：runtime.schedule → execute → runtime.gogo → runtime.goexit → runtime.schedule（回到原点），并且最终 P.schedtick = 0。
初学 scheduler 对于以上的流程感受是比较浅的，再来看看这些符号所代表的含义，就能更好地理解了：
 G: goroutine，计算任务。由需要执行的代码和其上下文组成。（上下文包括：当前代码位置，栈顶、栈底地址，状态等）
  M: machine，系统线程，执行实体，想要在 CPU 上来执行代码，必须有线程，与 C 语言中的线程相同，通过系统调用 clone 来创建。
  P: processor，虚拟处理器，M 必须获得 P 才能执行代码，否则必须陷入休眠（后台监控线程除外），你也可以将其理解为一种 token，有了这个 token，才有在物理 CPU 核心上执行的权利。
 上面所说的循环调度流程，都是在正常情况下运作的。而实际业务中我们往往还会遇到其他情况——阻塞。如果程序中有阻塞，那么线程不就全部被堵上，程序就卡住了么？
让我们来看看以下几种情况，在线程发生阻塞的时候，是否会无限地创新线程？（并不会）
案例1：
// channel send: var ch = make(chan int) ch &amp;lt;- 1 // channel recv: var ch = make(chan int) &amp;lt;- ch 案例2：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day2</title>
      <link>https://jupiterxue.github.io/posts/2021-08-05-go-top-day2-scheduler/</link>
      <pubDate>Thu, 05 Aug 2021 14:45:19 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-05-go-top-day2-scheduler/</guid>
      <description>1package main 2 3// sd1 4 5func main() { 6 // test 7} </description>
    </item>
    
    <item>
      <title>如何在 Go 高级工程师训练营生存</title>
      <link>https://jupiterxue.github.io/posts/2021-08-04-how-to-survive-in-senior-go-class/</link>
      <pubDate>Wed, 04 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-04-how-to-survive-in-senior-go-class/</guid>
      <description>前言 大家好，我是 Jupiter，目前从事的是 Pyhon 和 Go 的后端开发，现在是我们 Go 高级工程师第一期的学员，也是 3 班 7 组的组长。这周三的时候谢大邀请我来做个学习交流，很荣幸能有这样的机会给大家做个这样的交流。
一听到第一期学员，大家是不是觉得很厉害的样子。啊，没错，面向谷歌编程，复制粘贴代码的能力还是挺厉害的。不是，这期训练营教会我的当然不是复制粘贴那么简单，而是一个全方面的提高、一次格局拓展的经历。
像大家一样，看到有这么一个大咖云集的训练营，曹大、谢大、askuy、小 R 大（额，这里有的套娃）、听闻、邓大明、博锋，已经热血沸腾。再看了看价格，也不算很贵。相比于出门左转右转看到的黑马达内千峰，在价格上已经比较低了。机不可失时不再来，如果要问还有没有下一期，那可能我们第二期可能就是最后一期，嗯，最后一个第二期。
制定学习计划 在这次训练营开始前 5 月初时候，我是有点焦虑的。我是从 Python 转到 Go，几乎是没有什么 Go 基础，而这个训练营是面向 Go 高级工程师的。好像大家常见的语言转换和零基础，都被我撞上了。好在开营还有十多天，我做了两件事，让我在后面的学习节奏保持一个相对稳定的状态。
第一个就是制定学习计划。为期四个月的时间，120天，我很期待这期间所能够发生的许多奇妙化学反应。像往常一样，课前XXX，课中XXX，课后XXX。
课前：
   学习工具：搭建好环境、购买好 tizi 和相关工具 预习：把曹大推荐资料都读完，课程大纲自己绘制熟悉于心 问题：每次提前阅读完材料，一定要带着问题去听直播    课中：
   社群：积极参与任务，主动担当队长、副队长、主动去整理资料告知信息争做小助手 社区：每日浏览 GoCN 新闻，浏览关注的Go博主公众号和 Up 主视频 直播课堂：每次直播课都准时到，积极参加回答 大佬：多和老师曹大、助教、谢大沟通    课后：
   整理课堂笔记，发知识星球或者成立小组。整理出 github 博客 每次作业最迟第二天完成，不拖到第三天。 每天掌握一个面试问答。需要记录下来，整理出 github 博客    当然还不止这些，我还用到了风险管理与保险原理的一些方法。我向自己提问，风险有哪些？防控措施有哪些？</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>https://jupiterxue.github.io/go-to-top/day1-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day1-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>https://jupiterxue.github.io/posts/2021-08-03-go-top-day1-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-03-go-top-day1-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>https://jupiterxue.github.io/posts/2021-08-03-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-03-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>从“名家谈写作”我学到了什么</title>
      <link>https://jupiterxue.github.io/posts/2021-08-02-learn-from-top-writer/</link>
      <pubDate>Mon, 02 Aug 2021 09:36:25 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-02-learn-from-top-writer/</guid>
      <description>下定决心想要做好写文章的习惯。给自己树立的目标是先行动起来，并且完成不那么困难的事情，当行动系统建立起来了，当日毕日更做到了，再是说更高的目标，更宏远的理想。
我创立这个公众号与技术博客（后续会开通）的原意在于做些技术分享，并且坚持更新，在一个领域中做到扎根与深入。我也清醒地认识到，这个目标过于长远，还得从长计议，因此目前的计划是给自己一个缓冲的时间，一天更新纯技术一天更新技术心得或生活感悟，这样不会有太大难度的技术壁垒，也能够形成一个缓冲期，后面形成了习惯就能做纯技术输出。
我认为，既然要开始写作，那么掌握写作的框架结构和常用套路是很有必要的。去看了几位写作名家谈论如何写作，包括：胡鞍钢、毛泽东、矛盾等。以下来谈谈我的心得体会。
胡大和毛大都强调写出好的文章第一个要注意的是了解和理解你的写作对象。并且你写的文章不是给自己看，而是要给别人看。并且要有服务读者的理念，写出让读者爱看的文章。
大人，时代变了。以前的我确实是这么想的，我们写文章最重要的是要了解读者是谁，然后才能写出好的文章。而对现在的从事互联网行业的我来说，我只是一个小喽喽，自己写的文章自己都不想看，何况别人看。虽然会编程的人都可以说自己是做互联网行业，但光就编程语言就有几十上百种，各种日新月异的技术层出不穷，互联网也有非常多的分支。所以我写文章的出发点更多的是写出自己都愿意看的文章，写自己领域的技术技能。
我一直以来的想法都是，如果写出的文章。自己也喜欢那么肯定能够吸引到和你一样的人。技术文章有时候讲起来过于细碎，有时候即便同方向的别人也不知道你在干什么。因此最后还是回到了：照顾好自己，吸引那些喜欢你、认可你的人。
第二点，也是三位大家都在强调的：反复修改文章。好的文章就像好的代码，虽然一开始跑的很快有初稿有初步代码，但想要修正自己的认知、提升自己的写作能力、突破自己的编程瓶颈就得真正做好这件事。更重要的是，要有勇气面对自己，接纳不完美的自己，拥抱你能够做得更好的地方。
最后一点是矛大所说的，向生活学习。我向来认为，一个会生活的人，写出的文章是能够从中体会到柴米油盐酱醋茶的酸甜苦辣。一个会编程的人，写出的代码是洞悉世界的底层规律，严谨且确定的。同时艰巨这二者的人，便是会生活，会编程，懂得学习与接纳，拥有自己思想的人。简单的说，就是你们所谓，我之所想的——有趣的人。比如我公众号第一篇文章，就是我非常喜爱的一位既是编程者也是写作者的人。
今天也是我写作日更第一天的开始，时间有点压。明天开始还是要早点行动，早点完成写作。先建立行动习惯，再去尝试更多想法。先做到提前写作，再做到超前写作。一起加油。</description>
    </item>
    
    <item>
      <title>Grafana 条形图实践</title>
      <link>https://jupiterxue.github.io/posts/2021-07-29-grafana-bar-chart/</link>
      <pubDate>Thu, 29 Jul 2021 09:56:39 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-07-29-grafana-bar-chart/</guid>
      <description>前言 可视化平台有很多，最重要的是选择符合业务需求的方案，费用低、学习曲线低、易于上手、集成性好这些都是加分项。众望所归，我选择了 Grafana。
特点 让我们康康 Grafana 是怎样的：
 免费。Grafana 是一个开源的独立日志分析和监视工具。 开发少可直接用。面向分析师和一般使用者，一般不需要做多少编码工作就能直接拿来分析数据、搭建可视化系统。 界面炫酷。来看看官网的展示 Grafana 官网概述 丰富集成。Grafana 是跨平台工具，它提供了与各种平台和数据库的集成，持 InfluxDB，AWS，MySQL，PostgreSQL 等。 用户交互体验好。展示连续实时监控指标（如 CPU 负载，内存）、对数据提供自定义实时警报、提供基于数据库及其查询语法的命令列界面。  准备工作-采集器 一个可视化平台，重要的是有数据来做支撑，像上面所说的数据库。本文采取具有灵活查询和实时报警构建的时序数据库 promethues 来作为数据管理端。
作为圣火的传人，promethues 有着各种采集器小弟，如服务器资源采集器 node-exporter、进程资源采集器 process-exporter、服务资源采集器 blackbox-exporter， 有了这些采集器就可以直接搭建起监控和警报
服务器监控 进程监控 服务监控 最后再配有 docker 微服务，你的监控和警报平台就能够一键部署起来了。 准备工作-定制化 有了各种采集器，其实能够满足大部分通用监控的需求，但往往我们的业务是不一样的，那么就需要进行定制。
用到了胶水语言 Python 在 promethues 的模块 promethues_client，就能开始定制了！
制作一个条形图 其实这个标题，我最先想取 “fuck the bar chart”，其他定制化的数据，表格、饼图、折线图都是能够在粗略熟悉 Grafana 后可以自己上手做的。
而这个条形图困扰了我整整一周的时间，各种找插件、换版本、调格式、选展示方式，都没有达到理想效果：
今天来彻底搞定这个问题！！
版本    工具 版本     Docker 1.13.1   Go 1.</description>
    </item>
    
    <item>
      <title>Python 答疑复盘</title>
      <link>https://jupiterxue.github.io/posts/2021-07-28-python-replay/</link>
      <pubDate>Wed, 28 Jul 2021 09:49:15 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-07-28-python-replay/</guid>
      <description>在成长会中，我们会自发组建小组学习各种知识与技能，比如新概念英语朗读、经济学专题晨读、瘦下来、相亲、太极、书法、早起锁定以及 Python 基础入门小组。如果没有你感兴趣的小组，也可以你来组建这么个小组，因为，成长会的同学五湖四海，肯定有喜欢你的人 :)
今年的 2 月到 6 月我在保险学专题晨读活动中担任小队队长，听起来有点高大上，做起来就是催作业（其实不是）。我们的晨读活动是每天看一两章专业领域的书，然后当天答题，没答题的就会被踢出群。而我作为队长，并没有过多地去催作业，我们小队的同学都比较自觉，嘻嘻。更重要的是，在担任队长期间，我去开发了一套小程序，能够帮助我和其他12个队长统计作业、统计没有完成名单、收集本队作业以及统计复盘。虽然已经有一套比较复杂的工程软件来统计，但普通人一般用不了，比较麻烦，所以最后还是落到人工统计上，而队长所谓的人工统计，就是让队员自己统计？自从我在当队员的时候看到这个问题，就开始萌生要做一个统计软件的想法。现在已经实现了，并且不同主题晨读活动的队长拿着我的代码也能够进行作业统计，只需要看我的文档就会操作，一般不需要辅导。因为里面已经有封装为 exe 的程序或者源码和一两部操作就能跑的说明。
大概7月初，我们在成长会的知识星球会写个人的半年总结，我写到了些事。有一天一个成长会的同学想组织大家学 Python，通过知识星球的半年总结帖发现了我 Python 用的还可以，就让我进入小组担任答疑官。于是就有了今天组织大家线上答疑复盘的经历。
我是在早上醒来发现这位 Python 学习小组长来联系，邀请我进行答疑，询问我的时间情况。就今天拉。然后她收集好大家在学 Python 过程中的问题便发了一份 Jupyter 打开的文件给我。我也在抽空的时间写了笔记并且提供给大家提前看了看，也算是我从另外一位答疑官朋友那里吸取的翻车经验吧——即便自己能力再厉害，遇到基础还是要踏踏实实。
今晚也算是我第一是上麦直播分享纯 Python 技术，这种体验对我来说真的不一样。以前一直想有机会开直播讲解技术，但一直感觉自己的技术能力很差不够格去讲。现在深刻感悟到，我已经踏进门了一步，相比于想要入门的同学，分享的任何东西相对来说都是对他们有价值的。同时也发现，对基础概念的理解需要细细揣摩才能理解。同学们问的基础问题也值得留意，因为自己当初也是那么稀里糊涂地过来的，现在还能回答上吗？如果不能那就赶紧动起来，二次学习的机会到了！
其实这是第一次讲授代码的课，一开始我陷入了一句句讲解代码的过程，讲了第一题我自己就觉得有点累遭不住，美其名曰地问了一句大家觉得我这个讲解方式还适应吗，其实是想让大家说只想听思路，hhh。现在看来，一句句讲解是有必要的，一句句代码给大家演示也是有必要的，因此需要做好基本功的储备。同时，授课的时候要去倾听听众的感受，让我们一起将这堂课圆满完成。</description>
    </item>
    
    <item>
      <title>Go 实用小工具</title>
      <link>https://jupiterxue.github.io/posts/2021-07-26-go-tools-kit/</link>
      <pubDate>Mon, 26 Jul 2021 11:00:46 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-07-26-go-tools-kit/</guid>
      <description>Go 小工具 执行命令行 1package main 2 3import ( 4	&amp;#34;flag&amp;#34; 5	&amp;#34;fmt&amp;#34; 6	&amp;#34;runtime&amp;#34; 7 &amp;#34;os/exec&amp;#34; 8 &amp;#34;strings&amp;#34; 9) 10 11func main() { 12	// flag 包使用方法：flag.Type(&amp;#34;flagName&amp;#34;,defaultValue,&amp;#34;help message&amp;#34;) *Type 13	var name = flag.String(&amp;#34;name&amp;#34;,&amp;#34;ls&amp;#34;,&amp;#34;info: 命令&amp;#34;) 14	var args = flag.String(&amp;#34;args&amp;#34;,&amp;#34;-h&amp;#34;,&amp;#34;info: 多个参数&amp;#34;) 15 flag.Parse() 16	fmt.Println(*name) 17	fmt.Println(*args) 18	cmd := *name + &amp;#34; &amp;#34; + *args 19	fmt.Println(&amp;#34;Command: %s&amp;#34;, cmd) 20	out, err := exec.Command(&amp;#34;bash&amp;#34;, &amp;#34;-c&amp;#34;, cmd).CombinedOutput() 21	if runtime.GOOS == &amp;#34;windows&amp;#34; &amp;amp;&amp;amp; err !</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://jupiterxue.github.io/about/</link>
      <pubDate>Sat, 24 Jul 2021 17:51:42 +0000</pubDate>
      
      <guid>https://jupiterxue.github.io/about/</guid>
      <description>技能栈，小公司后端研发，自我定位——全栈工程师 🦄
 语言：Golang 🐹、Python 🐍、JavaScript、Emacs Lisp
前端：Vue、Element-UI
后端：爬虫 🕷、FastApi、Ethereum 以太坊
数据库：MySQL、Redis、ElasticSearch
运维：Docker
监控：Promethues、Grafana
大数据：Hadoop、Hive、Hbase
 兴趣爱好，网瘾少年 🎮
 运动：跑步 👟
竞技：自走棋、LoL、王者
休闲：怪物猎人 🐗
 书单，当然看经典
 大部头：《资本论》、《市场营销》、《管理学》、《保险学》
个人成长：《刻意学习》、《持续行动》💁
历史典籍：《毛泽东选集》🌌、《明朝那些事》
人物自传：《乔布斯传》、《富兰克林传》、《穷查理宝典》
最近在嗑技术类：《SICP》、《DDIA》
 欢迎更多交流
Github 👨‍👦‍👦地址: Jupiter ，邮件📧：JupiterXue97@gmail.com</description>
    </item>
    
    <item>
      <title>王垠的智慧</title>
      <link>https://jupiterxue.github.io/posts/2021-07-23-idea-from-wangyin/</link>
      <pubDate>Fri, 23 Jul 2021 18:21:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-07-23-idea-from-wangyin/</guid>
      <description>王垠的智慧 王垠是谁？去谷歌知乎简单搜搜就能很快知道这个大名鼎鼎之人。对我来说，他是具有叛逆精神、擅长质疑与逻辑推断的人。他的求学经历让我感到惋惜，与此同时，他的学习能力让我膜拜，他对计算器编译器的深刻洞见让我崇拜。最让我痴迷的是，还是他在自己的博客 “当然我在扯淡”中记录了四篇他的智慧：
参考链接
《编程的智慧》http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy
《生活的智慧》http://www.yinwang.org/blog-cn/2017/07/08/living-philosophy
《旅行的智慧》http://www.yinwang.org/blog-cn/2017/08/14/travel-wisdom
《学习的智慧》http://www.yinwang.org/blog-cn/2019/07/12/learning-philosophy
心得感悟 我是从大学开始接触编程，也是从大学才接触到的王垠。那时候无意之间闯入了 GNU 的新世界，王垠已经在这个广阔天地被人们称为了大牛。和计算机课本上那些枯燥、机械的例子不同，他将算法的思想融入到了生活的点点滴滴当中。不管你是否是从事计算机行业，相信看了这几篇文章都会被他的思想吸引住，想去一一尝试一下。
如果你从事计算机行业，掌握编程，那么你很荣幸，我们最大的乐趣就在于创造，它能让你脱离低级的趣味。我们学习技术，最直观的学习是在实践中进行的，学了代码就去写，掌握思想就能改，实践多了就能大胆创新。这时候，编辑器你的画笔，可以让你成为神笔马良；编译器是你的电脑笔友，细心地告诉你在哪里你要去往哪里。
我们做程序的，习惯叫自己程序员 / 程序媛 / 码农，就从码农可以看出，是勤勤恳恳的。确实，在编程领域当中，一分耕耘一分收获。大家学习技术，也许不单纯为了一份工作，我相信热爱技术的你，是想通过自己的双手，通过对技术的理解，创造出对世界、对社会有价值、有贡献的东西。当然，我们沉迷技术，却不是脱离生活，我们希望技术能够改善生活，我们希望算法的思想能够让这个社会变得更加美好，我们希望这个世界变得更加智慧。
生活不止眼前的代码，还有流淌于柴米油盐之间的智慧。
参考资料 [1]
[2] 最“狂”天才，保送清华读博，3次退学，怒怼阿里 P10，被微软全球封杀！ https://jishuin.proginn.com/p/763bfbd2b5c2</description>
    </item>
    
    <item>
      <title>Algorithms - Graphs</title>
      <link>https://jupiterxue.github.io/posts/2020-05-01-algorithms-graphs/</link>
      <pubDate>Fri, 01 May 2020 09:00:00 +0000</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2020-05-01-algorithms-graphs/</guid>
      <description>Undirected Graphs Some problems  Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once  classical NP-complete problem.   Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical?  No one knows so far. A lonstanding open problem    Representations Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree).</description>
    </item>
    
    <item>
      <title>Racket notes</title>
      <link>https://jupiterxue.github.io/posts/2020-02-29-racket/</link>
      <pubDate>Sat, 29 Feb 2020 09:00:00 +0000</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2020-02-29-racket/</guid>
      <description>Basic 1#lang racket 2(provide (all-defined-out)) 3 4;this is a comment 5 6(define s &amp;#34;hello&amp;#34;) 7 8(define x 3) 9(define y (+ x 2)) 10 11(define cube1 12 (lambda (x) 13 (* x (* x x)))) 14 15(define cube2 16 (lambda (x) 17 (* x x x))) 18 19(define (cube3 x) 20 (* x x x)) 21 22(define (pow1 x y) 23 (if (=y 0) 24 1 25 (* x (pow1 x (- y 1))))) 26 27; currying 28(define pow2 29 (lambda (x) 30 (lambda (y) 31 (pow1 x y)))) 32 List  Empty list: null  () doesn&amp;quot;t work for null but &#39;() does   build a list: (list e1 .</description>
    </item>
    
    <item>
      <title>ruby学习笔记</title>
      <link>https://jupiterxue.github.io/posts/2016-12-08-ruby-notes/</link>
      <pubDate>Thu, 08 Dec 2016 22:54:49 +0000</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2016-12-08-ruby-notes/</guid>
      <description>regular expressions =~是用于正则表达式的匹配操作符。返回匹配到的字符串位置或nil。
1&amp;#34;abcdef&amp;#34; =~ /d/ # return 3 2&amp;#34;aaaaaa&amp;#34; =~ /d/ # return nil !和? The exclamation point (!, sometimes pronounced aloud as &amp;ldquo;bang!&amp;quot;) indicates something potentially destructive, that is to say, something that can change the value of what it touches.
ruby&amp;gt; s1 = &amp;quot;forth&amp;quot; &amp;quot;forth&amp;quot; ruby&amp;gt; s1.chop! # This changes s1. &amp;quot;fort&amp;quot; ruby&amp;gt; s2 = s1.chop # This puts a changed copy in s2, &amp;quot;for&amp;quot; ruby&amp;gt; s1 # .</description>
    </item>
    
  </channel>
</rss>
