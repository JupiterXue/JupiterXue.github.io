<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jupiter 的个人博客</title>
    <link>https://JupiterXue.github.io/</link>
    <description>Recent content on Jupiter 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-ch</language>
    <lastBuildDate>Mon, 04 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://JupiterXue.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>投资与量化-任务7-量化回撤</title>
      <link>https://JupiterXue.github.io/posts/quant-whale-notes/task7-backtesting/</link>
      <pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/quant-whale-notes/task7-backtesting/</guid>
      
      <description>&lt;p&gt;传送门：&lt;a href=&#34;https://datawhalechina.github.io/whale-quant/#/./ch07_%E9%87%8F%E5%8C%96%E5%9B%9E%E6%B5%8B/ch07_%E9%87%8F%E5%8C%96%E5%9B%9E%E6%B5%8B&#34;&gt;第七章-量化回撤&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;量化回测指标可分四个维度，几个常见指标如下：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;收益&lt;/strong&gt;：总收益/累积收益率，年化收益率，平均收益率，夏普比率，索提诺比率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性&lt;/strong&gt;：波动率，最大回撤，回撤恢复时间，收益曲线，收益分布&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;胜率&lt;/strong&gt;：胜率，盈亏比，盈利因子，连续亏损次数，连续盈利次数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;风险&lt;/strong&gt;：最大回撤，最大回撤比率，条件风险价值，预期亏损，Beta系数，Alpha系数，信息比率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;综合考量几个或从不同维度考量量化回撤的指标，可以识别大部分&lt;strong&gt;金融投资诈骗&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手写量化回测框架&lt;/strong&gt;，目的在于造适合自己的轮子，简化并强化策略编写过程，最终直接对接到模拟盘与实盘当中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;笔记&#34;&gt;笔记&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;量化回测基础指标，熟练掌握：年化收益率、基准年化收益率、最大回撤。&lt;/li&gt;
&lt;li&gt;常见骗局
&lt;ul&gt;
&lt;li&gt;“胜率”确定策略好坏是非常业余且不可靠方法&lt;/li&gt;
&lt;li&gt;只看年化收益也不对忽略了波动风险情况（最大回撤）&lt;/li&gt;
&lt;li&gt;用周收益率来计算夏普比，而不是日收益率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;量化回测四个维度：收益、稳定性、胜率、风险。&lt;/li&gt;
&lt;li&gt;净值曲线：一组时间序列曲线，表示为股票或基金在不同时间的价值相对于期初的价值倍数。&lt;/li&gt;
&lt;li&gt;年化收益：直观理解，假设按某种盈利能力，换算成一年的收益能有多少。但不能用单月的直接推算一年的，忽略了波动性。&lt;/li&gt;
&lt;li&gt;波动率：方差表示，年波动率=策略收益和无风险收益的标准差除以其均值，再除以交易日倒数的平方根，交易日取252天。&lt;/li&gt;
&lt;li&gt;最大回撤：选定周期任意历史时点往后推，于最低点时的收益率回撤幅度的最大值。地位比波动率还重要。&lt;/li&gt;
&lt;li&gt;Alpha系数和Beta系数：Beta 代表系统风险，Alpha 非系统风险，投资者获得于市场波动无关的回报。&lt;/li&gt;
&lt;li&gt;夏普比（Sharpe ratio）：每承受一单位总风险，产生多少超额报酬，比率越高越好。&lt;/li&gt;
&lt;li&gt;信息比：类似夏普比率，但参照基准不是无风险收益率，是策略的市场基准收益率。&lt;/li&gt;
&lt;li&gt;量化回测平台：聚宽-图标丰富（https://www.joinquant.com/），Backtrader-学术风、基础数据来源 tushare （ &lt;a href=&#34;https://www.backtrader.com&#34;&gt;https://www.backtrader.com&lt;/a&gt;），BigQuant-图标丰富明亮（https://bigquant.com/）&lt;/li&gt;
&lt;li&gt;手写回测框架
&lt;ul&gt;
&lt;li&gt;目的：避免重复造轮子，简化策略回测，三方框架过重过程繁琐（vnpy）&lt;/li&gt;
&lt;li&gt;优点：无须额外依赖，框架简单，策略编写简单&lt;/li&gt;
&lt;li&gt;解决痛点：不用手写回测结果，封装常用技术指标，便于优化策略，可直接对接模拟盘、实盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>投资与量化-任务6-量化调仓</title>
      <link>https://JupiterXue.github.io/posts/quant-whale-notes/task6-select-time/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/quant-whale-notes/task6-select-time/</guid>
      
      <description>&lt;p&gt;传送门：&lt;a href=&#34;https://datawhalechina.github.io/whale-quant/#/./ch06_%E9%87%8F%E5%8C%96%E8%B0%83%E4%BB%93%E7%AD%96%E7%95%A5/ch06_%E9%87%8F%E5%8C%96%E8%B0%83%E4%BB%93%E7%AD%96%E7%95%A5&#34;&gt;第六章-量化调仓&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果说量化择时是进攻，那么&lt;strong&gt;量化调仓就是防守&lt;/strong&gt;。量化调仓可以说是投资中主动性更大的一个环节，更多的考虑不是超额收益而是&lt;strong&gt;降低风险&lt;/strong&gt;，因此会用到一些常见的方法来衡量风险情况。&lt;/li&gt;
&lt;li&gt;常见衡量风险方法有：方差与标准差来判断波动性，Beta系数判断相对市场波动性，VaR 衡量最大预期损失，CVaR 衡量极端风险损失均值。&lt;/li&gt;
&lt;li&gt;关于有效前沿和资本市场线，这个模块带入太过生硬，单纯讲概念莫名其妙，不知道用在什么场景，什么时候用。未来遇到类似问题再回头看。&lt;/li&gt;
&lt;li&gt;CAPM 模型，计算了理论上的投资组合收益率，因A股种类数量大，导致计算量巨大，引出后续回测章节因子模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;笔记&#34;&gt;笔记&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;常见衡量投资组合风险的方法：
&lt;ul&gt;
&lt;li&gt;方差和标准差，衡量波动性，越大数据分布越分散，反之越集中。&lt;/li&gt;
&lt;li&gt;Beta 系数，=协方差/方差，衡量相对于市场整体波动指标。1波动相同，大于1波动大于市场整体波动，小于1小于市场整体波动。&lt;/li&gt;
&lt;li&gt;Value at Risk(VaR)，L分布函数&lt;/li&gt;
&lt;li&gt;Conditional Value at Risk(CVaR)，衡量VaR损失超过一定阈值的平均损失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最优方法计算最佳仓位：等权重，市值加权，最小方差组合，最大分散度，风险平价，均值方差优化，引入常见约束（但资产权重范围限制，做空限制，行业中性化，风险敞口限制）&lt;/li&gt;
&lt;li&gt;关于有效前沿与资本市场线的几个关键词：效用函数，无差异曲线，有效前沿，资产配置线。&lt;/li&gt;
&lt;li&gt;MPT 现代资产组合理论，重点
&lt;ul&gt;
&lt;li&gt;用方差衡量风险&lt;/li&gt;
&lt;li&gt;通过资产组合配置降低风险、中和收益&lt;/li&gt;
&lt;li&gt;有效前沿在诸多风险资产上配置资产组合达到最好情况，市场组合是其中投资效率最高的资产组合&lt;/li&gt;
&lt;li&gt;资本市场先是加入无风险资产之后能配置出来收益-风险特征的边界&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CAPM 模型假设投资者都是风险厌恶情况下，如果某投资标的有更多收益，那么会承担更多风险，并且收益和风险满足公式所描述的线性关系。&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>投资与量化-任务5-量化择时</title>
      <link>https://JupiterXue.github.io/posts/quant-whale-notes/task5-select-position/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/quant-whale-notes/task5-select-position/</guid>
      
      <description>&lt;p&gt;传送门：&lt;a href=&#34;https://datawhalechina.github.io/whale-quant/#/./ch05_%E9%87%8F%E5%8C%96%E6%8B%A9%E6%97%B6%E7%AD%96%E7%95%A5/ch05_%E9%87%8F%E5%8C%96%E6%8B%A9%E6%97%B6%E7%AD%96%E7%95%A5&#34;&gt;第五章-量化择时&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;量化择时，时间作为投资的关键，决定了是否进行买卖。其中有三个主要时间选择：&lt;strong&gt;市场整体择时，板块轮动择时，个股择时&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;常见的择时指标是均线、MACD、RSI，各有优点和缺点：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;双均线&lt;/strong&gt;，短（5、7、10），中（20、30、60），长（120、250），优点在于可以确定趋势；缺点在于具有滞后性，长短期难以抉择；未来优化方向在加权平均、不限于收盘价、自适应时间窗口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MACD&lt;/strong&gt;，=DIF（EMA12-EMA26）-DEA（EMA(DIF, 9)），优点在于单指标易分析适用于中长期走势，尤其在上涨/下跌乏力时发出交易信号；缺点在于单边趋势指标会失灵，收益不如指数收益。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RSI&lt;/strong&gt;，=100-(100/1+RS)，大于70超买，小于30超卖，优点在于捕捉短期买卖点，缺点在于单边行情或市场剧烈波动指标失真。未来优化在于多指标结合，动态调整周期，结合机器学习。
&lt;ul&gt;
&lt;li&gt;RS=上涨价格幅度的平均值/下跌价格幅度的平均值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进阶八个择时指标：趋势、Hurst指数、SVM、牛熊线、SWARCH模型、异常指标、市场情绪、有效资金模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;笔记&#34;&gt;笔记&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定义：根据量化指标，选择买卖时机。&lt;/li&gt;
&lt;li&gt;主要分类：市场整体择时、板块行业轮动择时、个股择时&lt;/li&gt;
&lt;li&gt;优点：超高额收益，降低风险。&lt;/li&gt;
&lt;li&gt;主要目标：观察和定位市场的长期状态区间，在大概率下预测趋势，捕捉短期拐点。一般适合大类资产配置。&lt;/li&gt;
&lt;li&gt;常见指标：均线、MACD、RSI。&lt;/li&gt;
&lt;li&gt;进阶指标：
&lt;ul&gt;
&lt;li&gt;趋势：MA、MACD、DMA&lt;/li&gt;
&lt;li&gt;Hurst指数：分形，三种模式，H=0.5随机，0.5&amp;lt;H&amp;lt;1 长期记忆，0&amp;lt;H&amp;lt;0.5 分红噪声均值回复，只要不为0.5 可用偏的布朗运动（分形布朗）描述。&lt;/li&gt;
&lt;li&gt;SWARCH模型：海通证券宏观经济指标，描述货币供应量M2和大盘走势关系。&lt;/li&gt;
&lt;li&gt;异常指标：大盘顶点或低点出现的异常数据，主要有市场噪声、行业集中度和兴登堡凶兆。&lt;/li&gt;
&lt;li&gt;市场情绪：投资信心指数，情绪热烈积极入市，情绪低迷撤出市场。&lt;/li&gt;
&lt;li&gt;SVM：SVM 模式识别大盘，分为几个明显模式，找出特征，用历史数据学习模型来预测走势。&lt;/li&gt;
&lt;li&gt;有效资金模型：顶部和底部资金由额外推力，EMS &amp;gt; 0，主动买多，看好后市。EMS &amp;lt; 0，主动卖多，下跌资金所需越多，下跌阻力越大。&lt;/li&gt;
&lt;li&gt;牛熊线：年线250日线和大盘走势。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双均线：Granville八大买卖法则。
&lt;ul&gt;
&lt;li&gt;分类：短期5、7、10，中期20、30、60，长期 120、250&lt;/li&gt;
&lt;li&gt;缺陷：滞后、长短期难选择&lt;/li&gt;
&lt;li&gt;优化方向：用加权移动平均值，不限于收盘价，自适应调整均线周期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MACD：
&lt;ul&gt;
&lt;li&gt;短期 EMA 12 天，长期 EMA 26 天&lt;/li&gt;
&lt;li&gt;DIF=EMA12-EMA26，DEA=DIF EMA（DIF，9）&lt;/li&gt;
&lt;li&gt;MACD DIF-DEA&lt;/li&gt;
&lt;li&gt;优点：&lt;/li&gt;
&lt;li&gt;两条线转换成单指标，减少频发假信号，适用于中长期走势&lt;/li&gt;
&lt;li&gt;上涨乏力，能较早发出卖出信号，下跌反之如此。&lt;/li&gt;
&lt;li&gt;缺点：上涨行情，收益不如股票指数自身涨幅。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>投资与量化-任务4-量化选股</title>
      <link>https://JupiterXue.github.io/posts/quant-whale-notes/task4-select-stock/</link>
      <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/quant-whale-notes/task4-select-stock/</guid>
      
      <description>&lt;p&gt;传送门：&lt;a href=&#34;https://datawhalechina.github.io/whale-quant/#/./ch04_%E9%87%8F%E5%8C%96%E9%80%89%E8%82%A1%E7%AD%96%E7%95%A5/ch04_%E9%87%8F%E5%8C%96%E9%80%89%E8%82%A1%E7%AD%96%E7%95%A5&#34;&gt;第四章-量化选股&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基础有效市场理论模型的讨论和研究，短期市场3-5天无法预测价格，长期3-5年可预测走势。可以说短期的“市场先生”行为和长期的价格-价值均值回归。因此量化优势就是在短期内捕捉到市场无效的低价格和长期看低价格回归高价格的股票。&lt;/li&gt;
&lt;li&gt;APT 模型解释了市场回归均衡的一个决定因素，套利行为，如果市场未达到均衡状态市场就有无风险套利机会。单看套利行为好像没什么，单纯赚，但其核心和对冲很相像。就是寻找更低风险，甚至零风险的高收益的组合，而不是单一的看多看空行为。比如06年4月到07年2月，认沽行权价、认购行权价和公司利益形成了对冲，当时的五粮液、包钢认购权证的走势就是无风险套利行为。&lt;/li&gt;
&lt;li&gt;2010年交易所推出 level2，可了解日内高频行情信息，是 ALPHA 因子研究的重要数据来源。高频数据有更高数据密度和不同数据结构，但也可以定义为时间序列来处理。除了单日数据量大，时间单位可能也不整齐。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;笔记&#34;&gt;笔记&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高频量化&lt;/strong&gt;处理注意事项：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分段处理&lt;/strong&gt;。往往按表的或按时间窗口划分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;低频化&lt;/strong&gt;。将间隔不均匀的时间序列变为均匀时间间隔。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间窗口避免跨交易日&lt;/strong&gt;。集合竞价和隔夜信息会增加随机性，给抽样带来干扰。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因子中性化（正交化），用于剔除已有常见因子影响的方法。具体操作中：
&lt;ul&gt;
&lt;li&gt;市值中性化，对市值取对数然后进行线性回归&lt;/li&gt;
&lt;li&gt;行业中性化，对行业均值做差和回归取残差。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多因子选股模型的核心思想：通过多个因子的组合来选择股票，因子可以通过历史数据来计算，然后用来预测未来的股票表现，以获取更全面更稳定的预测，包括：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本面因子&lt;/strong&gt;：市盈率PE、市净率PB、营收增长&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术分析因子&lt;/strong&gt;：动量、波动率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;宏观经济因子&lt;/strong&gt;：利率、通货膨胀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多因子模型步骤
&lt;ol&gt;
&lt;li&gt;确定目标和约束条件。目标收益率、风险水平、组合数目限制、行业比例限制。&lt;/li&gt;
&lt;li&gt;选择因子并计算。根据目标和约束条件，选择合适因子，如PE、PB等。&lt;/li&gt;
&lt;li&gt;异常值处理。检查数据中异常值和报错数据，进行处理和滤除。&lt;/li&gt;
&lt;li&gt;因子标准化。不同因子取值范围差异很大，进行标准化处理，如去均值和缩放。&lt;/li&gt;
&lt;li&gt;确定因子权重。通常用统计方法，如主成分分析来确定。&lt;/li&gt;
&lt;li&gt;构建多因子模型。结合因子值和权重，建立评分模型。&lt;/li&gt;
&lt;li&gt;股票筛选和组合优化。根据评分筛选股票，并进行组合优化，获得符合目标和约束条件的组合。&lt;/li&gt;
&lt;li&gt;回测和调整模型。用历史数据回测多因子模型效果，根据结果调整和改进。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>投资与量化-任务3-获取数据</title>
      <link>https://JupiterXue.github.io/posts/quant-whale-notes/task3-get_data/</link>
      <pubDate>Tue, 22 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/quant-whale-notes/task3-get_data/</guid>
      
      <description>&lt;p&gt;传送门：&lt;a href=&#34;https://datawhalechina.github.io/whale-quant/#/./ch03_%E8%82%A1%E7%A5%A8%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/ch03_%E8%82%A1%E7%A5%A8%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96&#34;&gt;第三章-获取数据&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;思考&#34;&gt;思考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;获取数据 BaoStock。主要练习以 Python 开源金融数据分析包 BaoStock 来获取数据，开启量化 coding 第一步。&lt;/li&gt;
&lt;li&gt;数据处理 Pandas。开源的金融数据类型几乎都解析为 Pandas 格式数据类型，便于处理和分析。注意区分Series 和 Dataframes，type 查询其类型，时间类型有专门的，索引非常重要要重视，join可做数据视图，bool可观察可作条件&lt;/li&gt;
&lt;li&gt;本章以代码基础练习为主，梳理重用的方法和数据类型，更好的方式还是到类似聚宽的金融平台去作一个完整的 demo，跑出获取数据+均线系统+绘图+回测（平台已自带）。算是一个完整的练习。（读完一遍聚宽入门量化的文章才发现，吃透双均线策略是走出新手村的四个任务之一，所以还是多打好基础）&lt;/li&gt;
&lt;li&gt;关于获取数据，聚宽有一文章专门讲解：&lt;a href=&#34;https://www.joinquant.com/view/community/detail/c688e86342b472f380c8fb9fc58eec54&#34;&gt;获取数据-聚宽&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;“某些知识点忘了很正常，回头再看就行，用什么去学什么学习效率更高。”引用聚宽文章，个人认为更重要的是，了解有什么知识，建立索引（做笔记或记号），下次再遇到类似问题的时候通过索引找到知识然后用起来。一个查理芒格的隐喻说的好：在拿锤子的人眼里，全世界都是钉子。学习的目的就是如此，避免手里和眼里只有一个“锤子”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;拓展&#34;&gt;拓展&lt;/h1&gt;
&lt;p&gt;以下为在本章基础上的其他学习补充：来源聚宽博客学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回测&lt;/strong&gt;：让计算机根据一段时间历史数据模拟执行策略，根据结果评价并改进策略。代码层面来讲，就是用一段时间历史真实行情数据来验证一个确定的交易策略在这段时间内表现如何。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模拟交易&lt;/strong&gt;：让计算机根据实际行情模拟执行该策略一段时间，根据结果评价并改进策略。&lt;/li&gt;
&lt;li&gt;更&lt;strong&gt;客观的评估策略指标&lt;/strong&gt;：年化收益率、最大回撤率、夏普比率。&lt;/li&gt;
&lt;li&gt;运行回测，执行回测并得到结果，回测结果：收益率、年化最大收益率、最大回撤、夏普比率、下单记录、持仓记录。&lt;/li&gt;
&lt;li&gt;编译运行，简化版运行回测，只有收益率，速度更快。&lt;/li&gt;
&lt;li&gt;常用下单函数：
&lt;ul&gt;
&lt;li&gt;order(code, amount) 买一定数量股票&lt;/li&gt;
&lt;li&gt;order_target(code, amount) 股票调仓，高于卖出，不高不低就不动&lt;/li&gt;
&lt;li&gt;order_value(code, value)买卖一定价值量。&lt;/li&gt;
&lt;li&gt;order_target_value，股票调仓至一定价值量。&lt;/li&gt;
&lt;li&gt;content：存储当前策略运行时间点、持有股票及其数量、持仓成本，一些常用&lt;/li&gt;
&lt;li&gt;当前时间 context.current_dt&lt;/li&gt;
&lt;li&gt;当前时间格式化：context.current_dt.strftime(&amp;quot;%Y-%m-%d&amp;quot;)&lt;/li&gt;
&lt;li&gt;前一个交易日：context.previous_date&lt;/li&gt;
&lt;li&gt;当前可用金：context.portfolio.positions_value&lt;/li&gt;
&lt;li&gt;累计收益 context.portfolio.returns&lt;/li&gt;
&lt;li&gt;当前持有股票 context.portfolio.positions.keys()&lt;/li&gt;
&lt;li&gt;当前持有某股票的开仓均价：context.portfolio.positions[&amp;lsquo;code&amp;rsquo;].avg_cost&lt;/li&gt;
&lt;li&gt;某股票当前现价：context.portfolio.positions[&amp;lsquo;code&amp;rsquo;].price&lt;/li&gt;
&lt;li&gt;当前持有某股票的可卖持仓量：context.portfolio.positions[&amp;lsquo;code&amp;rsquo;.closeable_amount&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;止损&lt;/strong&gt;：狭义是亏损一定幅度下单卖出，减少进一步亏损。广义止损在思路上衍生复杂的减少亏损方法。&lt;/li&gt;
&lt;li&gt;最大回撤越小越好&lt;/li&gt;
&lt;li&gt;足够多的交易次数让回测结果更有说服力，不能直接看到，可通过盈利次数与亏损次数相加得到，或每日买卖大致看出。&lt;/li&gt;
&lt;li&gt;有数理基础，进一步学习 Alpha 与 Beta 构造思路与过程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;夏普比率&lt;/strong&gt;，单位风险收益，越大越好&lt;/li&gt;
&lt;li&gt;未来函数，策略利用了历史当时无法得到的信息，造成回测结果极大失真。一般人工排查，注意时间。更好方法是用策略建立模拟交易，运行几天，多数未来函数问题都能被发现。模拟交易不可能引入未来数据，往往引入未来函数的策略都无法成功运行模拟交易。&lt;/li&gt;
&lt;li&gt;判断是否引入未来函数的经验法则：策略回测收益率极高，回撤极低，且各个时间段表现特别好，仿佛发现了交易圣杯，此时大概率引入了未来函数&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joinquant.com/help/api/help?name=api_old#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E2%99%A0&#34;&gt;enable_profile 性能分析&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;复制粘贴放到策略代码的第一行，回测就有性能分析结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过拟合&lt;/strong&gt;：回测好，模拟盘或实盘烂，很可能参数过拟合。
&lt;ul&gt;
&lt;li&gt;核心思想：过度细致地解读样本数据，从而没有认识到本质的规律，使策略失去普适性，对原本数据表现极为优异，对非原样本数据外情况有效性大大降低。&lt;/li&gt;
&lt;li&gt;案例：背卷子答案成绩极高，换题依旧烂&lt;/li&gt;
&lt;li&gt;鲁棒性：策略好坏对参数变化的敏感性。建议，控制参数梳理，多测几组参数大致看下参数变化对策略的影响，另外考虑进行样本外才是，用一份样本回测所选参数，另一份样本数据回测看参数在样本外情况的表现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;策略有时效性。最大回撤历史新高，收益率不增减少。都是现象，判断策略失效方法：
&lt;ul&gt;
&lt;li&gt;逻辑基础不成立。涨跌停制，某行业发展、某资源全球持续稀缺背景下。如果制度调整，新政策发布，科技进步，策略自然失效。&lt;/li&gt;
&lt;li&gt;资金过大。市场流动性不足承载，买入价更高、卖出价更低。&lt;/li&gt;
&lt;li&gt;市场中相似策略过多。策略竞争导致赚钱变难。交易行业非常注意保密且不适合分享，有志者培养自学能力。&lt;/li&gt;
&lt;li&gt;寄生策略。有心人发现你的策略并足够程度的监测时，针对你的策略制定策略，寄生在你策略上，压缩盈利空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;往往收益能力与抗风险能力互相制约不能兼顾，建议是，达到基本盈利能力，极力追求低风险，理由是盈利水平往往可以朝桐光增加资本家来提高。&lt;/li&gt;
&lt;li&gt;量化不适合分享，自学必不可少。&lt;/li&gt;
&lt;li&gt;彻底读懂下面四篇文章，作为走出新手村的一个历练：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joinquant.com/post/1398&#34;&gt;双均线策略&lt;/a&gt;  （MACD）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joinquant.com/post/1957&#34;&gt;彼得林奇成功投资&lt;/a&gt;  （PEG）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://joinquant.com/post/1668&#34;&gt;Fama-French 三因子火锅&lt;/a&gt; （多因子）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joinquant.com/post/1311&#34;&gt;凯利公式&lt;/a&gt; （期望）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://joinquant.com/post/10760&#34;&gt;编程入门资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;量化进阶&#34;&gt;量化进阶&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本模式：有一个灵感，研究与实现，成败获得新认知&lt;/li&gt;
&lt;li&gt;灵感来源：论文、研报、聚宽论坛、知乎量化主题问答、宽客博客（多数国外）、各类书籍&lt;/li&gt;
&lt;li&gt;广泛阅读：不限量化，还有财务分析、行为金融、熟悉、统计学、机器学习、心理学、物理学、语音识别&lt;/li&gt;
&lt;li&gt;学习时批判眼光看，独立思考，警惕盲从。量化交易很难有特别有价值的东西出现在大众眼前。&lt;/li&gt;
&lt;li&gt;直接参与到市场中。市场对时下新闻的反应、对量价走势的瞬时反应、不同股票或人群的反应、你的反应等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;职业化&#34;&gt;职业化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;学历只是知识储量与提效手段，你应该被录取的理由是什么？怎么把这个理由告诉他们？比如有一个好策略想入职带他们赚钱，或者有相当的策略实现能力或因子发掘能力。&lt;/li&gt;
&lt;li&gt;独立开发。多数公司独立出来，或学生阶段转独立职业量化，但现金流压力较大后来成立公司。&lt;/li&gt;
&lt;li&gt;聚宽栏目，策略被看中要谈买断、发文章要被录取，注意保护自己的成果。&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>诗词-春不晚</title>
      <link>https://JupiterXue.github.io/posts/poetry/not_too_late/</link>
      <pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/poetry/not_too_late/</guid>
      
      <description>&lt;p&gt;姑娘一句春不晚，痴儿留在真江南。&lt;/p&gt;
&lt;p&gt;江南曲落孤城，化作烟雨、与我对弹。&lt;/p&gt;
&lt;p&gt;姑娘一句冬不寒，痴儿踏过万重山。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;——傲寒同学&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;星河斗转纵横，锻成雄心壮志永存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;——Jupiter&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
    </item>
    
    <item>
      <title>诗词-临江仙</title>
      <link>https://JupiterXue.github.io/posts/poetry/river_to_god/</link>
      <pubDate>Wed, 16 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/poetry/river_to_god/</guid>
      
      <description>&lt;p&gt;浊水倾波三万里，愀然独坐孤峰。 龙潜狮随后飙风。无情皆竖子，有泪亦英雄。&lt;/p&gt;
&lt;p&gt;长剑倚天星斗烂，古今过眼成空。乾坤俯仰任穷通。半轮沧海上，一苇大江东。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;——缠中说禅&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
    </item>
    
    <item>
      <title>投资与量化-任务2-什么是金融市场</title>
      <link>https://JupiterXue.github.io/posts/quant-whale-notes/task2-basic_fina_concepts/</link>
      <pubDate>Wed, 16 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/quant-whale-notes/task2-basic_fina_concepts/</guid>
      
      <description>&lt;p&gt;传送门：&lt;a href=&#34;https://datawhalechina.github.io/whale-quant/#/./ch02_%E9%87%91%E8%9E%8D%E5%B8%82%E5%9C%BA%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.1_%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5&#34;&gt;第二章-金融市场基础&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;思考&#34;&gt;思考&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;亚当斯密从《国富论》提出看不见的手市场万能，标志微观经济学诞生；宏观经济学以凯恩斯流派为主，提倡研究供需关系与宏观经济指标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;货币金融学研究金融资产有效配置，包括金融体系的建设（融资、工具和机构），货币的功能与计量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利率现值（贴现率）理论上可以想成通货膨胀率，或是机会成本：投资这东西本来可以赚5%，但为了投资另外一个地方而放弃这里的机会，即机会成本5%。又或者像是资金成本。个人更倾向于叫做打折率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利率计算公式：
$$ PV = \frac{CF}{(1+i)^n} $$&lt;br&gt;
通过极限推导可以得到：
$$ PV = \frac{CF}{r} $$
可以称之为&lt;strong&gt;万物皆有价的公式&lt;/strong&gt;。比如一家公司固定配股配息2元，无期限，就可以大概算出这家公司大概值多少钱：如果通货膨胀率在2%，就可以算出：
$$ PV = \frac{2}{0.02} = 100 \text{元} $$
即公司股票价在100元是合理价格，实际股价在100以下就是好买点，以上就是溢价了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;投资学界定了四大类的投资种类：固定收益或债务型证券、普通股或权益型证券、基金、金融衍生品（期货期权互换），并根据其特点分为了几种交易市场：债券市场、外汇市场、贵金属市场、大宗商品市场和股票市场。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数理统计部分都是大学中概率论部分知识，公式列举枯燥乏味，有空还是继续补补课看看3Blue1Brown的动画教学视频。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://JupiterXue.github.io/pages/about/</link>
      <pubDate>Tue, 15 Oct 2024 21:51:42 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/pages/about/</guid>
      
      <description>&lt;p&gt;技能栈，小公司后端研发，自我定位——&lt;strong&gt;全栈工程师&lt;/strong&gt; 🦄&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语言：Golang 🐹、Python 🐍、JavaScript、Emacs Lisp&lt;/p&gt;
&lt;p&gt;前端：Vue、Element-UI&lt;/p&gt;
&lt;p&gt;后端：爬虫 🕷、FastApi、Ethereum 以太坊&lt;/p&gt;
&lt;p&gt;数据库：MySQL、Redis、ElasticSearch&lt;/p&gt;
&lt;p&gt;运维：Docker&lt;/p&gt;
&lt;p&gt;监控：Promethues、Grafana&lt;/p&gt;
&lt;p&gt;大数据：Hadoop、Hive、Hbase&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎更多交流&lt;/p&gt;
&lt;p&gt;Github 👨‍👦‍👦地址: &lt;a href=&#34;https://github.com/JupiterXue&#34;&gt;Jupiter&lt;/a&gt; ，邮件📧：&lt;a href=&#34;mailto:JupiterXue97@gmail.com&#34;&gt;JupiterXue97@gmail.com&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>投资与量化-任务1-什么是投资</title>
      <link>https://JupiterXue.github.io/posts/quant-whale-notes/task1-what-invist/</link>
      <pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/quant-whale-notes/task1-what-invist/</guid>
      
      <description>&lt;p&gt;组队开始学习开源量化课程，第一章投资与量化，第一个打卡任务是了解什么是投资。
传送门：&lt;a href=&#34;https://datawhalechina.github.io/whale-quant/#/./ch01_%E6%8A%95%E8%B5%84%E4%B8%8E%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/ch01_%E6%8A%95%E8%B5%84%E4%B8%8E%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84&#34;&gt;第二章-金融市场基础&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;思考&#34;&gt;思考&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;量化主要风险在于策略失效，更大挑战在于无法预测策略什么时间失效。其实不仅是量化，所有能够“盈利”的交易策略的主要风险都是如此。个人认为，相比主观交易，量化（使用量化策略的人）更倾向于墨守成规，尤其是在回测、模拟盘显示出良好的可盈利性后，但这是交易的大忌，用相同的思考方式和行为方式，必然会在黑天鹅事件出现后产生重大亏损。相反，用量化回测来验证自己的交易策略，发现策略失效边界是一个很好的思路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模拟盘交易一般需要半年到一年成熟，更多是指策略优化需要半年到一年才能更好地参与实盘。实盘交易有效性在3-5年，更多是指策略大概2、3年就可能会失效。一句话，优化无止境。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>Table of content</title>
      <link>https://JupiterXue.github.io/arch/table-of-content/</link>
      <pubDate>Tue, 02 May 2023 10:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/arch/table-of-content/</guid>
      
      <description>&lt;h2 id=&#34;table-of-content&#34;&gt;Table of content&lt;/h2&gt;
&lt;p&gt;This theme supports displaying table of content (ToC) in blog posts.&lt;/p&gt;
&lt;h2 id=&#34;parameters&#34;&gt;Parameters&lt;/h2&gt;
&lt;p&gt;You can manage a ToC with two parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;global &lt;code&gt;toc&lt;/code&gt; parameter;&lt;/li&gt;
&lt;li&gt;post &lt;code&gt;toc&lt;/code&gt; parameter.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The post &lt;code&gt;toc&lt;/code&gt; parameter has higher priority than the global &lt;code&gt;toc&lt;/code&gt; parameter.&lt;/p&gt;
&lt;h2 id=&#34;enable-table-of-content-on-all-posts&#34;&gt;Enable table of content on all posts&lt;/h2&gt;
&lt;p&gt;To enable ToC on all posts (globally) set parameter &lt;code&gt;toc&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;hugo.toml&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;toc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To disable ToC globally, simply ignore the &lt;code&gt;toc&lt;/code&gt; parameter or set it to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Math Typesetting - use Mathematical notation in blog posts</title>
      <link>https://JupiterXue.github.io/arch/math-typesetting/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/arch/math-typesetting/</guid>
      
      <description>&lt;p&gt;Mathematical notation in a Hugo project can be enabled by using
&lt;a href=&#34;https://github.com/hugo-sid/hugo-blog-awesome/blob/main/layouts/partials/helpers/katex.html&#34;&gt;third party JavaScript libraries&lt;/a&gt;.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Markdown Syntax Guide</title>
      <link>https://JupiterXue.github.io/arch/markdown-syntax/</link>
      <pubDate>Sat, 11 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/arch/markdown-syntax/</guid>
      
      <description>&lt;p&gt;This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Rich Content</title>
      <link>https://JupiterXue.github.io/arch/rich-content/</link>
      <pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/arch/rich-content/</guid>
      
      <description>&lt;p&gt;Hugo ships with several &lt;a href=&#34;https://gohugo.io/content-management/shortcodes/#use-hugos-built-in-shortcodes&#34;&gt;Built-in Shortcodes&lt;/a&gt; for rich content, along with a &lt;a href=&#34;https://gohugo.io/about/hugo-and-gdpr/&#34;&gt;Privacy Config&lt;/a&gt; and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Placeholder Text</title>
      <link>https://JupiterXue.github.io/arch/placeholder-text/</link>
      <pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/arch/placeholder-text/</guid>
      
      <description>&lt;p&gt;Lorem est tota propiore conpellat pectoribus de pectora summo.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Emoji Support</title>
      <link>https://JupiterXue.github.io/arch/emoji-support/</link>
      <pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://JupiterXue.github.io/arch/emoji-support/</guid>
      
      <description>&lt;p&gt;Emoji can be enabled in a Hugo project in a number of ways.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——web 框架原理（4）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day45-web_design_and_project_4/day45-web_design_and_project_4/</link>
      <pubDate>Tue, 28 Dec 2021 22:15:36 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day45-web_design_and_project_4/day45-web_design_and_project_4/</guid>
      
      <description>&lt;p&gt;这周尝试连续更技术文。上期说到，Validator 组件能够将复杂的字段校验工作完全自动化完成，只需使用到 go-playground 中的 validator 包就能实现这一功能。今天继续聊聊其他组件。&lt;/p&gt;
&lt;h1 id=&#34;request-binder&#34;&gt;Request Binder&lt;/h1&gt;
&lt;p&gt;这是一段摘自 gin 框架的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Content-Type MIME of the most common data formats.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEJSON&lt;/span&gt;	  		    &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;application/json&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEHTML&lt;/span&gt;			&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;text/html&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEXML&lt;/span&gt;				&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;application/xml&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEXML2&lt;/span&gt;			 &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;text/xml&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEPlain&lt;/span&gt;			       &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;text/plain&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEPOSTFORM&lt;/span&gt;		  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;&amp;#34;application/x-www-form-urlencoded&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEMutipartPOSTForm&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;multipart/form-data&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEPROTOBUF&lt;/span&gt;		  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;application/x-protobuf&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEMSGPACK&lt;/span&gt;			  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;&amp;#34;application/x-msgpack&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEMSGPACK2&lt;/span&gt;		  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;&amp;#34;application/msgpack&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;MIMEYAML&lt;/span&gt;			  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;application/x-yaml&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于 gin 走的是 HTTP 协议，所以 Request binding 请求绑定，本质上是根据 HTTP header 中的 Contet-Type 的各种类型情况。&lt;/p&gt;
&lt;p&gt;根据这个 header 我们可以判断用户传的 body 和 url 是什么东西。&lt;/p&gt;
&lt;p&gt;下面就是我们在代码中，根据 http 的 contentType 做的简单的 switch-case：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;contentType&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Binding&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MethodGet&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Form&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;contentType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MIMEJSON&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;JSON&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MIMEXML&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MIMEXML2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;XML&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MIMEPROTOBUF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ProtoBuf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MIMEMSGPACK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MIMEMSGPACK2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MsgPack&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MIMEYAML&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;YAML&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MIMEMultipartPOSTForm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;FormMultipart&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// case MIMEPOSTForm:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Form&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，switch-case 返回的是一个 binding 结构。这个过程其实是设计模式中简单工厂模式的应用。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——web 框架原理（3）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day44-web_design_and_project_3/day44-web_design_and_project_3/</link>
      <pubDate>Tue, 28 Dec 2021 22:15:02 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day44-web_design_and_project_3/day44-web_design_and_project_3/</guid>
      
      <description>&lt;p&gt;没想到吧，今天继续写点技术文章。上期文章我们说到，路由 Router 的本质其实是从字符串匹配到用户函数的过程；相似字符串对应不同的路由，中间经过 Radix Tree 构造字典树进而实现。这期文章继续讲讲常见 Web 框架中的组件。&lt;/p&gt;
&lt;h1 id=&#34;validator&#34;&gt;Validator&lt;/h1&gt;
&lt;p&gt;在没有拦截器（Validator）之前，可能我们写的一个关于，注册请求的代码是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RegisterReq&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Username&lt;/span&gt;             &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;username&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;PasswordNew&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;`josn:&amp;#34;password_new&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;PasswordRepeat&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;password_repeat&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Email&lt;/span&gt;                   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;   &lt;span class=&#34;s&#34;&gt;`json:email`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RegisterReq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Username&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PasswordNew&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PasswordRepeat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PasswordNew&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PassowrdRepeat&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nf&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;invalid email&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;password and password reinput must be loger than 0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;length of username cannot be 0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码的意思是说，我们想要创建一个账户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，用户名的长度需要大于 0；&lt;/li&gt;
&lt;li&gt;其次，密码的长度大于 0，并且重复确认输入的密码的长度也大于 0；&lt;/li&gt;
&lt;li&gt;然后，密码和重复确认的密码必须相同；&lt;/li&gt;
&lt;li&gt;再然后，注册用到的 email 必须是合法的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这段代码看起来就像开了花，但其实是很多公司的日常开发写的。但我们如果这种代码写多了不仅感到繁琐，看起来更是感到不舒服。&lt;/p&gt;
&lt;p&gt;于是我们会去学习一些重构的理念之后，比如 early return / guard cluuse 的重构思想后，重构改造写出的代码可能就是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RegisterReq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Username&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;length of username cannot be 0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PassowrdNew&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reqPasswordRepeat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;password and password reinput must be loger than 0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PassowordNEw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PassowrdRepeat&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;passowrd and reinput must be the same&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;emailFormatValid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Email&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;invalid email&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;重构之后的代码看起来相比之前的代码是更加清晰、有条理些。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——web 框架原理（2）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day43-web_design_and_project_2/day43-web_design_and_project_2/</link>
      <pubDate>Mon, 27 Dec 2021 22:11:54 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day43-web_design_and_project_2/day43-web_design_and_project_2/</guid>
      
      <description>&lt;p&gt;上期我们说到了 Middleware 可实现洋葱模式，将一些前置或后置的自定义代码插入到业务逻辑之前，并且便于修改。这期文章继续来聊聊常见 Web 框架中的组件。&lt;/p&gt;
&lt;h1 id=&#34;router&#34;&gt;Router&lt;/h1&gt;
&lt;p&gt;本质上，路由（Router）就是从字符串匹配到用户函数的过程。这里有两段示例代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;未命名文件&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112272228960.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;Router 本质是映射&lt;/center&gt;
&lt;p&gt;这里用到的是 http 标准库的签名，所以参数类型为 http.responseWriter，和 http.Request。&lt;/p&gt;
&lt;p&gt;左边的字符串并不是单独的一个字符串。我们知道在 Rest ful 风格的路由中，很多时候可以带一些参数，比如上方路由有个 id 参数，就可以在用户函数 h1 中的 http.Request 中的路由中解析出来。但我们很多时候知道怎么用，却不知道如何自己来实现这种带参数的实现的，这时候就需要用到一个树结构。&lt;/p&gt;
&lt;p&gt;在了解这个树结构之前，我们需要先知道什么是字典树（trie），这里有一幅图：&lt;/p&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112272240765.png&#34; width=&#34;400px&#34; height=&#34;400px&#34;/&gt;
&lt;center&gt;字典树例子&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;单个节点代表一个字母。&lt;/li&gt;
&lt;li&gt;如果需要对字符串进行匹配，只要从根节点开始依次匹配即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以从这个字典树发现几个单词：比如中间的 OK，右边的 OUT，左边略微复杂的 ONLINE。如果我们需要做一些文本匹配的工作，用到字典树是不错的方式。&lt;/p&gt;
&lt;p&gt;但字典树的设计比较浪费空间，有时候我们只是需要存一个字母，但其实开辟了很多空间，这个在路由当中好比有多个层级 /XXX。而如果还想要做字典树的查询，无疑时间上开销还是略大，因为在树的节点之间跳转，一般还是要经过指针的，而经过指针意味着它的内存的局部性不那么好，所以匹配起来可能会比较慢。&lt;/p&gt;
&lt;h2 id=&#34;radix-tree&#34;&gt;Radix Tree&lt;/h2&gt;
&lt;p&gt;在此基础上，我们可以再了解一下 Radix Tree。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211227225604535&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112272256621.png&#34;&gt;&lt;/p&gt;
&lt;center&gt; Radix Tree 摘自 Wikipedia&lt;/center&gt;
&lt;p&gt;Radix Tree 一般叫做奇数树或放射树，也有叫压缩前缀树。它本身是经过空间优化的字典树。在它里面会把一些子节点的公共的内容合并到父节点里面去，也就意味着单个节点不只存单个字母。&lt;/p&gt;
&lt;p&gt;然后来看看 Radix Tree 的几个特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个 URI 在 HTTP 规范中会有多个方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;Radix Tree 特征一：同一个 URI 在 HTTP 规范中会有多个方法&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112272306229.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;Radix Tree 在 URI 中的例子&lt;/center&gt;
&lt;p&gt;在我们 HTTP 的 Router 实现里，其实不止有一颗 Radix Tree。我们知道，在同一个路由字符串上，可以设置多种操作的。像这里的 Rest ful API 不仅有常见的 GET、POST 方法，还有 DELETE、PUT、UPDATE、PATCH 等方法，并且每一个方法其实都对应一颗 Radix Tree，大概的样子是这样的：&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——web 框架原理</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day42-web_design_and_project/day42-web_design_and_project/</link>
      <pubDate>Fri, 24 Dec 2021 19:14:59 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day42-web_design_and_project/day42-web_design_and_project/</guid>
      
      <description>&lt;p&gt;今天来讨论一下流行、常见的具有 RESTful API 风格的 web 框架中的原理，涵盖了 gin、go-chi 和 ego 的一些组件。我们会发现，它们框架中的组件，或多或少会有以下几个设计：middleware、router、validator、request binder、sql binder，。或许名称不都叫这个，但其实现的逻辑大概是差不多的。下面就来具体讲解它们的实现。&lt;/p&gt;
&lt;h2 id=&#34;middleware&#34;&gt;Middleware&lt;/h2&gt;
&lt;h3 id=&#34;实际场景&#34;&gt;实际场景&lt;/h3&gt;
&lt;p&gt;在讲 middleware 底层实现之前，我们先来看看它在我们实际项目中是怎么用到的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wr&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;wr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HandleFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;:8080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们有个 hello world 的业务逻辑，监听了 8080 端口，配置了一个 http 的 Handler，只要访问了路由 / 就会进入 hello 的逻辑。内部的逻辑这里只有个简单的写动作，实际场景中还会不断地叠加业务逻辑。&lt;/p&gt;
&lt;p&gt;某一天新的业务来了，想要统计每个请求所花费的时间，怎么实现呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// mindware/hello_with_time.elapse.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;logger&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Stdout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;we&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;timeStart&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;we&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;timeElapsed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Since&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeStart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;logger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeElapsed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最简单粗暴的就是在 hello 逻辑中手动添加统计时间的过程，在向 http.ResponseWriter 写入  hello 逻辑之前记录当前的时间，在处理完业务逻辑以后，再记录消耗过的时间，并且把中间消耗过的时间打到日志中。&lt;/p&gt;
&lt;p&gt;随着业务的迭代，接口肯定会逐渐增加。我们一个模块不可能只有一个诸如 hello 这样简单的接口，还会有各种各样的接口。虽然大多数公司都是微服务架构，但一般一个模块中至少有 10 个以上的接口，这种“笨笨”的办法就不是很适用了。哪怕现在年轻体力好，有 100 个接口，也可以写这样的代码一百遍，随着公司发展壮大后，除了要把请求的耗时写到日志里之外，可能业务还需要将耗时上传到可视化监控当中，代码就会发生如下改动：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;we&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;timeStart&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;we&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;timeElapsed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Since&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeStart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;logger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeElapsed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 新增耗时上报功能
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Upload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;timeHandler&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;timeElapsed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;洋葱模式&#34;&gt;洋葱模式&lt;/h3&gt;
&lt;p&gt;我们有 100 个接口都有这种功能修改需求，而如果有几百上千个接口，每个接口都要改一遍？所以我们有了中间件的思想，有个框架中叫做 middleware 有点框架中叫 filter (Java 框架中多这么叫，比如 Spring)，中间件的本质其实就是实现了 23 种设计模式中的一种，责任链模式 (Chain of Responsibility Pattern)，或者叫做拦截器模式，又或者叫装饰器模式，还有的地方称之为代理模式、洋葱模式等等，它们的实现都是差不多的东西。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>杂谈——软件开发如何选择优秀的框架？</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day41-how_to_choose_structure/day41-how_to_choose_structure/</link>
      <pubDate>Wed, 22 Dec 2021 20:58:12 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day41-how_to_choose_structure/day41-how_to_choose_structure/</guid>
      
      <description>&lt;p&gt;在编程当中，当我们掌握了编程语言的基础知识、经过一段时间编程练习之后会发现三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;项目复杂&lt;/strong&gt;。最直接的就是代码越写越多，夸张到所有代码堆积在一个文件，比如单文件 10 w 行代码。这是因为没有培养好的代码习惯、没有软件设计与重构的一些理念，而如果代码素养好一点，我们通常会把代码拆分成几个文件，并根据目录进行分类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;没有规范&lt;/strong&gt;。接上一条，也许代码多了我们会开始试着将代码拆分成几个文件，但其实没有一个统一的思想，我们还是容易继续在拆分出的文件中重新写出个 10 w 行代码的单文件，并在需要修改代码的时候东翻西翻找，浪费了时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重复写代码&lt;/strong&gt;。我们会发现当想要实现几个不同功能的时候，它们的代码是有很大部分一样的结构，比如接口开发中的抽象类。我们很希望有一个模板，也会自己去做一些可以复用的代码模板。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这三个常见的问题，于是有越来越多的开发者或团队开发了解决方案，框架。其他开发者可以直接使用这个框架，基于作者设计好的项目架构、文件结构和代码规范，能够在短时间内开发项目更清晰，性能更优越，维护更简单的软件。&lt;/p&gt;
&lt;p&gt;而有些框架要么因为太简单，要么因为太复杂，而不能直接拿来用。除非现有的框架中的功能是和我们业务中的需求是完全匹配，而且其中的代码不是复杂、能够很快阅读完，这种框架直接拿来用是非常合适的。但实际中有一个和需求比较契合的框架也是很难找的、甚至没有的，找得到的话那都是运气好的情况了。尤其是大公司，做大了之后，肯定会有和别人不一样自己的定制需求，这个就不在今天讨论的框架范畴内了。&lt;/p&gt;
&lt;p&gt;今天来聊聊一些偏主观点的内容，怎么判断框架的优劣？这里我们不讨论具体某个框架、代码写得好不好。有几个框架设计时需要考虑的问题，如果框架符合了，那么说明可能会是优秀的项目：代码规范、自动化、平台化、集成化、组件化、插件化、通用化。如果我们在企业中是扮演企业自研框架的设计者，考虑这几个问题也是很有帮助的。&lt;/p&gt;
&lt;h2 id=&#34;代码规范&#34;&gt;代码规范&lt;/h2&gt;
&lt;p&gt;不考虑一个框架的工程质量，如果我们亲自去看，仅凭自己的感受，亲自去看代码的其实比较容易发现代码写得是否好。这里以 Golang 的框架为例，一个代码规范的框架，是老老实实规规矩矩用上静态代码检查工具 GolangCI-Lint 并且遵守着 Go 社区的规范。而不规范的框架虽然声势浩大的，但注释写得很少，代码很乱，随处可见不知道哪里来的下划线的命名（Golang 中的命名是以小驼峰命名法）。&lt;/p&gt;
&lt;h2 id=&#34;自动化&#34;&gt;自动化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Layout 代码自动生成（DDD/Clean Atch）&lt;/li&gt;
&lt;li&gt;服务上线自动发布&lt;/li&gt;
&lt;li&gt;自动生成接口文档&lt;/li&gt;
&lt;li&gt;服务接入 SDK 自动生成&lt;/li&gt;
&lt;li&gt;常见 code snippet（boilerplate）内置在 CLI 工具内&lt;/li&gt;
&lt;li&gt;不要让用户去复制粘贴，我们来帮他自动写好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们既然要写一个框架，那么写新接口的时候，涉及到大量的重复代码，比如在入口写一个 Controller 或者在 logic 中写一个入口又或者在 Dao 里面又要写一些入口之类的东西等等。这些东西其实都是应该有自动的工具去生成的，通过模板生成工具去实现。&lt;/p&gt;
&lt;p&gt;第二点说的是公司中内部的交接需要打通，一旦服务上线之后，就会自动发布到服务注册系统里，不再需要我们人工去做一大堆的申请流程。&lt;/p&gt;
&lt;p&gt;自动生成接口文档，这个功能在 Golang 领域最早发现于 Beego 框架。可以直接把 Swagger 集成到里面，通过注解的方式，能把我们开发的接口相应的文档都生成出来。目前，在公司内，有些开发不一定会用到 HTTP，那就需要有一套专门的接口定义，就比如 Thrift 定义的 IDL，gRPC 的 Protobuf。有些新兴公司会用到 gRPC，这种情况还是用 pb 去做服务的定义，因此就需要把 pb 和客户端的生成尽量都做出平台，并且写一些注释，然后自动生成接口文档，做好自动化。&lt;/p&gt;
&lt;p&gt;第四点是说如果我们想接入一个外部的服务，不能说要到处找怎么接入，最好是有平台支持，通过平台能够搜到相关的服务接口，直接在接口的网页上能直接把我们的 SDK 生成好，并且最好是能够把我们的代码系统也打通，直接就能把相应的代码生成在我们的代码库中，然后用个简单的 git pull 就好了。&lt;/p&gt;
&lt;p&gt;最后是常见的模板代码 code snoppet 最好就内置在 CLI 工具里面，同时不要让程序员去其他项目中不断寻找，然后粘贴过来，这是比较容易出处的，不太建议。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——并发模型（3）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day40-memory_model_3/day40-memory_model_3/</link>
      <pubDate>Fri, 17 Dec 2021 07:24:03 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day40-memory_model_3/day40-memory_model_3/</guid>
      
      <description>&lt;p&gt;在 Go 语言的内存模型文档中会专门对 Happen-before 进行描述，网上也有很多分析文章对这个概念进行了阐述，但存在一些场景的误区。那么 Happen-before 到底是什么？有什么特征？在此之前我们先来回顾一下 goroutine 的三个基本特征。&lt;/p&gt;
&lt;h2 id=&#34;goroutine&#34;&gt;Goroutine&lt;/h2&gt;
&lt;p&gt;在 Go 语言中，&lt;strong&gt;同一个 goroutine 内的逻辑有依赖的语句执行，满足顺序关系&lt;/strong&gt;。比如我在一个 goroutine 里执行了一个很简单的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只要在其他 goroutine 中没有对这个 a 做修改，那么我们预期和实际的程序运行结果一定是 1，不会是 a=0 的情况。这个过程是个基本的逻辑保证，如果说保证不了的话，相当于我们的代码结果没有办法去做预测了。所以从直觉上我们就能理解这句话。&lt;/p&gt;
&lt;p&gt;另一个特征是说：&lt;strong&gt;编译器/CPU 可能对同一个 goroutine 中的语句执行进行打乱，以提高性能，但不能破坏其应用原有的逻辑&lt;/strong&gt;。比如有两个线程，分别会修改 x 和 y 变量的值，第一个线程中修改了 x 的值，并且载入了变量 y。虽然没有修改 y，但提前预加载提高了性能。&lt;/p&gt;
&lt;p&gt;最后个特征，&lt;strong&gt;不同的 goroutine 观察到的共享变量的修改顺序可能不一样&lt;/strong&gt;。其实也就是我们在上期文章中提到的内存重排。在 Go 语言中，我们说到同步的时候是指在 goroutine 之间发生的操作，其实在其他语言中是和线程的概念和操作是一样的。说到底，goroutine 在运行的时候就是在线程上去执行的。&lt;/p&gt;
&lt;p&gt;上期文章我们还知道了可以通过使用 Litmus 工具测试和观察内存重排，不仅如此，我们在用 Go 语言进行并发编程的时候，如果写的代码不够严谨，在线上产生错误的可能性有 1/100w，那在找 bug 的时候真的是很要命的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211217075309734&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112170753914.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;happen-before&#34;&gt;Happen-before&lt;/h2&gt;
&lt;p&gt;在官方的并发模型文档中，Happen-before 说的是什么呢？&lt;/p&gt;
&lt;p&gt;第一个特征：Init 函数一定在 main.main 之前执行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A pkg importt B pkg，那么 B pkg 的 init 函数一定在 A pkg 的 init 函数之前执行。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——并发模型（2）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day39-memory_model_2/day39-memory_model_2/</link>
      <pubDate>Wed, 15 Dec 2021 10:45:03 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day39-memory_model_2/day39-memory_model_2/</guid>
      
      <description>&lt;p&gt;上期文章说到 Go 语言中，单变量的原子的读或写操作，CPU 的多核心使用了 mesi 协议来确保正确性，也就足够了。但是 mesi 协议还存在一些缺陷：如果对某个变量进行先读，然后修改，再写，这样的多步操作，mesi 协议是无法解决的。因此我们需要除了读和写之外的指令，能够保证这种一系列操作的原子性。&lt;/p&gt;
&lt;h2 id=&#34;内存重排&#34;&gt;内存重排&lt;/h2&gt;
&lt;p&gt;mesi 能够保证单变量全局顺序的正确性，但其他多变量的全局顺序其实是保证不了的。在 Go 语言的并发编程中，有个叫做内存重排，指的是内存的读/写指令重排。为什么会用到内存重排呢？一些硬件或者编译器会对程序进行一些指令优化，优化后的结果可能会导致程序编码时的顺序与代码编译后的先后顺序不一致。因此，内存重排就专门为其适配，提升程序执行效率，减少一些IO操作。&lt;/p&gt;
&lt;p&gt;一般我们可以使用工具 &lt;strong&gt;litmus&lt;/strong&gt; 来验证内存重排，具体暂时不演示了，网上有很多文章。它会模拟本机上一些多线程的读写指令，来对其结果做一些判断。这部分内容不难，刚毕业的学生在面试的时候也会遇到面试官问其中的一些汇编指令是什么意思。其中涉及到的汇编源码，其实我们可以简化为以下的伪代码&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211215232733958&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112152327098.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;Litmus 测试观察内存重排的伪代码&lt;/center&gt;
&lt;p&gt;关键来了，我们在写并发代码的时候，如何考虑内存重排呢？对大多数程序员来说，不用考虑这个，既然知道在并发的时候诸如以上的操作都可能有内存重排，那么需要保证其顺序性的时候，直接&lt;strong&gt;在两遍加上互斥锁&lt;/strong&gt;就 OK 了。而如果还要考虑更高的性能，就需要使用一些工具。&lt;/p&gt;
&lt;h2 id=&#34;memory-barrier&#34;&gt;Memory barrier&lt;/h2&gt;
&lt;p&gt;如果我们要阻止内存重排的发生，只能使用 Memory barrier。首先，它和内存回收 GC 中的 write barrier 和 read barrier 不是一回事。网上一些文章中会把它们混淆起来，因为它们看起来都有个 barrier。虽然看起来都有 barrier，但其实完全不是一回事。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211215233343872&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112152333933.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在并发编程中 ，Memory barrier 是为了防止各种类型的读写重排而专门设计出的工具。比如说 atomic load，在其他语言中都需要加条件，诸如 require、flag 线性一致。&lt;/p&gt;
&lt;p&gt;在 GC 中的 write/read barrier 其实是指在堆上的指针修改之前，插入的一小段的代码。&lt;/p&gt;
&lt;p&gt;以上的 barrier 其实对于做 Go 应用开发的程序员来说可以不用详细了解，只要知道程序在加锁的时候能够保证正确性就 OK 了。&lt;/p&gt;
&lt;h2 id=&#34;false-sharing&#34;&gt;False sharing&lt;/h2&gt;
&lt;p&gt;上期文章我们说到了 CPU 采取的是分层存储结构，L1 cache 是 64 个字节。而实际上我们共享变量还不到 64 字节。比如我自定义了一个 struct，它只有 16 字节。但对 CPU 来说，它从内存去在加载这个 struct 的时候，它会把这个 struct 临近的内存也一起加载到 L1 cache 中。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——内存模型</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day38-memory_model/day38-memory_model/</link>
      <pubDate>Mon, 13 Dec 2021 20:06:42 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day38-memory_model/day38-memory_model/</guid>
      
      <description>&lt;p&gt;今天聊一聊 Go 语言中的内存模型，这部分内容在对于利用 sync 库在进行应用开发中用处不大，不过我们在面试过程中可能会遇到，这里做个记录。&lt;/p&gt;
&lt;p&gt;我们日常的开发中，&lt;strong&gt;只要知道使用显示同步就可以保证正确性&lt;/strong&gt;。也就是说只要发生了并发的情况，那么一定要显示地使用同步手段。显示同步手段，通常是指 channel 或者锁。并且，能够用 channel 和锁的情况下，基本上，只要没有 race 出现，就能够保障程序的正确性。&lt;/p&gt;
&lt;p&gt;但我们在开发中有时候会给别人提供偏底层的库，那么需要对底层有了解才能做得出来。因此就遇到了 Memory Model 内存模型。&lt;/p&gt;
&lt;h1 id=&#34;memory-model&#34;&gt;Memory Model&lt;/h1&gt;
&lt;p&gt;在具体了解之前，我们先要了解目前的 CPU 架构。现代的 CPU 内部的存储其实都是分级的，比如以下就是个多核 CPU 的典型架构图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211213211849363&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112132118518.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;现代计算机的多级存储结构&lt;/center&gt;
&lt;p&gt;在这个内部，我们可以看到 L1 cache，具体的信息可以通过命令 &lt;strong&gt;lscpu&lt;/strong&gt; 查看到，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211213212551827&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112132125962.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;lscpu 命令结果&lt;/center&gt;
&lt;p&gt;L1 cache 有两种类型： L1 Data cache 和 L1 Structure cache。我们平时在编程中经常遇到的就是 L1 Data cache，也就是在修改内存中变量的时候，一定需要从内存中一级一级地把它加载到 L3 → L2 → L1→ core 最终才能让 CPU 核心去处理数据。&lt;/p&gt;
&lt;p&gt;L1 cache 又会被划分为多个更细粒度的 cache line，每个 cache line 的大小为 64 bytes。这就是我们为什么在程序中经常会看到，有些数据结构会在其最后不足的情况下补足为 64 字节或 128 字节，都是有可能发生的。我们在 Linux 中也可以再动动手去做些实践尝试一下这个命令：&lt;strong&gt;getconf LEVEL1_DCACHE_LINESIZE&lt;/strong&gt;，可以看到 Data cache 的 cache line 长度，也就是 64 个字节。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——常见并发 bug（3）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day37-normal_sync_bug_3/day37-normal_sync_bug_3/</link>
      <pubDate>Fri, 10 Dec 2021 21:18:46 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day37-normal_sync_bug_3/day37-normal_sync_bug_3/</guid>
      
      <description>&lt;p&gt;&lt;img alt=&#34;img&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112102120452.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;这只地鼠又来了，说明今天我又来讲 Go 语言并发中常见的一些bug，看代码咯。&lt;/p&gt;
&lt;h2 id=&#34;引用传递&#34;&gt;引用传递&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;21&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// write
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Create a new goroutine */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// before modify
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// modified
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;apiVersion&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;v1.%d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// read
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// before modify
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// modified
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里说的是，更改代码之前，我们启动一个 goroutine，这个 goroutine 用的是一个闭包，闭包捕获了外面的变量 i，而这个 i 用的还是地址。而迭代器 for 用的也是同一个 i 的地址，所以到 goroutine 执行的时候，最后 Print 出来的 i 就是最后一个了。&lt;/p&gt;
&lt;p&gt;这里的修改方式比较简单，就是把 i 当作参数传过去，因为是值传递，也就解决问题了。&lt;/p&gt;
&lt;h2 id=&#34;waitgroup&#34;&gt;WaitGroup&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;peer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;idle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// modified
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// before modify
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stopped&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;peer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stopped&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里代码还是涉及到 WaitGroup 的用法，在修改代码之前，Add 是放在 go func 中，有可能 WaitGroup 依旧是 0，WaitGroup 的 Wait 就不需要等待任何 goroutine 就能执行完成，整个程序也就执行结束了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——常见并发 bug（2）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day36-normal_sync_bug_2/day36-normal_sync_bug_2/</link>
      <pubDate>Wed, 08 Dec 2021 16:20:11 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day36-normal_sync_bug_2/day36-normal_sync_bug_2/</guid>
      
      <description>&lt;p&gt;上期文章说到了一些常见并发 bug 的场景，本期文章继续聊聊 Go 语言中常见的一些 bug，继续写 bug（当然不是），并通过代码案例来讲解。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112081853217.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;k8s&#34;&gt;K8S&lt;/h2&gt;
&lt;p&gt;这里有段一篇论文的代码，这篇论文总结了业界比较知名的 bug，有一些是 k8s、docker 等耳熟能详的应用。因此，我们也可以发现，即便是 Google 的工程师，他们还是会写出来一些 bug，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;finishReq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ob&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ob&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// before modify
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ob&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// modified
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// block
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;After&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码的思路其实很简单：我现在想往外部发一个请求，同时要控制超时。如果请求超时那么就会给用户返回一个空。&lt;/p&gt;
&lt;p&gt;这里前两行分别有两段注释，说的是官方修改前的代码 channel 没有缓冲，还有段是修改后的代码 channel 中加入了 1 的缓冲。如果是未修改前的代码，在整个程序跑起来后，我们可以自己先想一下可能会发生什么问题？&lt;/p&gt;
&lt;p&gt;在启动了 goroutine 去向远端发起请求的时候，如果发生了超时，就会触发 select 直接返回空。说明 channel 的对端已经没有消费者在等待结果，而没有缓冲时，channel 的 buffer 为 0，那么往 channel 发送结果的 goroutine 一定会阻塞，也就意味着这个 goroutine 永远释放不了，最终造成 goroutine 泄露。也就是超时一次就泄露一个 goroutine，如果超时越多，泄露的 goroutine 涨幅也越多。&lt;/p&gt;
&lt;h2 id=&#34;syncwaitgroup&#34;&gt;sync.WaitGroup&lt;/h2&gt;
&lt;p&gt;这个是 sync.WaitGroup 的 bug&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;plugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;plugins&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;plugin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dont&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// before modify
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// modified
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看到代码大家可以思考一些这段代码有什么问题。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——常见并发 bug</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day35-normal_sync_bug/day35-normal_sync_bug/</link>
      <pubDate>Mon, 06 Dec 2021 22:30:43 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day35-normal_sync_bug/day35-normal_sync_bug/</guid>
      
      <description>&lt;p&gt;这期文章来聊一聊 Go 语言中常见的并发 bug 有哪些，并不是说要写 bug，而是在出现这些情况的时候，有相应的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112062349044.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;死锁&#34;&gt;死锁&lt;/h2&gt;
&lt;p&gt;死锁应该是最常见的，来看看代码，应该是最直观的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RUnlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RUnlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// do some logic
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里举的例子都是对对象 a 加锁，可以认为它是个全局变量。a.RLock() 加了读锁，defer 延迟解锁 a.RUnlock()，这时候调用了一个函数 y。进入函数 y 以后，再次执行 a.RLock()和 defer 解锁 a.RUlock()。这个过程相当于递归地执行了两次 a.RLock()，就会发生死锁。&lt;/p&gt;
&lt;p&gt;还有段较为简单的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有两个函数 x 和 y，都有 a.Lock() 和 b.Lock()，只不过顺序不一样。在主程序中，并发执行这两个函数时，就会出现循环等待，没有办法对锁进行抢占，也就出现了死锁。&lt;/p&gt;
&lt;p&gt;面对死锁问题，我们常见的解决办法是通过 pprof 进入 goroutine 页面查看。Go 语言自带了 pprof 工具，只要进程不挂掉就可以进入 goroutine 页面插件。但是有个问题是，如果死锁是偶发的情况，那就需要想办法在整个进程崩溃掉之前完整地把 goroutine 的栈保存下来（又是另一个话题了）。&lt;/p&gt;
&lt;h3 id=&#34;并发读写&#34;&gt;并发读写&lt;/h3&gt;
&lt;p&gt;Map concurrent writes/reads，Map 的并发读写也是容易出现死锁的情况。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——并发编程模式</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day34-sync_programming_pattern/day34-sync_programming_pattern/</link>
      <pubDate>Fri, 03 Dec 2021 20:32:49 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day34-sync_programming_pattern/day34-sync_programming_pattern/</guid>
      
      <description>&lt;p&gt;通常我们在写 Go 代码的时候，听得比较多的是 Go 和传统并发模式不一样。Go 语言采用的是 CSP 模式，即 &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;这句英文看起来有些玄乎，但其实是在说，除了 runtime 中的 hchan 结构，没有其他结构能够共享内存。而如果我们想要共享数据的话，就需要 chan 去做任务发送，这时候做的其实是一些拷贝的工作。听起来有点抽象，来看一些别人写的代码示例。&lt;/p&gt;
&lt;p&gt;第一个例子 Fan-in 扇入，也就是多个分支合并为一个分支，或合并为少数的分支。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211203230406497&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112032304677.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1-1：Fan-in 合并多个 channel 例子&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211203230942784&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112032309871.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1-2：Fan-in 合并多个 channel 例子&lt;/center&gt;
&lt;p&gt;这里的代码意思是要把多个 channel 的结果合并到同一个 channel 中去，这样消费者只用去消费一个就好了。函数中第一行是通过判断输入的 channel 数组的长度来实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是 0，说明递归结束直接返回；&lt;/li&gt;
&lt;li&gt;如果是 1，就返回当前的 channel；&lt;/li&gt;
&lt;li&gt;如果是 2，就需要调用 mergeTwo 函数。这个 mergeTwo 函数也就是简单的 for 循环 + select 结合来实现的。&lt;/li&gt;
&lt;li&gt;最后 default，就是不断对 channel 的长度除 2 ，然后递归地调用 mergeTwo 最终来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般情况下，我们要合并 channel 的话，数量不会很多几百上千个，常见的是 5-6 个。并且更加实际环境中，每个 channel 还有其具体的名字的，也就只需要写一个 select 就可以了，不用像以上代码中不定长的 channel 实现方式要简单得多。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——并发数据结构（3）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day33-sync_structure_3/day33-sync_structure_3/</link>
      <pubDate>Wed, 01 Dec 2021 13:46:40 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day33-sync_structure_3/day33-sync_structure_3/</guid>
      
      <description>&lt;p&gt;一个优质的程序、优秀的设计不是凭空产生的，而是经过由简至精，不断迭代产生出来的。在上期文章中，我们了解了 Go 语言中的信号量 semaphore 和互斥锁 sync.Mutex，在此基础上我们还可以实现更加复杂的锁。&lt;/p&gt;
&lt;h2 id=&#34;syncrwmutex&#34;&gt;sync.RWMutex&lt;/h2&gt;
&lt;p&gt;读写锁 (&lt;strong&gt;sync.RWMutex&lt;/strong&gt;)，可以来看下它的数据结构和运作逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;sync.RWMutex 结构 (2)&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112012248318.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：sync.RWMutex 结构与逻辑&lt;/center&gt;
&lt;p&gt;可以看到它的第一个结构叫做 w 其实就是互斥锁 sync.Mutex。在这里的作用是为了挡住大部分写操作的 Goroutine，只让第一个进来的能够和其他的读操作的 Goroutine 去做竞争。&lt;/p&gt;
&lt;p&gt;现在有一个写 Goroutine writer 进来了，如果还有其他 reader 在做操作，就会把这个进入的挂载在 writerSem 后面的 sudog。如果后面来了新的 writer，前面的 writer 还没有退出的话，那么新的 writer 就需要挂载在之前的互斥锁 sync.Mutex 上的 sudog 后面。同样的 writer 和 reader 也会在不同阶段去做些竞争和唤醒的操作。&lt;/p&gt;
&lt;p&gt;一旦有一个 writer 进入并且调用了 lock，那么就会在 writerSem 后面挂载一个阻塞的 sudog，并且把 readerCount 减去一个最大的值，即图中 1 左移 30 的值，最终让 readerCount 变为负数。当 readerCount 变为负数时，reader 在执行 Runlcok 的操作以后，会发现当前已经变为特殊模式了，所以就会后来进来新来的 reader，这些新的 reader  会去调用 Rlock，那么就会挂载在 readerSem 队列中。readerSem 其实也是一个信号量，最终会对应一个等待队列，并且最后的结构 readerWait 的数量其实是和这个等待队列的数量是对应的。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——并发数据结构（2）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day32-sync_structure_2/day32-sync_structure_2/</link>
      <pubDate>Mon, 29 Nov 2021 22:39:57 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day32-sync_structure_2/day32-sync_structure_2/</guid>
      
      <description>&lt;p&gt;本期文章继续拆解 Go 语言中并发部分的一些内置数据结构，了解它们的运行逻辑，梳理其中的要点。&lt;/p&gt;
&lt;h2 id=&#34;syncpool&#34;&gt;sync.Pool&lt;/h2&gt;
&lt;p&gt;上期说到 sync.Pool 结构，它的应用场合非常多，不过主要是用于 GC 标记阶段消耗大量 CPU 或者进程 RSS 占用过高情况。并且通过梳理源码发现它的逻辑是和缓存的机制很像是，都是多级缓存结构的。上期也留下了一个悬念，当 sync.Once 发生 GC 时，sync.Pool 的代码逻辑有有怎样的变化呢？还是看图直观点：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;sync.Pool GC 时逻辑&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111292258979.svg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：sync.Pool GC 时的逻辑&lt;/center&gt;
&lt;p&gt;可以看到，当发生 GC 的时候，相当于将 local 和 localSize 直接向下平移，local 赋值给了 victim，localSize 赋值给了 P。如果之前 victim 和 victimSize 有值的话就直接丢弃掉。通过这种方式将以前不需要的、多出来的对象淘汰掉。如果把其中的值刚替换掉，并且又需要从 sync.Pool 中 get 获取对象的时候，local 为空，因此就会去 victim 中去寻找值。其他的逻辑，其实和之前的逻辑是完全一致的。最终，如果 victim 找不到值，就会去 P 中去找值。&lt;/p&gt;
&lt;p&gt;一个小插曲。sync.Pool 最早的实现中，操作 shared 是有锁的。而从 Go 1.13 开始，这个锁就直接被干掉了，变成了右下方看起来有点诡异的双端链表，它就可以无锁进行操作。&lt;/p&gt;
&lt;p&gt;并且早期的 sync.Pool 在进行 GC 的时候会将其中的对象完全清空掉的。如果我们的程序对 sync.Pool 有重度使用的情况，那么在每次 GC 完成之后，如果正好发生了一个流量请求的数量波动，就会造成应用程序大量地阻塞在一个锁上，会有短时间的延迟波动。&lt;/p&gt;
&lt;h2 id=&#34;semaphore&#34;&gt;semaphore&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;信号量 （semaphore）&lt;/strong&gt;，是和所有锁相关的实现基础和所有同步原语的基础设施。可以看看这幅图：&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——并发数据结构</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day31-sync_structure/day31-sync_structure/</link>
      <pubDate>Thu, 25 Nov 2021 23:22:55 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day31-sync_structure/day31-sync_structure/</guid>
      
      <description>&lt;p&gt;我们之所以使用 Go 语言，其中一个很大的原因是它原生支持高并发，通过 Goroutine 和 Channel 完美实现。并且 Go 的并发是属于一种 CSP 并发编程模式的实现。如果我们想很好利用到这个特性，&lt;strong&gt;知其然知其所以然，是学习阶段最好的成果&lt;/strong&gt;，在生产环境中遇到问题才能有的放矢。下面就从它的一些基础数据结构开始讲起。&lt;/p&gt;
&lt;h1 id=&#34;并发内置数据结构&#34;&gt;并发内置数据结构&lt;/h1&gt;
&lt;h2 id=&#34;synconce&#34;&gt;sync.Once&lt;/h2&gt;
&lt;p&gt;在 Go 语言的并发结构中，比较简单的是 sync.Once。可以在源码 sync/once.go 中看到代码并不多，但注释很多，还有部分我用省略号隐去了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111262246986.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：once.go 源码&lt;/center&gt;
&lt;p&gt;sync.Once 只有一个方法，DO。不过其中有一些要点，如果 done 被人修改了，那么就需要做一个初始化；如果是非零就可以直接返回了。也就是说 o.Do 需要保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化方法必须且只能被调用一次。&lt;/li&gt;
&lt;li&gt;Do 返回后，初始化一定已经执行完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上代码虽然非常短，但我们在开发的时候还是会遇到一些问题。这时还得找官方，为什么一定要有 atomic 操作，为什么 doSlow 函数中一定要用 defer 来处理锁。官方对这些“看似”很基础的问题感到烦，于是就写了非常多的注释，让读者自己去搞懂这些问题（从图中看到）。&lt;/p&gt;
&lt;p&gt;这里的功能对于业务层开发的 Gopher 来说比较简单：有个全局资源，只能够初始化一次，需要初始化完成之后去执行一些操作，不过初始化的入口可能会被很多地方调用到。这种情况很常见，一方面是因为我们在做网络编程的时候要处理连接，如果多次 close 连接会出现诡异的错误。所以有很多网络程序中的 Connection 对象再加个 Once 对象，来保证关闭只会执行一次。&lt;/p&gt;
&lt;h2 id=&#34;syncpool&#34;&gt;sync.Pool&lt;/h2&gt;
&lt;p&gt;这个结构用的场合非常非常多，不过主要在两种场景使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程中 inuse_objects 数过多，&lt;strong&gt;gc mark 消耗大量 CPU&lt;/strong&gt;。这种情况多出现于当我们发现程序吞吐量很低时。&lt;/li&gt;
&lt;li&gt;进程中 inuse_objects 数过多，&lt;strong&gt;进程 RSS 占用过高&lt;/strong&gt;。这种情况是我们的程序可能运行在比较苛刻的环境下，比如 docker 中内存限制，只有 2GB 的内存。如果超过的话这个进程就会被 kill。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本的使用方法是在请求生命周期开始时，调用 pool.Get 去获取缓存的 struct 或者 slice，当请求结束时，再调用 pool.Put 把之前拿出来的对象再放回去。在这种流程在开源项目 fasthttp 中有大量应用：https://github.com/valyala/fasthttp/blob/b433ecfcbda586cd6afb80f41ae45082959dfa91/server.go#L402 这个框架对我们几乎能够看到的结构都做了一次以上的复用，也就是各种花式的 sync.Pool。并且因为它在内存优化方面做得比较多，所以它的性能也要比其他几乎所有的第三方 http 库和官方的库要好一些（当然这种优化都是有代价的）。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——GC 补充与总结</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day30-gc_lean_and_summary/day30-gc_lean_and_summary/</link>
      <pubDate>Wed, 24 Nov 2021 21:33:37 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day30-gc_lean_and_summary/day30-gc_lean_and_summary/</guid>
      
      <description>&lt;p&gt;最后一篇关于 Go 语言内存管理与垃圾回收的文章，再对之前流程中做一些补充，然后对这期系列文章做个总结。&lt;/p&gt;
&lt;h2 id=&#34;gc-补充&#34;&gt;GC 补充&lt;/h2&gt;
&lt;p&gt;在 GC 标记流程中有一个环节能够辅助标记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Goroutine 中有 gcAssistBytes 字段。&lt;/li&gt;
&lt;li&gt;当后台 gcWorker 标记时，会累积 credit，记录在 gcController.gbScanCredit 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211124233351199&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111242333365.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：协助标记源码-判定&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;Goroutine 想执行内存分配，要先尝试去 gcController.bgScanCredit 中去借债，如果借到了足够的债，那么就不用协助标记。&lt;/li&gt;
&lt;li&gt;如果借不到，那就先协助标记，标记完成后再去分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211124233409903&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111242334952.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 2：协助标记源码-分配内存&lt;/center&gt;
&lt;p&gt;在标记流程阶段，堆上对象可能出现引用交叉情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;标记流程-堆对象引用交叉情况&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111242342645.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 3：堆上对象引用交叉情况&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;一个是 isMarked 剪枝&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211124233904984&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111242339052.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 4：isMarked 源码&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;另一个是 atomic.Or8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211124233915764&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111242339838.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 5：atomic.Or8 源码&lt;/center&gt;
&lt;p&gt;再补充一些零零碎碎的小知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GC 的 CPU 控制目标是整体的 25%。&lt;/li&gt;
&lt;li&gt;当 P = 4 * N 时，只要启动 N 个 wroker 就可以使用。&lt;/li&gt;
&lt;li&gt;当 P 无法被 4 整除时，需要吃苦耐劳的 gcMarkWorker 来帮助做一部分工作：
&lt;ul&gt;
&lt;li&gt;作为全局 GC 员工 Dedicated worker，需要一直干活，知道被抢占。&lt;/li&gt;
&lt;li&gt;作为兼职 GC 员工 Fractional worker，达到业绩目标（fractionalUtilizationGoal）时，可以主动让出。&lt;/li&gt;
&lt;li&gt;另外一种 IDLE 模式。在调度循环中发现找不到可执行的 g ，并且有标记任务没有完成的情况下，就可以开启 IDLE 模式去帮忙。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Worker 运行模式位于：_p_.gcMarkWorkerMode。&lt;/li&gt;
&lt;li&gt;栈本身的内存：newstack、shrinkstack。&lt;/li&gt;
&lt;li&gt;使用 allocManual 和 freeManual 相当于手动管理内存，不计入 heap_inuse 和 heap_sys，而是计入 stackinuse 和 stacksys。&lt;/li&gt;
&lt;li&gt;栈上变量的内存变化：SP 移动销毁，简单快速。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;最后来做个总结，还是简单回顾一下垃圾回收代码的流程。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——现代化标记丢失解决方案</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day29-morden_write_barrier/day29-morden_write_barrier/</link>
      <pubDate>Mon, 22 Nov 2021 11:49:45 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day29-morden_write_barrier/day29-morden_write_barrier/</guid>
      
      <description>&lt;p&gt;在 Go 语言 GC 中，为避免对象丢失，可以在所有指针操作中加 Dijkstra barrier，而 Go 官方设计者为了降低 Go 运行环境中的成本，不希望栈上的操作频率很高，所以限制了 Go 不能在栈上操作指针时加 barrier。因此 Dijkstra barrier 和 Yuasa barrier 都失效了。&lt;/p&gt;
&lt;p&gt;因为 Go 语言不在栈上去加一个 writebarrier，所以任何一个 barrier 单独拿出来都没办法解决 Go 语言 GC 标记的正确性问题。为了解决这个问题，机智的语言设计者就把 Dijkstra barrier 和 Yuasa barrier 结合起来，做出了集大成者——Hybrid barrier，并且写了一个提案 preposal。网上有很多博客会去解析 writebarrier 的源码，其实就是这张图中的，中和两种算法的集合体。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211122224523656&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111222245159.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：混合屏障 Hybrid barrier&lt;/center&gt;
&lt;p&gt;这里的意思是说，把要修改的指针所指向的老的对象先标灰，然后判断当前栈是否是灰色。如果是灰色就去把新来的对象也标灰。最后再做个赋值操作。&lt;/p&gt;
&lt;p&gt;这个算法虽然集成了两种算法思想，但两个算法所遇到的问题正好被有效避免了。虽然作者写个提案 preposal，但后来因为没有时间就没有去实现。后来他们还发现，如果要检查栈的颜色的工作话还需要做一些同步操作，而这个 stack check 动作维护成本太高，所以暂时放弃了，至今也没实现。&lt;/p&gt;
&lt;p&gt;但我们亲自去看 Go 语言源码可以发现，它不是内部实现，代码片段如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// slot is the destination in Go code.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ptr is the value that goes into the slot in Go code.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RealityWB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slot&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;shade&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;shade&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slot&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ptr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，Go 源码中其实是没有任何 if 判断。如果发送了任何堆上指针的变化，那么一定要把原来的对象和新指向的对象都标灰。然后再执行赋值操作。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——GC 标记丢失解决初步方案</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day28-mark-lost-solutions/day28-mark-lost-solutions/</link>
      <pubDate>Fri, 19 Nov 2021 21:31:07 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day28-mark-lost-solutions/day28-mark-lost-solutions/</guid>
      
      <description>&lt;p&gt;Go 语言采用三色标记算法来实现垃圾回收，但标记过程中存在对象漏标情况，最终导致变量被意外回收掉。为了解决这个问题我们需要一个理论基础——强弱三色性。&lt;/p&gt;
&lt;h1 id=&#34;强弱三色性&#34;&gt;强弱三色性&lt;/h1&gt;
&lt;p&gt;强三色不变性和弱三色不变性是解决标记流程中对象漏标或错标的方案，还是看图好理解：&lt;img alt=&#34;强弱三色性&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111192153481.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：强弱三色不变性流程&lt;/center&gt;
&lt;p&gt;左边的强三色不变性意味着所有黑色对象不能白色对象，比如 A → B 就是种非法的情况。只要让程序中不出现这种情况，黑色只能指向灰色，灰色可任意指向，那么 GC 流程一定不会有漏标或错标的情况的，这是一种比较严格的限制。&lt;/p&gt;
&lt;p&gt;右边的弱三色不变性是说黑色对象可以指向白色对象，是合法的，但是必须保证还有指向灰色对象的可达路径，比如 A → E，前提是 A → C → E。因为有灰色可达路径，所以黑色对象指向白色对象是合法的，这种方式适当地放宽了强三色不变性的条件，保证了我们的算法可以顺利都执行完。&lt;/p&gt;
&lt;p&gt;以上都只是理论，我们要实现这两种三色不变性，最终还是回到了 writebarrier 或 readbarrier（Go 语言中没有）。&lt;strong&gt;需要注意&lt;/strong&gt;：在 GC 中的 writebarrier 和并发中的 writebarrier 不是一个东西。GC 中 barrier 的本质是：指针在编辑之前，可以插入一段代码 snippet of code insert before pointer modify，而 writebarrier 就是指的这段代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211119224915061&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111192249194.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 2：chan.go 中 writebarrier 的实现位置&lt;/center&gt;
&lt;p&gt;图中用红色下划线勾出来的意思是说，我们去触发 runtime.gcWriteBarrier 函数时，就是一个指针修改操作之前插入的一个函数调用。我们可以在源码中直接搜索 gcWriteBarrier 找到这个函数。因为反编译也能够看出这句函数调用的源码位置，所以我们可进入确认一下，它一定是一个指针的操作。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211119225429746&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111192254821.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 3：gcWriteBarrier 源码对应位置&lt;/center&gt;
&lt;p&gt;可以看到在源码的 252 行，确实是将 waiting 指针指向了空。&lt;/p&gt;
&lt;h2 id=&#34;强弱三色性的实现例子&#34;&gt;强弱三色性的实现例子&lt;/h2&gt;
&lt;p&gt;以上说了强弱三色不变性和 writebarrier，还都偏抽象、偏基础的，再来看一下强弱三色不变性分别通过哪些 writebarrier 来实现的。首先来一组实现例子：Dijkstra barrier 和 Yuasa barrier。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——三色标记</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day27-three_color_mark/day27-three_color_mark/</link>
      <pubDate>Wed, 17 Nov 2021 15:16:20 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day27-three_color_mark/day27-three_color_mark/</guid>
      
      <description>&lt;p&gt;上期文章说了很多关于标记的概念、流程，而标记的具体实现今天就来聊一聊。&lt;/p&gt;
&lt;p&gt;在了解标记之前我们需要了解&lt;strong&gt;三色抽象&lt;/strong&gt;。在 Go 语言的 MarkSweep 算法中它会把对象分成三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黑：已经扫描完毕，子节点也扫描完毕。(也就是在 mSpan 结构中的 gcmarkbits = 1，位于队列之外)&lt;/li&gt;
&lt;li&gt;灰：已经扫描完毕，但子节点未扫描完毕。(也就是子节点大概率是白色，在 mSpan 结构中的 gcmarkbits = 1，位于扫描队列 wbuf1 或 wbuf2 或者全局的 Globally unique work 之内)&lt;/li&gt;
&lt;li&gt;白：未扫描，collector 不知道任何相关信息。（也就是 gcmarkbits = 0，并且没有在任何队列中）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里黑、白、灰，本质上是抽象的概念，在代码中不会找到某个对象，它是表示颜色的。&lt;/p&gt;
&lt;p&gt;文字描述还是有点抽象，再来看看图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;三色标记基本流程 (1)&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111172257917.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：三色标记流程开始&lt;/center&gt;
&lt;p&gt;最开始有个 root，它是指全局变量或栈上的指针或栈上的对象，它们是整个 GC 扫描的起点 root。可以看出来整个 GC 的过程就是个简单的广度优先遍历算法流程。最开始扫描根对象的时候，会把这些根对象放在 gcWorkBuf 里面，并且把 gcmarkbits 置为 1，这时候就&lt;strong&gt;变成了灰色&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后从 gcWorkBuf 里取出指针，把它们的子对象往队列中放。比如 A 的两个子节点的 gcmarkbits 都被置为了 1 并且进入了队列，也就意味着 A 应该从队列中出来，这时候就会&lt;strong&gt;变成黑色&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当 E 的对象被推入到队列中后，它的子对象 F 会变为灰色，E 会变成黑色。按照这个过程一直执行下去，&lt;strong&gt;直到所有对象都会被扫描到并且被标记为黑色&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;三色标记基本流程&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111172315989.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 2：三色标记流程结束&lt;/center&gt;
&lt;p&gt;最后可以发现还有个 G 没有被标记到，这就之前说的语法不可达对象，也就是语法垃圾，它最终会被 sweeper 回收掉。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——标记流程</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day26-go_garbage_collection_mark/day26-go_garbage_collection_mark/</link>
      <pubDate>Mon, 15 Nov 2021 09:07:46 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day26-go_garbage_collection_mark/day26-go_garbage_collection_mark/</guid>
      
      <description>&lt;p&gt;&lt;strong&gt;Go 语言使用并发的三色标记（tricolor marking）算法作为其垃圾回收算法&lt;/strong&gt;，并且在 Go 中的 GC 没有分代，没有压缩，没有对象移动。整个 GC 流程如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;gc&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111152027238.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：GC 全流程&lt;/center&gt;
&lt;p&gt;整个图看起来觉得很复杂，代码很长，但其实里面的关键节点不是很多。左上角可以看到三种 GC 的触发的方式：后台触发，用户主动触发，内存分配触发。&lt;/p&gt;
&lt;p&gt;在触发之后会进入 runtime.gcStart 函数。因为很多内存分配器都会进来，但最终只有一个能够进去，所以它会抢一个全局锁。然后启动所有后端标记的 worker 并且把它和每个 P 绑定。每个 P 都会对应一个 BgMarkWorker，但不一定每个 worker 都能全部启动，其实是按比例启动的。所以在 cBgMarkStartWorkers 函数中初始化所有 worker 都会让它们进入一个休眠状态 goPark，它会在执行到 schedule 函数中的 finRunnableGCWorker 时之前休眠的 GC 标记线程唤醒，之后是从 G runing 状态变为 G waiting 状态。&lt;/p&gt;
&lt;p&gt;注意，在标记的时候会控制所有标记协程的 CPU，所以不能把所有的 P 上协程全部唤醒，如果全唤醒意味着 CPU 占用中标记就占用了了80% 到 90%，应用程序也就跑不起来了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gcDrain 是整个标记的主流程&lt;/strong&gt;。其中，mark 标记根节点，gc work 全局和本地的平衡，scan 对象并进行标灰。整个清扫过程完成之后会，会有一个分布式完成算法进行判断，然后会进入 gcMarkDone 函数。&lt;/p&gt;
&lt;p&gt;gcMarkDone 阶段会去把剩余的 write buffer 或 gc worker 里面的工作都清理掉。整个函数中还可能会有回退情况循环情况。标记完成之后就是 gcMarkTermniation ，也就是 GC Mark 的终极阶段。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——Go 语言垃圾回收流程</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day25-go_garbage_collection/day25-go_garbage_collection/</link>
      <pubDate>Thu, 11 Nov 2021 23:26:35 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day25-go_garbage_collection/day25-go_garbage_collection/</guid>
      
      <description>&lt;p&gt;&lt;strong&gt;Go 语言的垃圾回收机制采用的是标记清扫&lt;/strong&gt;。这种方法的特点在于：标记清扫完成之后，有些内存没办法被使用的，所以标记清扫很大的问题就是有很多内存碎片。我们在使用标记清扫算法的时候，需要内存分配算法能够一定程度上应对这种碎片问题，之前分析过分级分配的分配器可以在一定程度上应对这个问题。这也是为什么 Go 语言可以使用标记清扫算法，因为它使用了 tcmalloc，在一定程度上能够缓解碎片问题（但也没有解决）。&lt;/p&gt;
&lt;p&gt;老版本 Go 语言中，标记清扫大致是以下流程：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211112230308481&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111122303610.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：老版本 Go 的垃圾回收流程&lt;/center&gt;
&lt;ol&gt;
&lt;li&gt;最开始 Off 阶段，应用程序正常执行，可能没有调用 gc。&lt;/li&gt;
&lt;li&gt;当垃圾收集开始处于 Stack scan 阶段，会做一些栈扫描，从栈和全局变量中收集到一些基本的根指针，也就是整个对象图的根，在开始收集时需要去开启 write barrier。黄色的矩形标记的是要把 write barrier enable 这种全局变量改成 True，之后所有的指针变量都需要经过这种特殊的逻辑。&lt;/li&gt;
&lt;li&gt;在堆对象收集完成之后就开启了标记流程 Mark，其实就是个基础的广度优先算法，也可以当作多叉树来理解也是可以的。&lt;/li&gt;
&lt;li&gt;标记结束阶段 Mark termination，因为 write barrier 存在缺陷，所以在标记完成之后还需要对有全局或者已经变更的栈做一次扫描，把已修改的指针重新进行 GC 标记，防止在 GC 阶段发生对象的漏标或者错标情况。&lt;/li&gt;
&lt;li&gt;所有对象标记完成之后进入 Sweep 阶段，做一些清扫工作，这段流程之后垃圾就被回收掉了。被垃圾占用过的空间就可以被重新拿来分配。如果不需要那么多内存，那就会把分配器还给操作系统。&lt;/li&gt;
&lt;li&gt;完成整个清扫、回收过程之后，把 GC 设置为 Off，也就重新回到应用程序执行阶段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Go 语言在 1.8 版本以后，通过混合 write barrier 消除了第二个 stw 中的 stack re-scan，也就是说 stw 时间大大减少了。stw 位于图中红白的矩形块阶段，是指这段时间内只有垃圾回收在执行，应用程序是被阻塞住的，两个红色阶段都是被阻塞住的。早期版本的 stw 的时间是比较长的，因为它会扫描所有全局或者变动的栈，这里就非常耗时了。&lt;/p&gt;
&lt;p&gt;新版本的垃圾回收流程和原来有些区别：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211112230254975&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111122302132.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 2：新版本 Go 的垃圾回收流程&lt;/center&gt;
&lt;p&gt;Go 官方做了些优化，第二个 stw 过程中不用去做全栈扫描，因此时间大大缩短了。整体流程也发现了非常大的变化。如果去看了 Go 语言源码，可以发现每两三个版本垃圾回收模块的逻辑变化挺大，很多内部的实现都变了，有时候两个版本之间可能只有主函数或关键流程差不多。因此我们也可以得出结论：Go 语言垃圾回收的模块是变化非常频繁的，如果不是工作需要或兴趣趋势，简单了解流程就行了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——垃圾回收基础</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day24-garbage_collection_base/day24-garbage_collection_base/</link>
      <pubDate>Wed, 10 Nov 2021 15:18:35 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day24-garbage_collection_base/day24-garbage_collection_base/</guid>
      
      <description>&lt;p&gt;之前说的内存回收可以用这张全局图来解释，总共 6 个 level 的分配结构，把这几个链路都梳理弄清楚就能有个清晰理解。&lt;/p&gt;
&lt;p&gt;垃圾回收的理解更为难，需要一些算法基础，否则在看这部分知识的时候很可能完全看不懂。&lt;/p&gt;
&lt;p&gt;在理解垃圾回收之前，首先需要先对垃圾做一个分类，程序当中有两类的垃圾，语义垃圾和语法垃圾。&lt;/p&gt;
&lt;p&gt;语义垃圾(semantic garbage)，有时也称为内存泄露，是指从语法上可触达的对象（包括可通过局部、全局变量引用得到的对象），但从语义上来讲他们都是垃圾，垃圾回收器对它们无能为力。&lt;/p&gt;
&lt;p&gt;语法垃圾(syntactic garbage)是指从语法上无法触达的对象，这些才是垃圾收集器收集的主要目标。比如有些内存无论用怎样的代码去操作都是无法接触到的。&lt;/p&gt;
&lt;p&gt;这里有几个例子有助于理解：&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——Go 内存管理（2）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day23-go_memory_management_2/day23-go_memory_management_2/</link>
      <pubDate>Sat, 06 Nov 2021 16:55:34 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day23-go_memory_management_2/day23-go_memory_management_2/</guid>
      
      <description>&lt;p&gt;Go 语言在内存管理中申请使用稀疏堆时，使用系统调用 mmap ，因此可以分配出不连续的地址（而不是通过系统调用 brk 来调整虚拟空间里堆的 program break 来分配连续内存地址）。在使用稀疏堆时，整体的堆内存怎样增长的呢？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;堆内存增长过程&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111071005412.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 1：稀疏堆内存增长过程&lt;/center&gt;
&lt;p&gt;较大的内存块 arenas 其实是个大的指针数组，每个指针就是 mheap arena 结构，它会指向具体的 64 MB 的内存，在当前的 mheap 结构中还会维护最后一个起始位置和结束地址。一旦分配内存的时候真实结束地址超过了 mheap 结束地址时，说明还需要从操作系统要更多虚拟内存，这时还是执行  mmap 再分配一个 64 MB 的地址空间，并且维护好当前的数据结构，把原来的 n 变为 n+1 相当于增加了一个元素。&lt;/p&gt;
&lt;p&gt;在 Go 语言中除了从操作系统申请内存的方式以外，在分配时还要区分内存大小，有三种分配大小分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiny：size &amp;lt; 16 bytes &amp;amp;&amp;amp; has no pointer(noscan)&lt;/li&gt;
&lt;li&gt;Small: has pointer(scan) || (size &amp;gt;= 16 bytes &amp;amp;&amp;amp; size &amp;lt;= 32KB)&lt;/li&gt;
&lt;li&gt;Large: size &amp;gt; 32KB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且，内存分配器在 Go 语言中为了做一些优化，维护了一种多级结构：&lt;/p&gt;
&lt;center&gt;mcache → mcentral → mheap&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;mcache：与 P 绑定，本地内存分配操作，不需要加锁。&lt;/li&gt;
&lt;li&gt;mcentral：中心分配缓存，分配时需要上锁，不同 spanClass 使用不同的锁。&lt;/li&gt;
&lt;li&gt;mheap：全局唯一，从 OS 申请内存，并修改器内存定义结构时，需要加锁，是个全局锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在距离应用代码最近的 P 的位置，每个 P 都绑定了 mcache 结构，这个结构会有大小相应的缓存。本地分配内存时会优先从 mcache 中找，如果找不到就要从全局的缓存中去找，如果还是没有相应的内存块可以用的话，就需要去全局唯一的  mheap 请求，从操作系统重新划分一部分内存出来。不过 mheap 还有 area 结构，如果 area 还没有用完的话还是会从 area 里面去切分，如果用完了就会去操作系统中去申请。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——Go内存管理（丢失）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day22-go_memory_management/day22-go_memory_management/</link>
      <pubDate>Wed, 03 Nov 2021 07:20:48 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day22-go_memory_management/day22-go_memory_management/</guid>
      
      <description></description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——进程与虚拟内存的分布</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day21-virtual_memory_management/day21-virtual_memory_management/</link>
      <pubDate>Tue, 02 Nov 2021 22:19:25 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day21-virtual_memory_management/day21-virtual_memory_management/</guid>
      
      <description>&lt;p&gt;没想到继续更文已经是一个月半以后了。立个小小的 flag，到年底把 Go 基础与浅层的内核过一遍。保持两天一更的节奏。还是继续接着上期说的内存管理。了解了内存管理抽象的基础概念之后，来看一下一些具体的实现。&lt;/p&gt;
&lt;h1 id=&#34;虚拟内存的分布&#34;&gt;虚拟内存的分布&lt;/h1&gt;
&lt;p&gt;首先来看一下虚拟内存是如何布局的，这部分其实算是操作系统的内容。在《The Linux Programming Interface》这本书中提到了一张图，描述了 32 位操作系统大致的虚拟地址空间的分布是怎样的：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211102222059379&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111022220502.png&#34;&gt;&lt;/p&gt;
&lt;center&gt; 图 1: 32 位操作系统虚拟内存地址分布&lt;/center&gt;
&lt;p&gt;因为是 32 位操作系统，所以总的地址空间是 4 GB。可以看到上方是高地址，下方是低地址，所以可以看到以下几个特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈 Stack 是从高地址向低地址增长的。&lt;/li&gt;
&lt;li&gt;堆 Heap 是从低地址向高地址增长的。&lt;/li&gt;
&lt;li&gt;调整堆顶一般来说是调整的 Program break。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后再来看看我们常用的 64 位系统中进程虚拟内存的分布是怎样的，摘自网络：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211102223150938&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111022231059.png&#34;&gt;&lt;/p&gt;
&lt;center&gt; 图 2: 64 位操作系统虚拟内存地址分布 &lt;/center&gt;
&lt;p&gt;这张图可能不是很准确，感兴趣可以去官方文档，描述更加详细：https://www.kernel.org/doc/html/latest/x86/x86_64/mm.html 。&lt;/p&gt;
&lt;p&gt;可以看到 64 位操作系统可使用的虚拟内存空间是增加的，并且基本上都是以 TB 为单位。但通过对比功能可以发现，其实 64 位内存的整体布局和 32 位的内存布局大差不差。&lt;/p&gt;
&lt;p&gt;前面说到的都是单线程的情况，而在 Go 中我们会经常用到多线程，那么多线程的情况下，进程虚拟内存又是怎么分布的呢？一图就懂：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20211102223936677&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202111022239800.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图 3: 多进程下 32 位系统虚拟内存地址分布&lt;/center&gt;
&lt;p&gt;相比单进程，可以看到栈的变化最大。主线程的栈还是从上往下增长，但是其他的线程会分布在中间，并且中间会穿插动态链接库 Shared libraries、共享内存 shared memory。&lt;/p&gt;
&lt;p&gt;而堆空间没有什么变化，但也意味着它对其他线程来说都是公用的。所以线程要访问堆上的东西都一般是需要加锁的。&lt;/p&gt;
&lt;p&gt;OK，了解了虚拟内存地址分布情况，那么是谁来对内存进行分配呢？没错，有请下一位主角登场。&lt;/p&gt;
&lt;h1 id=&#34;内存分配器&#34;&gt;内存分配器&lt;/h1&gt;
&lt;p&gt;内存分配器 Allocator，理论上分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性分配器 Bump / Sequential Allocator&lt;/li&gt;
&lt;li&gt;空闲链表分配器 Free List Allocator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线性分配器在分配内存时都是从虚拟内存中扒一点出来，下次还要分配又继续扒，继续扒 &amp;hellip; 如果中间有内存释放掉了 free，这些线性分配器也不会对这些被释放掉的内存进行复用。而如果我们现在的需求就是要对空间进行复用的话，就需要额外的链表来维护被释放掉的块，这也叫做空闲链表分配器。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——内存管理</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day20-memory_management/day20-memory_management/</link>
      <pubDate>Sun, 12 Sep 2021 10:01:17 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day20-memory_management/day20-memory_management/</guid>
      
      <description>&lt;p&gt;&lt;strong&gt;发生内存泄露时，要知道内存如何进行分配，垃圾回收要找出哪些对象有用，哪些对象无用。尤其当系统到达高并发瓶颈时，更需要垃圾回收这一角色做好风险把控，否则就是大型灾难现场&lt;/strong&gt;。今天就来聊聊内存管理与垃圾回收。&lt;/p&gt;
&lt;h1 id=&#34;背景介绍&#34;&gt;背景介绍&lt;/h1&gt;
&lt;p&gt;垃圾回收 Garbage Collection ，我们一般称为 GC。在现实世界中，说到垃圾，指的就是那些不读的书、不穿的衣服等。在计算机中，GC 把程序不用的内存空间视为垃圾。但究其本质，&lt;strong&gt;GC 本身也是一个程序&lt;/strong&gt;，如果满足两项功能的程序，我们就可以叫它 GC：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到内存空间中的垃圾&lt;/li&gt;
&lt;li&gt;回收空间，让程序员能够再次利用这部分空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在没有 GC 的年代，像 C 语言程序员必须自己手动去分配内存，必须确保申请多少大小的内存空间，在程序执行完释放不再需要的空间。因为在当时计算机的内存资源是稀缺和昂贵的，现在我们买一个 G 内存条的价格相当于当时买 1 KB 的价格，所以程序员写代码时操作都是小心谨慎的。&lt;/p&gt;
&lt;p&gt;人为操作，难免有疏忽的地方。如果忘记释放内存空间，该内存空间就会发生泄露。意味着这块空间将会继续维持被使用的状态，无法被使用。一部分内存泄露放任不管，直到所有内存被占满了，整个系统也就崩溃了。&lt;/p&gt;
&lt;p&gt;另外，在释放内存空间时，如果忘记初始化用于释放内存的指针，这个指针就会一直指向释放完成的内存空间。更有甚者，释放的空间错误，导致下次程序使用这个空间时发生故障。这些内存上的 bug 都是难以确定真实原因的，因为与内存分配时疏忽造成的 bug 和真实场景下发生的位置（或时间）是不一致的。&lt;/p&gt;
&lt;p&gt;为了略去以上种种的麻烦与困难，聪明的人们研发了 GC，即把内存管理的工作交给计算机，程序员就不用想着什么时候要释放内存，不用再担心忘记释放内存所导致的 bug，从而大大减轻负担，将更多精力和注意力放在业务开发上。&lt;/p&gt;
&lt;p&gt;在学习难度上，如果说内存分配难度在 2 ，那么垃圾回收的难度就在 4，相比之下难度翻倍。并且学习垃圾回收必须掌握扎实的理论基础，否则难以读懂代码，不知道在干什么。有三本关于垃圾回收的书，可以去读一读：《垃圾回收的算法与实现》、《垃圾回收算法手册-自动内存管理的艺术》、《深入 Java 虚拟机》。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上，Go 官方的 runtime 作者中能够去维护 GC 代码的人也很少。&lt;/p&gt;
&lt;p&gt;据说，GC 是因为 Java 的发布而一举成名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;基础概念&#34;&gt;基础概念&lt;/h1&gt;
&lt;p&gt;我们&lt;strong&gt;在学习内存分配的和 GC 的时候需要经常去问自己一些问题，顺着问题的思路去找代码会方便些&lt;/strong&gt;。如果直接埋头去看 Go 语言内存相关的代码肯定会很蒙蔽的，毕竟内部数据结构真的很多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存分配：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存从哪里来？&lt;/li&gt;
&lt;li&gt;内存要到哪里去？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GC 中标记流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标记对象从哪里来？&lt;/li&gt;
&lt;li&gt;标记对象到哪里去？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GC 中清扫：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;垃圾从哪里来？&lt;/li&gt;
&lt;li&gt;垃圾到哪里去？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;当掌握了对象的流向以后，一些中间遇到的数据结构就能够连接起来。这在往期文章谈“调度”的时候提到的“生产-消费”流程非常相似。只要我们为这些问题找到了答案，也就慢慢地学会每一个流程具体是怎么实现的，并且写出自己的总结。&lt;/p&gt;
&lt;p&gt;在任何一门编程语言中，都会有栈分配和堆分配的概念。&lt;/p&gt;
&lt;p&gt;栈分配，是指函数调用返回后，函数栈帧自动销毁（SP 下移）。函数调用时，会有函数栈帧，这个栈帧上面所有的变量都是函数的局部变量，在做函数调用的时候就相当于把栈从高地址向低地址增长的过程，然后移动栈顶的寄存器。在函数地址返回以后，被调用栈上的内容也就无效了。把这个栈直接干掉，返回回去，这部分内存就得到释放了。这个才做非常轻量化，既不需要对这段内存上的东西进行任何置零操作，也不需要关心这段代码做了什么事。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;示例代码调用规约&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109121231501.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;栈分配回收示例&lt;/center&gt;
&lt;p&gt;而堆分配就不是一个轻量级的操作。一个 C 语言示例，思考一下：返回函数的局部变量会怎样变化？&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>GO 翻山越岭——系统调用调试工具</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day19-tools_and_sys/day19-tools_and_sys/</link>
      <pubDate>Thu, 09 Sep 2021 22:43:41 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day19-tools_and_sys/day19-tools_and_sys/</guid>
      
      <description>&lt;p&gt;&lt;strong&gt;了解系统调用就能在业务发生问题时有更多招数，见招拆招&lt;/strong&gt;。知道了系统调用的概念，有时候我们还需要用工具去实际观察进程是如何发起系统调用，对操作系统做了哪些请求，今天就来聊一聊。&lt;/p&gt;
&lt;h1 id=&#34;观察系统调用工具&#34;&gt;观察系统调用工具&lt;/h1&gt;
&lt;p&gt;在 Linux 中我们常用用观察系统调用的工具是 strace，在 macOS 系统上常用的是 dtruss&lt;/p&gt;
&lt;p&gt;案例1，通过 strace 可以看到一个 Go 进程的启动过程到底调用了哪些系统调用，这里有个例子（具体代码不用关注）：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20210909230308944&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092303708.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;系统调用示例&lt;/center&gt;
&lt;p&gt;使用 strace 指令 + 可执行文件x，看到了有哪些系统调用函数被调用。execve 执行哪个二进制文件，arch_prctl、sched_getaffinity 设计 CPU 亲和度，oepnat 加载相关文件，mmap 系统映射，gettid 获取线程 ID。&lt;/p&gt;
&lt;p&gt;案例2，通过 strace 还可以查看一些软件的做了哪些系统调用，比如查看 nginx 的：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20210909231712937&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109092317098.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;查看nginx 系统调用&lt;/center&gt;
&lt;p&gt;我们知道 nginx 在平时不服务的时候都是阻塞的状态，即阻塞在某个系统调用上。使用 strace 指令 + -f 参数 + nginx 可以观察它启动的过程。如果这个软件需要创建多个进程，就需要这里的 -f 的 flag 参数，跟踪所有刚启动线程创建的其他进程。最后我们可以发现 nginx 阻塞在 pid 为 224 的 epoll_wait 上。&lt;/p&gt;
&lt;p&gt;注意：在 docker 中用这个命令可能会遇到一些问题，可以参考这个链接《Why strace doesn&amp;rsquo;t work in Docker》https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/&lt;/p&gt;
&lt;p&gt;案例3，通过 strace 观察一个 Go 语言 Hello world 程序生命周期中系统调用情况。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>GO 翻山越岭——Go 常见系统调用</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day18-go_and_sys/day18-go_and_sys/</link>
      <pubDate>Tue, 07 Sep 2021 07:28:31 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day18-go_and_sys/day18-go_and_sys/</guid>
      
      <description>&lt;p&gt;系统调用，是操作系统内核为应用提供的 API。今天继续来讲一个系统调用案例和 Go 中常见系统调用&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;arch&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;syscall NR&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;return&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;arg0&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;arg1&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;arg2&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;arg3&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;arg4&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;arg5&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;213&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;epoll_create&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;man/ cs/&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0xd5&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;int size&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;-&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;-&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;-&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;-&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;来源：https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit&lt;/p&gt;
&lt;p&gt;这是 Linux 中的系统调用，编号是 213，我们可以从一下代码了解更多信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ABAP&#34; data-lang=&#34;ABAP&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SYS_epoll_create&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;213&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;TEXT&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;epoll_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;SB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NOSPLIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;MOVL&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;FP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;DI&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;MOVL&lt;/span&gt;	&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;SYS_epoll_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AX&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;SYSCALL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;MOVL&lt;/span&gt;	&lt;span class=&#34;nv&#34;&gt;AX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;FP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;RET&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编号 213 按照调用规约会被存储在 rax 寄存器中，也就是这里的 AX 寄存器。epoll_create 只有一个阐述传递，也就是 int 类型的 size。SYSCALL 直接进入内核去了。&lt;/p&gt;
&lt;p&gt;因此，我们需要知道 SYSCALL 之后发生了什么，即我们写好应用程序 Application program 执行了哪些 SYSCALL 逻辑。从下图可以得知：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;SYSCALL 之后发生了什么&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109072232527.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;当我们调用了 syscall.EpollCreate 之后进入了 syscall 包中的一段代码，然后根据一定的规则翻译成 runtime.RawSyscall，里面会有一堆准备参数和逻辑，完了之后就是执行 SYSCALL 指令。上期说的我们写的代码处于 CPU 分级保护域 ring-3，执行这个指令之后就能帮助我们从 ring-3 切换到 ring-0，然后去执行内核相关的代码了。ring-0 内核模式下什么操作都能够进行，没有特别的权限限制。内核也有相关的系统调用表（在最上面的链接中），会去调用具体的系统调用实现。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——系统调用基础</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day17-lang_and_sys/day17-lang_and_sys/</link>
      <pubDate>Mon, 06 Sep 2021 20:26:32 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day17-lang_and_sys/day17-lang_and_sys/</guid>
      
      <description>&lt;p&gt;编程语言和操作系统之间的桥梁，也就是我们所说的系统调用。今天来聊聊，系统调用的基础概念。&lt;/p&gt;
&lt;h1 id=&#34;什么是系统调用&#34;&gt;什么是系统调用&lt;/h1&gt;
&lt;p&gt;我们在了解系统调用之前，需要对操作系统有个简单的了解。操作系统（operating system,OS）是&lt;strong&gt;资源的管理器&lt;/strong&gt;，也是计算机系统的内核与基石，其管理的资源都是经过了抽象。而对计算机来说，资源是硬件信息：CPU、RAM 内存、I/O 设备，以及进一步抽象的软件资源，如进程。&lt;/p&gt;
&lt;p&gt;为什么说操作系统是对资源进行了抽象呢？因为操作不方便、操作不安全，我们平时接触到的不是直接的硬件，比如磁盘操作，不会去操作扇区（嵌入式系统除外）。而我们所面对的都是这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘抽象：文件夹&lt;/li&gt;
&lt;li&gt;内存抽象：虚拟内存&lt;/li&gt;
&lt;li&gt;CPU 抽象：时间片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了操作系统，我们对计算机的调度还是不够的。说白了，操作系统也是一个应用程序，底层还是一堆代码和汇编指令。这时候，我们需要由硬件提供支持，在应用和操作系统之间进行一层或多层隔离。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20210906210117219&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109062101385.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;分级保护域&lt;/center&gt;
&lt;p&gt;CPU 已经为操作系统提供了特殊的安全支持——分级保护域（protection ring）。操作系统内核运行在特殊模式下，即图中的 ring-0 ，而应用运行在 ring-3，但权限被严格限制。因此，在代码中我们没办法直接去调用系统资源，就需要操作系统帮助我们去调用，并把相应的操作抽象成 API 来供我们使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Intel64 有四个特权级别，不过实际上只用到了其中两个 ring-0 和 ring-3。ring-1 和 ring-2 本来计划是为了驱动程序和 OS 服务用，不过流行的 OS 们都没有接受这个方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说到这里，答案已经揭晓。&lt;strong&gt;系统调用，是操作系统内核为应用提供的 API&lt;/strong&gt;。可以理解为内核为应用提供服务，操作系统就位我们的上层应用程序提供了一系列“标准库”。比如我们常见的后端服务：APP 发起请求 request → 操作系统 Operating System 接收、处理并响应 →  APP 接收 response。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于应用来说，系统调用可以实现超出自己能力以外的事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么 Go 语言中的系统调用是怎样的呢？在此之前，还需要提及 &lt;strong&gt;Go 语言调用规约&lt;/strong&gt;。我们在做函数调用的时候没有使用寄存器，而是将参数都放在栈上。但在其他编程语言中做参数传递和函数调用都是用到了寄存器。举个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;z&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;multi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;multi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码的调用规约如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;未命名文件 (5)&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109062141634.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;示例代码调用规约&lt;/center&gt;
&lt;p&gt;这里也说明一下什么是寄存器。寄存器，是CPU 内部的特殊存储单元。一般是用二极管做的，价格比较高，数量比较少。又因为寄存器少，所以有具体的名字。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;CPU 与内存 (1)&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109062206995.png&#34;&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Context</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day16-data-structure_context/day16-data-structure_context/</link>
      <pubDate>Sun, 05 Sep 2021 15:48:38 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day16-data-structure_context/day16-data-structure_context/</guid>
      
      <description>&lt;p&gt;Go 语言在 1.16 版本之后加入了新的内置数据结构 Context，虽然在代码中使用都比较简单，但语言内部还是做了许多区分，今天来分析一下 Context。&lt;/p&gt;
&lt;h1 id=&#34;context&#34;&gt;Context&lt;/h1&gt;
&lt;p&gt;虽然在使用 context 的时候，看起来都是 context.* 的结构，但 Go 语言内部做了这样一个区分：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Context 操作&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109051711081.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;context 操作&lt;/center&gt;
&lt;p&gt;具体说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;emptyCtx：所有 ctx 类型的根&lt;/li&gt;
&lt;li&gt;valueCtx：主要为了在 ctx 中嵌入上下文数据，一个简单的 k 和 v 结构，同一个 ctx 内只支持一对 kv，需要更多的 kv 的话，会形成树形结构。&lt;/li&gt;
&lt;li&gt;cancelCtx：取消程序的执行树&lt;/li&gt;
&lt;li&gt;timerCtx：在 cancelCtx 上包了一层，支持基于时间的 cancel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有个例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s&#34;&gt;&amp;#34;context&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;orderID&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;TODO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;orderID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;orderID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;2345&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;orderID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;3456&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;orderID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体流程如下，前一个节点是后一个节点的 parent&lt;/p&gt;
&lt;p&gt;valueCtx{ k: 3, v: 3456 }  →  valueCtx{ k: 2, v: 2345 } → valueCtx{ k: 1, v: 1234} → emptyCtx&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Map</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day15-data-structure_map/day15-data-structure_map/</link>
      <pubDate>Thu, 02 Sep 2021 23:23:12 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day15-data-structure_map/day15-data-structure_map/</guid>
      
      <description>&lt;p&gt;Map 有时能够返回一个值，有时候能够返回多个值，这是 &lt;strong&gt;Map 的特权语法&lt;/strong&gt;。今天继续从底层角度来聊聊 Go 语言内置数据结构，Map。&lt;/p&gt;
&lt;h1 id=&#34;map&#34;&gt;Map&lt;/h1&gt;
&lt;p&gt;Map 中大量类似但又冗余的函数，原因之一便是没有泛型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;v1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;利用之前提到的工具 go tool objdump 能够获得反汇编后的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make → runtime.makemap&lt;/li&gt;
&lt;li&gt;10 → hint&lt;/li&gt;
&lt;li&gt;m[1] → runtime.mapaccess1_fast64&lt;/li&gt;
&lt;li&gt;m[2] → runtime.mapaccess2_fast64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上这些过程都是编译器帮我完成的，编译器判断赋值语句，如左边有一个值就翻译为 runtime.mapaccess1_fast64， 需要注意以下三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当 hint  大小大于 8 时，采用的是 makemap&lt;/li&gt;
&lt;li&gt;当 hint 小于 8 时，采用的是 makemap_small&lt;/li&gt;
&lt;li&gt;map 分配栈上时，不一定会调用 makemap&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;Map 函数一览&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109042253388.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;Map 底层函数一览&lt;/center&gt;
&lt;p&gt;为什么一个 Go 语言内置数据结构就有这么多情况，那如果 Go 的 20 来个内置数据结构都有这种判定，岂不是底层就有差不多 60 个不同判定结构？确实是这样的，map 中存在大量类似但又冗余的函数，但不至于把性能拉低很多。这种问题主要是原因之一是 Go 语言在 1.16 版本前没有泛型。可喜的是，在 Go 1.17 版本之后将会引入泛型，大家感兴趣已经可以自己去尝试了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Timer</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day14-data-structure_timer/day14-data-structure_timer/</link>
      <pubDate>Mon, 30 Aug 2021 23:13:54 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day14-data-structure_timer/day14-data-structure_timer/</guid>
      
      <description>&lt;p&gt;上期 Go 文章说道了 Go 内置数据结构，从底层源码角度简单地描述了 channel。今天继续分析其他的内置数据结构 Timer。&lt;/p&gt;
&lt;h1 id=&#34;timer&#34;&gt;Timer&lt;/h1&gt;
&lt;p&gt;Timer 在 golang 1.14 版本以前比较简单，整个 Timer.go 文件中代码 才 700 行左右。整个代码就是一个数据结构和许多 goroutine。但 golang 到了 1.14 版本以后，由于官方的升级维护就变得非常复杂。所以这里笔者简单讲一下 Timer 的迭代历史，状态机制不会涉及到。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;未命名文件 (1)&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108302359026.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;从这张图可以看到**，最早的 Timer 就是一个四叉堆**。我们平时写算法的时候二叉堆见得比较多，那是不是理解这个更困难？不是的，我们着重看 Timer 的结构和演进。像最早的 time.Sleep 或者 time.After 这两个函数，实际上我们创建了两个 Timer 类，这个 Timer 会最终加到我们的 runtime 维护的四叉堆里面。这个四叉堆其实是很好理解的，其实是有个基准的。&lt;/p&gt;
&lt;p&gt;堆顶要放什么元素，元素如何排列？都是以触发时间为准。也就是说离当前时间最近的，一定是在堆顶的。如果来了一个新的 Timer ，它是在这个时间之后，它就会继续往堆下面走。如果比堆顶小就会涉及到对当前四叉堆的调整了，这个和写二叉堆调整算法很类似。&lt;/p&gt;
&lt;p&gt;最老的 Timer 实现全局只有一个四叉堆，这个四叉堆专门启用一个叫做 timerproc 的 goroutine。这个 goroutine 的逻辑也不复杂，就是用一个 for 循环。这个 for 循环会不断地检查堆顶元素是不是已经到期了，如果到期了就会触发，在触发的同时会逐渐地调整堆，直到把所有需要触发的 Timer 都触发完毕为止，继续去休眠。&lt;/p&gt;
&lt;p&gt;但这种单一的四叉堆会有一个问题。当前 Go 程序所有的 goroutine 在执行 Timer 相关操作的时候都需要去抢占操作这个堆的全局锁，而其实这个锁都是写锁。如果并发量很高，那么就会导致程序整体的吞吐量下降。全局锁对于任何程序来说，性能影响都比较大，这个问题导致了 go 程序在多核处理器上性能不佳，有人专门提了一个 issues：https://github.com/golang/go/issues/15133。（就 python 来说， 虽然 python 支持多进程，也支持多线程。但因为 GIL 全局解释器锁的存在，python 的多线程程序在同一时间只有一个线程在运行。所以多线程 Python 程序只是并发，而不是并行）&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Channel</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day13-data-structure_channel/day13-data-structure_channel/</link>
      <pubDate>Sun, 29 Aug 2021 14:47:52 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day13-data-structure_channel/day13-data-structure_channel/</guid>
      
      <description>&lt;p&gt;&lt;strong&gt;内置数据结构是一门编程语言的基础核心&lt;/strong&gt;，了解基本语法就能够让我们进行简单的开发。今天开始，就来系统地研究 Go 语言内置数据结构。&lt;/p&gt;
&lt;p&gt;首先，先来看看所有的Go 语言所有内置数据结构都有哪些，如下图所示，列出了思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;未命名文件&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108291453518.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;既然是系统地研究，这里就需要用到暴力破解的思想——把每个数据结构都遍历吃透。&lt;/p&gt;
&lt;h1 id=&#34;channel&#34;&gt;Channel&lt;/h1&gt;
&lt;p&gt;之前的文章中提到了通过反汇编调试工具来查看 Go 语言的源码。还提到了三种情况会导致 panic 的关键函数 chansend、chanrecv，下面来进行源码逻辑分析。忽略一些细节实现，来看看 chansend 的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;chansend 流程图&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108291706892.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;图上省略了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;select dafault 的情况。&lt;/li&gt;
&lt;li&gt;逻辑执行时碰到 ch 已 close 的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从流程图，能够清晰地看到 在 chansend 的内置函数中，Go 语言是如何处理我们发送的数据。紧接着我们再来看看 chanrecv 的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;chanrecv 流程图&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108291706194.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;图上也省略了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;select default 的情况。&lt;/li&gt;
&lt;li&gt;逻辑执行时碰到 ch 已经 close 的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对比发现，两个流程差不多，因此 channel 的发送和接收的逻辑都是差不多的，都要判断是否为空，是否阻塞，然后看缓存情况，一个明显不一样的特征是 chansend 要判断满，chanrecv 要判断空。&lt;/p&gt;
&lt;p&gt;我们常说Go 语言中 channel 是并发安全的，什么意思呢？从上面的流程可以发现：chansend、chanrecv、closechan 都是要加锁的。即便如此，从代码层面我们还是看不到这些锁，那我们能否通过代码来看，“并发安全”具体而言是什么意思呢？下面罗列了三者的源码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// chansend 源码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;chansend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;callerpc&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;gopark&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitReasonChanSendNilChan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;traceEvGoStop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unreachable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// chanrecv 源码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;chanrecv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selected&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;received&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;gopark&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitReasonChanReceiveNilChan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;traceEvGoStop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unreachable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// closechan 源码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;closechan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;plainError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;close of nil channel&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然我们在用户态完全看不到，但我们可以从底层源码看到这个明显的加锁操作，并且这个加锁的操作基本上都是在函数开始加锁，函数结束解锁，除了 goready() 要放在锁外面，其他也没有什么特殊的，这便是达成并发安全的条件之一。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——编译器应用（3）</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day12-parser_app/day12-parser_app/</link>
      <pubDate>Sat, 28 Aug 2021 15:14:37 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day12-parser_app/day12-parser_app/</guid>
      
      <description>&lt;p&gt;上期说到两种复杂的 Parser场景，通过借鉴业界成熟的技术方案，能够大大节约我们自己的时间。今天再来谈谈最后一个 Parser 应用场景和 Parser 总结。&lt;/p&gt;
&lt;h1 id=&#34;客户定制需求&#34;&gt;客户定制需求&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;场景8，我们公司是做 ToB 的服务，我们的软件会先编译完再卖出去，比如我们公司是用 Go 开发的，假如我们是卖 gRPC 服务的，而用户想要在此基础上做一些定制，他们也有自己的开发人员，比如说实现内部的 RPC 协议。用户想定制，而我们想不给他们源代码并且能够支持他们的定制需求，这就需要些技术手段来解决。（特别是 Go 语言的生态还不是很完善，并且每个方案都有自己的缺陷）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在给客户交接系统的时候，客户想要自己的 RD去做些开发工作（一般指研发工程师）。而我们知道，Go 程序需要编译成二进制文件才能使用，因此让 Go 模块去做热更新是非常难的。为了满足这样的需求，我们应该怎样来做扩展呢？业界目前有四种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RPC&lt;/li&gt;
&lt;li&gt;go-plugin&lt;/li&gt;
&lt;li&gt;REPL，社区的解释器方案&lt;/li&gt;
&lt;li&gt;WASM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上&lt;strong&gt;四种方案都有不足，具体还是要看我们在真实业务场景中能够接受哪种折中的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;RPC 中，在两个系统之间定义好交互的 API，要做扩展那么就将新系统中所有的扩展做成 API，要实现这个扩展，就在原系统中调用一下就好。但 RPC 自身也有一定&lt;strong&gt;性能问题&lt;/strong&gt;，如做些网关之类的扩展就不适合。&lt;/p&gt;
&lt;p&gt;go-plugin 在Go 1.8版本就有，但也是有缺陷的：不同版本编译不兼容。用户编译出的 plugin 和我们的原始二进制文件必须要用相同的版本去编译才能通过。&lt;/p&gt;
&lt;p&gt;REPL，社区的解释器方案例如 gopherjs、gopherlua，这些都是不错的项目，在可以在线上去用这些东西，并给用户提供局部热更新的功能。但问题就在于，有些业务需求不一定社区有。&lt;/p&gt;
&lt;p&gt;WASM（webAssemble）是一种不针对特定平台的二进制格式文件，也是目前比较新的方案。理论上在每个语言直接互相调用没有性能损失的，但 Go 语言版本不是很完善，所以这个方案也是在调研阶段。有些公司只是在做些宣传、&lt;/p&gt;
&lt;h1 id=&#34;parser-总结&#34;&gt;Parser 总结&lt;/h1&gt;
&lt;p&gt;OK，到目前为止，我们了解了编译和反编译工具去找 Go 程序的语法具体实现，以及用到 Parser 知识可以在实际公司的业务里面去做些探索。但说到底，如果我们掌握了编译原理的知识就能够在很多场景下找到比较灵活的方案。&lt;/p&gt;
&lt;p&gt;对于像笔者一样大学毕业工作不久，因工作需要转到用 Go 语言，而 Go 语言入门又没多久的同学来说。大学期间我们学习编译原理感到 枯燥、困难，略有些脱离实践，因此学习得不扎实，勉强通过。而工作期间又确确实实需要这方面实打实的知识，怎么办？边做边看。既然大学的时光已经过去，一去不复返，那么能抓住的就是现在。业务上需要什么我们去看什么，同时多去逛逛技术社区和论坛，比如汇总整理了几个有意思 Parser 项目的项目：https://github.com/cch123/parser_example，将自己的技术面拓宽，尽可能地边实践，边回顾理论。&lt;/p&gt;
&lt;p&gt;之前总结了 8 个 Parser 场景，其实我也只经历了两个的样子。经验非常受到局限，但是我们通过学习，通过学习技术前辈曹大所经历的、所见识的，就能让我们也坐上通往技术前方的高铁。不知道，不擅长没关系；先了解，多了解，以后总还有可能遇到。到时我们就不再是愁思苦想，而是胸有成竹了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1] Go进行wasm编程, 博客园&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/codingnote/p/12453872.html&#34;&gt;https://www.cnblogs.com/codingnote/p/12453872.html&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——解释器</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day10-parser/day10-parser/</link>
      <pubDate>Sun, 22 Aug 2021 22:51:00 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day10-parser/day10-parser/</guid>
      
      <description>&lt;p&gt;上期文章遗留了一个问题“三个 panic 在 runtime 代码的具体哪个位置输出”，如果通过汇编调试工具找出来。今天来动手实践，并且尝试解决另一个业务问题。&lt;/p&gt;
&lt;h1 id=&#34;问题回顾&#34;&gt;问题回顾&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;分别有三种情况的 panic：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;往已经关闭的 channel中写入数据&lt;/li&gt;
&lt;li&gt;关闭一个是 nil 值的 channel&lt;/li&gt;
&lt;li&gt;关闭一个已经是关闭状态的 channel&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;要找出它们在 runtime 代码中具体位置，首先我们先写几个小型代码，来完全模拟这几种情况。&lt;/p&gt;
&lt;p&gt;情况1：往已经关闭的 channel中写入数据，文件名  send_to_close.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go tool compile -S send_to_close.go &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;send_to_close.go:6&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;image-20210823233649497&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108240001413.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过反汇编和文本搜索，找到了关键信息 &lt;strong&gt;runtime.chansend1(SB)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;情况2：关闭一个是 nil 值的 channel，文件名  close_nil.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go tool compile -S close_nil.go &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;close_nil.go:6&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;image-20210823234414243&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108240001274.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;情况3：关闭一个已经是关闭状态的 channel，文件名  close_closed.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go tool compile -S close_closed.go &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;close_closed.go:6&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;image-20210823233943750&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108240000241.png&#34;&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——语法分析实现</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day9-parsing_implementation/day9-parsing_implementation/</link>
      <pubDate>Sun, 22 Aug 2021 08:34:33 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day9-parsing_implementation/day9-parsing_implementation/</guid>
      
      <description>&lt;p&gt;之前的文章提到：Go 程序编译和链接涉及到工具 go tool compile 、go tool objdump 和 SSA func  build 将源代码转化成静态单赋值形式的中间代码。这些工具都可以直接上手玩一玩，即便对编译原理的理论不熟悉，在实践后还是会逐步明白的，Go 的工程化在这方面做得挺不错。今天来讲一讲“GO 语言语法分析的具体实现”&lt;/p&gt;
&lt;h1 id=&#34;调试工具回顾&#34;&gt;调试工具回顾&lt;/h1&gt;
&lt;p&gt;通过命令 readelf  -h 可以查看 ELF 可执行文件的头信息，发现调试入口的十六进制地址码，然后用 dlv 来调试 Go 程序。&lt;/p&gt;
&lt;p&gt;在 dlv 中，打断点有三种常用方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;b * 地址&lt;/li&gt;
&lt;li&gt;b 函数名&lt;/li&gt;
&lt;li&gt;b 文件名:行数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;指令 c 是从一个断点跳到另一个断点。如果打多个断点，那么可以做连续代码的跳转。&lt;/p&gt;
&lt;p&gt;指令 si 是单步调试，调试汇编时常用于使用 si 到 jmp 目标位置，即一步步跳转。&lt;/p&gt;
&lt;p&gt;我们用工具 go tool objdump 来做反汇编，而它输出的是 plan9 形式的汇编。其实在 dlv 中内置了反汇编工具，disass，不过它输出的是另一种形式的汇编。这里，我们可以掌握多种调试工具，平时就用自己擅长点的，而遇到了没弄明白的，也许另一个工具换来使用有不一样的效果。&lt;/p&gt;
&lt;p&gt;之前我们都是遇到问题搜资料，我想系统学习 dlv 怎么办呢？就像上期文章讲到的，还是去看官方文档：https://github.com/go-delve/delve/tree/master/Documentation/cli&lt;/p&gt;
&lt;p&gt;简单浏览一下官方文档可以发现，官方也在逐步添加新的功能。比如说，现在有一个地址，我可以直接用 dlv 中的 x 指令查看一段连续内存里存储的值，这个有点像 gdb 中的 x（另一个调试工具，用于查看内存地址的值）。这个指令在 runtime 中有些开头是 len，然后跟着 unsafe pointer 之类的，我能看到 unsafe pointer ，但它后面的结构直接调试可能看不到，这时候用到 x 指令就可以看到它后面内存里存储的是什么值了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——反编译</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day8-disassembly/day8-disassembly/</link>
      <pubDate>Sat, 21 Aug 2021 15:25:05 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day8-disassembly/day8-disassembly/</guid>
      
      <description>&lt;p&gt;Go 语言常用的两个查看汇编代码的工具是 &lt;strong&gt;go tool compile 和 go tool objdump&lt;/strong&gt;。上期文章说到通过 go tool compile -S 可以查看实现相同功能，两个不同的代码在性能上有什么区别，可从反编译出的汇编代码看出，二者的性能一样。今天再来聊一聊另外一个工具的使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在解决这种类似问题之前，我们其实可以&lt;strong&gt;查阅官方的资料 spec&lt;/strong&gt;，国外源地址：https://golang.org/ref/spec ，国内看这个：https://golang.google.cn/ref/spec&lt;/p&gt;
&lt;p&gt;这个 spec 讲述了 Go 语言内部的语法可以怎么用。在 spec 中出现的东西，也就是官方认为是正确的东西。而如果一个用法没有在 spec 中提到，那么我们就没有办法去依赖输出结论。&lt;/p&gt;
&lt;p&gt;举个例子，我们用到一个函数，这个函数用到了指针和 Error，如果这个返回的 Error 是非空的时候，我就不能依赖它的指针返回值。我们要依赖这个值，就需要 Error 是空。这种情况就是&lt;strong&gt;语言的确定性&lt;/strong&gt;，如果我们依赖了有 Error 的结果，那么就是非确定性的。这个非确定性，我们会经常看到一个名词叫做 &lt;strong&gt;Undefined Behavior&lt;/strong&gt;。我们初学 Go 语言，或者习惯于写动态语言，如 Python 的同学，会非常依赖这种写代码习惯，这其实是非常危险的。它可能会给我们带来隐藏的线上 Bug，很多时候都是难发现的，特别是在做语言 SDK 升级的时候，可能会导致比较严重的问题。&lt;/p&gt;
&lt;p&gt;所以我们要去查询 Go 语言内部的函数或者结构的用法的话，一定要去看官方的资料。不要去看网上的博客来作为自己的结论，因为别人写的不一定对，尤其是当我们使用了错误的博客内容来操作，会给业务带来更多麻烦。&lt;/p&gt;
&lt;p&gt;OK，打开 spec 网址，我们来看看，哥们，你这瓜多少钱一斤？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20210821223659673&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108212337904.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;spec 告诉我们，make 可以用在三种结构上的：slice，map，channel。也就说明，我们要研究 make 的实现，就去看这三种结构上执行 make 具体会执行哪个函数就好。&lt;/p&gt;
&lt;p&gt;我们来实现这段代码，文件名为 make.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// make slice
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 空间开的比较大，是为了让这个 slice 分配到堆上。空间小的话会默认分配到栈上，而栈上的 slice 和堆上的 slice 底层实现会不一样。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sl&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// make channel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// make map
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; go build make.go &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; go tool objdump ./make &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep -E &lt;span class=&#34;s2&#34;&gt;&amp;#34;make.go:6|make.go:10|make.go:14&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;命令说明，这里 go build make.go 是编译我们的 Go 程序代码，生成 ELF 可执行文件 make。然后用管道符 | 接住这个 ELF 文件，并用到反编译工具 go tool objdump 来反编译可执行文件 make。然后用管道符 | 接住结果，并用文本搜索工具 grep -E 指令来分割多个 pattern，以实现 OR 操作。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——编译与反编译</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day7-assembly/day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day7-assembly/day7-assembly/</guid>
      
      <description>&lt;p&gt;Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而&lt;strong&gt;最重要的就是进行虚拟地址重定位（Relocation）&lt;/strong&gt;。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。&lt;/p&gt;
&lt;p&gt;重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Quote&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20210819234132142&#34; src=&#34;c:\\Users\\Xfavor\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210819234132142.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;编译与反编译工具&#34;&gt;编译与反编译工具&lt;/h1&gt;
&lt;p&gt;我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go tool
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;img&#34; src=&#34;c:\\Users\\Xfavor\\AppData\\Local\\YNote\\data\\weixinobU7VjplR8GhsqZn6qPSNHGlLvOg\\bf1978b1b2864b888597f55ca77551b3\\clipboard.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再让我们看看这两句指令在具体场合下都是什么意思：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;go tool compile -S main.go  # 反编译代码为汇编代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）&lt;/p&gt;
&lt;p&gt;go tool objdump [-s symregexp] 二进制 # Objdump 打印二进制文件中所有文本符号（代码）的反汇编。如果存在 -s 选项，objdump 只会反汇编名称与正则表达式匹配的符号。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day6-parse/day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day6-parse/day6-parse/</guid>
      
      <description>&lt;p&gt;上回我们说到 &lt;strong&gt;8 个常见 Go 业务场景&lt;/strong&gt;，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础”&lt;/p&gt;
&lt;h1 id=&#34;回顾&#34;&gt;回顾&lt;/h1&gt;
&lt;p&gt;Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，我们可以通过这句代码，编译一段简单的 “Hello World！” 程序看到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go build -x hello.go
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;编译原理基础&#34;&gt;编译原理基础&lt;/h1&gt;
&lt;p&gt;我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;未命名文件&#34; src=&#34;https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108222319385.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20210815232014055&#34; src=&#34;c:\\Users\\Xfavor\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210815232014055.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法分析&lt;/strong&gt;（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象语法树&lt;/strong&gt;（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。&lt;/p&gt;
&lt;p&gt;这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20210815233646288&#34; src=&#34;c:\\Users\\Xfavor\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210815233646288.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语义分析&lt;/strong&gt;（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &amp;ldquo;abc&amp;rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day5-problem/day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day5-problem/day5-problem/</guid>
      
      <description>&lt;p&gt;上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调试啊。关于业务，写代码当然可以，而当我们面临性能问题时，就需要涉及算法与数据结构。糟糕，你一说到算法我就心虚。如果你算法基础薄一点，没关系，东方不亮西方亮，算法走不通，我们走查看修改底层代码做起，仅需要细心和逻辑推理就能解决部分问题。因此，今天的主题是“探究 Go 语法背后的秘密”。&lt;/p&gt;
&lt;h1 id=&#34;常见业务场景&#34;&gt;常见业务场景&lt;/h1&gt;
&lt;p&gt;你说写业务不用关心底层，OK，那我们今天先讲原理，直接上业务场景。&lt;/p&gt;
&lt;p&gt;场景1，这两段代码运行速度怎样？第一个比第二个快？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 代码1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;person&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;111&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 对比代码2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;person&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;person&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;111&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;场景2，类型转换的原理是怎样的？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？&lt;/p&gt;
&lt;p&gt;场景4，有一个中台服务，划分了许多用户等级，具体规则如下：（以下场景都没遇到过，不过可以来做分析）&lt;/p&gt;
&lt;p&gt;初级会员，发帖数 &amp;gt; 10&lt;/p&gt;
&lt;p&gt;中级会员，充值 &amp;gt; 1000 RMB&lt;/p&gt;
&lt;p&gt;高级会员，发帖数 &amp;gt; 100 ，充值 &amp;gt; 10000 RMB&lt;/p&gt;
&lt;p&gt;如果其中项目数量 = 几百，那么每个项目都应该有自己的会员规则吗？也就是说，我们需要单独定制这么几百个代码吗？&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——调试2</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day4-run/day4-run/</link>
      <pubDate>Wed, 11 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day4-run/day4-run/</guid>
      
      <description>&lt;p&gt;上回我们说到，利用调试工具 readelf 读取我们在 Linux 上编译的可执行文件 hello，并且找到了查看 Go 底层的入口 entry point address，今天我们尝试踏进底层调试的大门，看一看我们平时所说的底层，是否真的很困难，今天的主题是“初探Go底层”&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&#34;实验环境与回顾&#34;&gt;实验环境与回顾&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：CentOS 7&lt;/p&gt;
&lt;p&gt;Go：1.14.12&lt;/p&gt;
&lt;p&gt;调试工具：readelf、dlv&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们同样运行曹大提供的实验环境，并且挂载映射到本地项目，然后进入到这个容器环境中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 挂载目录，文件也可以生成&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 进入项目目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /project/work/ch01
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 查看文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ls
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;image-20210811230644860&#34; src=&#34;c:\\Users\\Xfavor\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210811230644860.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里的绿色 hello，就是我们 Go 语言编译后产生的 ELF 格式可执行程序（ELF 不知道是什么，可回顾上期文章）&lt;/p&gt;
&lt;p&gt;我们一般通过工具 readelf 来找到进入可执行程序底层的入口 entry point address，通过以下命令来实现，这里的 -h 表示去读取 header&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-h &amp;ndash;file-header	Display the ELF file header&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;readelf -h hello
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;image-20210809235305494&#34; src=&#34;c:\\Users\\Xfavor\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210809235305494.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;开始底层调试&#34;&gt;开始底层调试&lt;/h1&gt;
&lt;p&gt;当找我们通过 readelf 找到了调试入口的十六进制地址码，我们还需要用另一个工具 dlv 才能来调试 Golang 程序。再次之前，来简单说明一下什么是 readelf、什么是 dlv。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day3-run/day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day3-run/day3-run/</guid>
      
      <description>&lt;p&gt;今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我一步步走肯定都能理解。&lt;/p&gt;
&lt;p&gt;既然要进行代码实践操作，首先要考虑的就是Go语言编译器（也就是Go）、Go 编程环境以及 Go 代码的调试环境，这里我们需要用到的版本：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：CentOS7 或其他 Linux 环境&lt;/p&gt;
&lt;p&gt;Go：1.14.12&lt;/p&gt;
&lt;p&gt;Go 调试工具：readelf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是不是有点复杂？如果版本和我的不一样，那么实验结果可能不一样。如果版本比较低，有的工具需要自己去找旧版本的去匹配安装。那有没有什么办法可以简化这些实验环境的搭建呢？用上容器技术——Docker。简单说，当你用 Docker 的时候，就像在自己的电脑中装上了我所说版本的实验环境，里面包括了上面所说的所有东西。你可以用我给出的定制环境（我们称之为镜像），也可以用其他人给出的定制环境，并且可以做到无缝切换。就这么说，在你的 windows 上可以运行 CentOS、Ubuntu，甚至还能在 windows 上运行一个微型 windows，是不是很神奇？OK，我们说回今天的实验，在开始之前希望你能去了解 Docker 是怎样操作的，这里推荐我非常喜爱的 B 站 UP 主“遇见狂神说”推出的 &lt;a href=&#34;https://www.bilibili.com/video/BV1og4y1q7M4?from=search&amp;seid=13499423805328211071&#34;&gt;Docker 教程&lt;/a&gt;。好，就当你已经会基本操作啦，跟我开始敲代码了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搭建实验环境&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -it xargin/go1.14.12-dev bash
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们运行了曹大（曹春晖）提供的实验环境，并且进入到这个容器环境中。但是存在一个问题，我们在这里面写的代码在这个容器销毁后就没有了，所以我们需要对容器做一个映射，在容器中写了文件，在我们本地也有一份记录。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 挂载目录，文件也可以生成&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;创建目录与文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在home目录下创建文件夹所有实验目录 work，创建第一个实验目录 ch。（这里的样式和大家不一样是因为 安装了 zsh ，你不一定也要按照，如果感兴趣，请自行搜索安装，当前配色主题是 ys）&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; src=&#34;c:\\Users\\Xfavor\\AppData\\Local\\YNote\\data\\weixinobU7VjplR8GhsqZn6qPSNHGlLvOg\\2a19397ad8e14472b1f4c9358d3a8ed7\\clipboard.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;实验环境准备完毕。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写一段简单代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们来打开一个叫做 hello.go 的文件，写一段我们最熟悉的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;vi hello.go
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// hello.go 文件中写入
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编译代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;生成可执行程序并查看：&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day2</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day2-scheduler/day2-scheduler/</link>
      <pubDate>Thu, 05 Aug 2021 14:45:19 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day2-scheduler/day2-scheduler/</guid>
      
      <description>&lt;p&gt;上回说到 &lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=Mzg3MjYzMzQzMQ==&amp;mid=2247483687&amp;idx=1&amp;sn=a357de9b46d3dbf466b9f52f6e2f413a&amp;scene=21#wechat_redirect&#34;&gt;Go 的调度流程本质上是⼀个⽣产-消费流程&lt;/a&gt;，今天来讲一讲“调度组件与调度循环”，再来回顾一下两个生动的动画 goroutine 的⽣产端, goroutine 的消费端。&lt;/p&gt;
&lt;p&gt;当 goroutine 处于生产端时，M 执行调度循环时，必须与一个 P 绑定。并且我们常说的 Work stealing 就是说的 runqsteal -&amp;gt; runqgrab 这个流程。&lt;/p&gt;
&lt;p&gt;当 goroutine 处于消费端时，执行的是一个循环：runtime.schedule → execute → runtime.gogo → runtime.goexit → runtime.schedule（回到原点），并且最终 P.schedtick = 0。&lt;/p&gt;
&lt;p&gt;初学 scheduler 对于以上的流程感受是比较浅的，再来看看这些符号所代表的含义，就能更好地理解了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;G: goroutine，计算任务。由需要执行的代码和其上下文组成。（上下文包括：当前代码位置，栈顶、栈底地址，状态等）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;M: machine，系统线程，执行实体，想要在 CPU 上来执行代码，必须有线程，与 C 语言中的线程相同，通过系统调用 clone 来创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;P: processor，虚拟处理器，M 必须获得 P 才能执行代码，否则必须陷入休眠（后台监控线程除外），你也可以将其理解为一种 token，有了这个 token，才有在物理 CPU 核心上执行的权利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面所说的循环调度流程，都是在正常情况下运作的。而实际业务中我们往往还会遇到其他情况——阻塞。如果程序中有阻塞，那么线程不就全部被堵上，程序就卡住了么？&lt;/p&gt;
&lt;p&gt;让我们来看看以下几种情况，在线程发生阻塞的时候，是否会无限地创新线程？（并不会）&lt;/p&gt;
&lt;p&gt;案例1：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// channel send:
var ch = make(chan int)
ch &amp;lt;- 1

// channel recv:
var ch = make(chan int)
&amp;lt;- ch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;案例2：&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>https://JupiterXue.github.io/posts/go-to-top/day1-scheduler/day1-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://JupiterXue.github.io/posts/go-to-top/day1-scheduler/day1-scheduler/</guid>
      
      <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;golang-四座大山&#34;&gt;Golang 四座大山&lt;/h2&gt;
&lt;p&gt;作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环&lt;/p&gt;
&lt;p&gt;Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项&lt;/p&gt;
&lt;p&gt;Memory	：当代码需要内存时，负责内存分配工作&lt;/p&gt;
&lt;p&gt;Garbage	：当内存不再需要时，负责回收内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。&lt;/p&gt;
&lt;h2 id=&#34;调度器的发展历史&#34;&gt;调度器的发展历史&lt;/h2&gt;
&lt;p&gt;如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：&lt;/p&gt;
&lt;h2 id=&#34;什么是调度34&#34;&gt;什么是调度&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;,&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;p&gt;举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。
Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。
一个简短的例子
每当我们写下这样形式的代码，到底发生了什么事情呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello world in goroutine!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。
Go调度流程的本质
也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。
这里有两个动画便于你理解：&lt;/p&gt;
&lt;p&gt;Goroutine 生产过程&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;,&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Goroutine 消费过程&lt;/p&gt;
&lt;p&gt;想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。
（未完待续）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关链接&lt;/strong&gt;&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
