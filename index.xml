<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>木夜星空的个人博客</title>
    <link>https://jupiterxue.github.i/</link>
    <description>Recent content on 木夜星空的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>JupiterXue</copyright>
    <lastBuildDate>Sun, 22 Aug 2021 22:51:00 +0800</lastBuildDate><atom:link href="https://jupiterxue.github.i/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 翻山越岭——解释器</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day10-parser/</link>
      <pubDate>Sun, 22 Aug 2021 22:51:00 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day10-parser/</guid>
      <description>上期文章遗留了一个问题“三个 panic 在 runtime 代码的具体哪个位置输出”，如果通过汇编调试工具找出来。今天来动手实践，并且尝试解决另一个业务问题。
问题回顾  分别有三种情况的 panic：
 往已经关闭的 channel中写入数据 关闭一个是 nil 值的 channel 关闭一个已经是关闭状态的 channel   要找出它们在 runtime 代码中具体位置，首先我们先写几个小型代码，来完全模拟这几种情况。
情况1：往已经关闭的 channel中写入数据，文件名 send_to_close.go
1package main 2 3func main() { 4 var ch chan int 5 close(ch) 6 ch &amp;lt;- 1 7} 1go tool compile -S send_to_close.go | grep &amp;#34;send_to_close.go:6&amp;#34; 通过反汇编和文本搜索，找到了关键信息 runtime.chansend1(SB)
情况2：关闭一个是 nil 值的 channel，文件名 close_nil.go
1package main 2 3func main() { 4 var ch chan int 5 ch = nil 6 close(ch) 7} 1go tool compile -S close_nil.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——语法分析实现</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day9-parsing_implementation/</link>
      <pubDate>Sun, 22 Aug 2021 08:34:33 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day9-parsing_implementation/</guid>
      <description>之前的文章提到：Go 程序编译和链接涉及到工具 go tool compile 、go tool objdump 和 SSA func build 将源代码转化成静态单赋值形式的中间代码。这些工具都可以直接上手玩一玩，即便对编译原理的理论不熟悉，在实践后还是会逐步明白的，Go 的工程化在这方面做得挺不错。今天来讲一讲“GO 语言语法分析的具体实现”
调试工具回顾 通过命令 readelf -h 可以查看 ELF 可执行文件的头信息，发现调试入口的十六进制地址码，然后用 dlv 来调试 Go 程序。
在 dlv 中，打断点有三种常用方式：
 b * 地址 b 函数名 b 文件名:行数  指令 c 是从一个断点跳到另一个断点。如果打多个断点，那么可以做连续代码的跳转。
指令 si 是单步调试，调试汇编时常用于使用 si 到 jmp 目标位置，即一步步跳转。
我们用工具 go tool objdump 来做反汇编，而它输出的是 plan9 形式的汇编。其实在 dlv 中内置了反汇编工具，disass，不过它输出的是另一种形式的汇编。这里，我们可以掌握多种调试工具，平时就用自己擅长点的，而遇到了没弄明白的，也许另一个工具换来使用有不一样的效果。
之前我们都是遇到问题搜资料，我想系统学习 dlv 怎么办呢？就像上期文章讲到的，还是去看官方文档：https://github.com/go-delve/delve/tree/master/Documentation/cli
简单浏览一下官方文档可以发现，官方也在逐步添加新的功能。比如说，现在有一个地址，我可以直接用 dlv 中的 x 指令查看一段连续内存里存储的值，这个有点像 gdb 中的 x（另一个调试工具，用于查看内存地址的值）。这个指令在 runtime 中有些开头是 len，然后跟着 unsafe pointer 之类的，我能看到 unsafe pointer ，但它后面的结构直接调试可能看不到，这时候用到 x 指令就可以看到它后面内存里存储的是什么值了。</description>
    </item>
    
    <item>
      <title>2021 08 21 Go Top Day8 Disassembly</title>
      <link>https://jupiterxue.github.i/go-to-top/2021-08-21-go-top-day8-disassembly/</link>
      <pubDate>Sat, 21 Aug 2021 15:25:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/2021-08-21-go-top-day8-disassembly/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go 翻山越岭——反编译2</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day8-disassembly/</link>
      <pubDate>Sat, 21 Aug 2021 15:25:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day8-disassembly/</guid>
      <description>Go 语言常用的两个查看汇编代码的工具是 go tool compile 和 go tool objdump。上期文章说到通过 go tool compile -S 可以查看实现相同功能，两个不同的代码在性能上有什么区别，可从反编译出的汇编代码看出，二者的性能一样。今天再来聊一聊另外一个工具的使用。
 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？
 在解决这种类似问题之前，我们其实可以查阅官方的资料 spec，国外源地址：https://golang.org/ref/spec ，国内看这个：https://golang.google.cn/ref/spec
这个 spec 讲述了 Go 语言内部的语法可以怎么用。在 spec 中出现的东西，也就是官方认为是正确的东西。而如果一个用法没有在 spec 中提到，那么我们就没有办法去依赖输出结论。
举个例子，我们用到一个函数，这个函数用到了指针和 Error，如果这个返回的 Error 是非空的时候，我就不能依赖它的指针返回值。我们要依赖这个值，就需要 Error 是空。这种情况就是语言的确定性，如果我们依赖了有 Error 的结果，那么就是非确定性的。这个非确定性，我们会经常看到一个名词叫做 Undefined Behavior。我们初学 Go 语言，或者习惯于写动态语言，如 Python 的同学，会非常依赖这种写代码习惯，这其实是非常危险的。它可能会给我们带来隐藏的线上 Bug，很多时候都是难发现的，特别是在做语言 SDK 升级的时候，可能会导致比较严重的问题。
所以我们要去查询 Go 语言内部的函数或者结构的用法的话，一定要去看官方的资料。不要去看网上的博客来作为自己的结论，因为别人写的不一定对，尤其是当我们使用了错误的博客内容来操作，会给业务带来更多麻烦。
OK，打开 spec 网址，我们来看看，哥们，你这瓜多少钱一斤？
spec 告诉我们，make 可以用在三种结构上的：slice，map，channel。也就说明，我们要研究 make 的实现，就去看这三种结构上执行 make 具体会执行哪个函数就好。
我们来实现这段代码，文件名为 make.go
1package main 2 3func main() { 4 // make slice 5 // 空间开的比较大，是为了让这个 slice 分配到堆上。空间小的话会默认分配到栈上，而栈上的 slice 和堆上的 slice 底层实现会不一样。 6 var sl = make([]int, 100000) 7 println(sl) 8 9 // make channel 10 var ch = make(chan int, 5) 11 println(ch) 12 13 // make map 14 var m = make(map[int]int, 22) 15 println(m) 16} 1&amp;gt;&amp;gt;&amp;gt; go build make.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译与反编译</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day7-assembly/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。
重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。
具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）
编译与反编译工具 我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。
1go tool 这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：
 几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。
 再让我们看看这两句指令在具体场合下都是什么意思：
 go tool compile -S main.go # 反编译代码为汇编代码。
  go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）
go tool objdump [-s symregexp] 二进制 # Objdump 打印二进制文件中所有文本符号（代码）的反汇编。如果存在 -s 选项，objdump 只会反汇编名称与正则表达式匹配的符号。</description>
    </item>
    
    <item>
      <title>编译与反编译</title>
      <link>https://jupiterxue.github.i/go-to-top/2021-08-19-go-top-day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/2021-08-19-go-top-day7-assembly/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。
重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。
具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）
编译与反编译工具 我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。
1go tool 这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：
 几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。
 再让我们看看这两句指令在具体场合下都是什么意思：
 go tool compile -S main.go # 反编译代码为汇编代码。
  go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）
go tool objdump [-s symregexp] 二进制 # Objdump 打印二进制文件中所有文本符号（代码）的反汇编。如果存在 -s 选项，objdump 只会反汇编名称与正则表达式匹配的符号。</description>
    </item>
    
    <item>
      <title>编译与反编译</title>
      <link>https://jupiterxue.github.i/posts/2021-08-19-go-top-day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-19-go-top-day7-assembly/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。
重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。
具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）
编译与反编译工具 我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。
1go tool 这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：
 几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。
 再让我们看看这两句指令在具体场合下都是什么意思：
 go tool compile -S main.go # 反编译代码为汇编代码。
  go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）
go tool objdump [-s symregexp] 二进制 # Objdump 打印二进制文件中所有文本符号（代码）的反汇编。如果存在 -s 选项，objdump 只会反汇编名称与正则表达式匹配的符号。</description>
    </item>
    
    <item>
      <title>性感、美食和学术？</title>
      <link>https://jupiterxue.github.i/posts/2021-08-18-sex-research/</link>
      <pubDate>Wed, 18 Aug 2021 22:01:22 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-18-sex-research/</guid>
      <description>当我们的开始看论文、接触到学术研究后会形成一个感知：科研工作往往都是在进行复杂的实验、写出带有各种样式的图表和复杂的数学公式，最终生成的长篇大论。但今天我彻底颠覆了这一刻板印象——做科研也是“性感”的。？？？对，你没有看错，今天想来讨论中国知网推出的《研究生科研素养提升》系列学术讲座的其中一期。
介绍 这期讲座是在 2021-08-18 15:30~17:10 开展的。主讲人是北京交通大学教授、博导师，华国伟。他的主讲题目是《做最“性感”的研究》，一看到题目，是不是就觉得有点意思？
华老师开篇讲到，“性感”这个词常用于表达吸引异性的场合，而他的讲座并没有这个裸露的含义，而是隐喻：我们做学术也可以吸引其他做学术的人。同时，华老师还提到了一个小故事：
 有本书，名叫 《How to change your wife in 30 days》，一个星期之內售出200万本。直到作者发现，书名拼写错误，正确的应该是： 《How to change your life in 30 days》。改正后整整一个星期，只卖了3本。
 华老师希望我们来听他的讲座不是因为他的主题名字吸引了我们，而是真正对科研感兴趣，对科研是“性感”的、如何做好科研这个话题感兴趣来听的。
华老师为了做这场讲座看了许多论文和书籍，也推荐我们去看两本书：《靠近点 科学史最性感的世界观》、《性感的公司》
然后明确了这期讲座的三大言简意赅的提纲，向我们提出了三个问题：
开始正经 好，华老师开始正经地讲授科研了，大家严肃一点！
（缓冲区）
（缓冲区）
（缓冲区）
同学们，我们做学术是要有预期的，最开始我们是&amp;hellip;
不敢相信，这是科研讲座？？
哎呀呀，同学们，你们一定要记住，科研的三条秘籍：勤奋！勤奋！勤奋！连最聪明的人都在用着这个最笨的办法，但这还不够，做科研还要 欲望！冲动！血脉喷张！
这。。。我们做科研要像毛！血！旺！
小插曲 由于其他同学听得太用心，已经开始产生了幻觉，上演了一场买瓜好戏？
知网官方：同学们不要讨论其他与学习无关的东西
那么你的问题来了，买大西瓜还是小西瓜合算呢？
（两块钱一斤！哈哈哈，作为理科生的我，羞耻地去搜了搜答案）
做有价值的工作 华老师对我们科研宝贝们的论文比喻简直了，一个字，绝！
看论文我们要看看国外是怎么做的，这又会遇到一个问题：
（这么一堂科研学术讲座，活生生地做成了一趟美食之旅，让公屏后面的同学们都馋哭了吧）
写论文的要点，老师比喻地真是无懈可击。
我们看到数字对比能更加敏感，看到图片能够直观感受，听到老师的段子会忍不住哈哈大笑。
引用的故事在老师讲起来真是太搞笑了吧。
以上都是在听讲座过程中随手截取的图。
最后，华老师以优雅的姿态结束了本次讲座，惊艳了我们所有人：
（华老师结语祝福，希望你能看懂）
为什么这堂讲座口碑这么好 华老师在课间答疑说道：这个 PPT 其实在 2008、2009 年就有了，但新书一直都没有憋出来。也想出一个课程，希望能够对大家感兴趣、有困难的科研部分提供一些帮助。并且在这次讲座之前已经有300页的 PPT 内容，近好几个小时的演讲量。而为了这次讲座，将 PPT 极力压缩到了 80 页左右，为期 一个半小时讲座时间内完成。
后来，我思考了为什么华老师的讲座口碑这么好？华老师在讲授期间金句频繁，绘声绘色、有段子还有图片。背后是老师长达十多年的积累、对生活的热爱、对时尚潮流的关注以及对科研最崇高地尊敬。虽然老师有的比喻不是很恰当，略有点直白和低俗，但可以发现老师将他科研毕生所学的抽象概念都融汇在了我们生活点点滴滴的真实案例中。我们缺少阅历，但并不妨碍我们能够像老师学习，学习换位思考，尽可能地去设想另一个学者、编辑、作家、医生在想什么、做什么。并且我们能够在华老师这么一堂声色俱佳的讲座上重新捡回做科研那份初心，始终不忘如何探究、如何概括和总结。
最后，讲座不用我强烈推荐了吧，看图就好了，记得关注老师的微博“我是华国伟”，关注老师出书和课程的最新动态。放一下讲座 《华国伟 - 做最“性感”的研究》源地址：https://k.</description>
    </item>
    
    <item>
      <title>写技术文章的要点</title>
      <link>https://jupiterxue.github.i/posts/2021-08-16-tech_write/</link>
      <pubDate>Mon, 16 Aug 2021 22:52:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-16-tech_write/</guid>
      <description>磨刀不误砍柴工，程序员在写代码、写文章之余还是值得去了解重构代码、测试代码、如何写文章等辅助性的技能，虽然有时有点务虚，但从长远看却是实打实地有用。今天讨论的主题是“写技术文章有哪些要点”。
首先，我们需要对技术文章进行一个分类：
 知识总结。  比如你在公司内想要做个什么系统，你不知道，就去 Google 用英文搜一下。把第一页都消化吸收了就能出一篇总结性文章了（也就是老板常说的去调研一下）。业务问题 → Google 搜索 → 消化内容 → 总结 最近对流式计算感兴趣，我也可以 Google 去搜 &amp;ldquo;stream processing&amp;rdquo;，不过搜出来的知识点都比较零散。而我想要更完整的知识体系，那么我就去亚马逊搜书 &amp;ldquo;stream processing&amp;rdquo;。大致了解到有哪些关键词后，我们就去更加专业的渠道去阅读它——learning.oreily.com/library，然后就可以输出笔记了。 流式计算感兴趣 → 读书 → 读书笔记。   项目总结。  公司项目 → 完成之后 → 调研更高级项目 → 复盘总结。 公司问题提炼。业务脱敏，只把关键技术部分整理出来 → 输出。   教程指引。翻译官方文档，补充一些在使用时候会遇到的坑。  Yutube 上很好的国外的视频分享 → 怕忘记、感兴趣 → 结合自己的理解记下来。 内容翻译。medium，lobster，acm 里不错的新论文，acm queue，macm 杂志上的文章，都是不错的翻译目标。    小插曲：注册 ACM 会员再用同样的账号去注册O`reily，能够免费阅读里面大部分的书。价格为 25 刀，可以搞个双币信用卡呀，招行就行，现在学生账号可能不行了，不过用绑了 paypal 的卡就行好像。
 如果对电子书不排斥的话，目前比较经济的选择是申请一个国内的 ACM 会员，并且用该会员去注册oreily 在线书店。一年大概 20 美元，可以及时地阅读到大部分出版社的技术出版物。因为现在出版社的网站大多还支持 early preview，所以你甚至可以在书籍还没有上市之前就预先学习内容，第一时间获取整个业界的一线情报，能够帮助你站在时代的潮头。——曹大</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day6-parse/</guid>
      <description>上回我们说到 8 个常见 Go 业务场景，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础”
回顾 Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，我们可以通过这句代码，编译一段简单的 “Hello World！” 程序看到：
1go build -x hello.go 编译原理基础 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 println(1 + 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var x int = &amp;#34;abc&amp;#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &amp;ldquo;abc&amp;rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>https://jupiterxue.github.i/posts/2021-08-15-go-top-day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-15-go-top-day6-parse/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接。看似简单，但其中蕴藏着极大的能量，尤其在面对不能一时半会就解决的业务场景中，稍微深挖编译与链接的过程就有奇效。今天我们就来聊聊 “Go 语言中编译原理的基础”。
上期文章提到了 8 个常见 Go 业务场景，虽说都是业务场景，但在代码性能、数据结构转换和系统设计中偏细颗粒度的实践中我们通常感到茫然和繁琐。这是因为在平时开发中，编译器会自动帮我们屏蔽掉代码编译的过程，我们只用关注最后的 ELF 可执行文件。那么我们就来看看，编译器会帮我们做些什么工作，进一步理解我们所写的程序发生了什么样的转化。
编译原理概述 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 println(1 + 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var x int = &amp;#34;abc&amp;#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &amp;ldquo;abc&amp;rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day5-problem/</guid>
      <description>上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调试啊。关于业务，写代码当然可以，而当我们面临性能问题时，就需要涉及算法与数据结构。糟糕，你一说到算法我就心虚。如果你算法基础薄一点，没关系，东方不亮西方亮，算法走不通，我们走查看修改底层代码做起，仅需要细心和逻辑推理就能解决部分问题。因此，今天的主题是“探究 Go 语法背后的秘密”。
常见业务场景 你说写业务不用关心底层，OK，那我们今天先讲原理，直接上业务场景。
场景1，这两段代码运行速度怎样？第一个比第二个快？
1// 代码1 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var a = &amp;amp;person{111} 10 fmt.Println(a) 11} 1// 对比代码2 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var b = person {111} 10 var a = &amp;amp;b 11 fmt.Println(a) 12} 场景2，类型转换的原理是怎样的？
1package main 2 3func main() { 4 var a = &amp;#34;hello&amp;#34; 5 var b = []byte(a) 6 println(b) 7} 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>https://jupiterxue.github.i/posts/2021-08-14-go-top-day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-14-go-top-day5-problem/</guid>
      <description>上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调试啊。关于业务，写代码当然可以，而当我们面临性能问题时，就需要涉及算法与数据结构。糟糕，你一说到算法我就心虚。如果你算法基础薄一点，没关系，东方不亮西方亮，算法走不通，我们走查看修改底层代码做起，仅需要细心和逻辑推理就能解决部分问题。因此，今天的主题是“探究 Go 语法背后的秘密”。
常见业务场景 你说写业务不用关心底层，OK，那我们今天先讲原理，直接上业务场景。
场景1，这两段代码运行速度怎样？第一个比第二个快？
1// 代码1 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var a = &amp;amp;person{111} 10 fmt.Println(a) 11} 1// 对比代码2 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var b = person {111} 10 var a = &amp;amp;b 11 fmt.Println(a) 12} 场景2，类型转换的原理是怎样的？
1package main 2 3func main() { 4 var a = &amp;#34;hello&amp;#34; 5 var b = []byte(a) 6 println(b) 7} 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？</description>
    </item>
    
    <item>
      <title>七夕荐电影《当男人恋爱时》</title>
      <link>https://jupiterxue.github.i/posts/2021-08-13-when-man-love/</link>
      <pubDate>Fri, 13 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-13-when-man-love/</guid>
      <description>明天就是七夕节了，本来今天应该更技术文章，暂时放一放，让美好暂留一天，今天来聊一部爱情电影。
爱情并不完美，而爱情电影往往都是那么天真浪漫，这和现实生活产生了巨大的冲突和矛盾，即便如此，依就阻止不了我们对于美好爱情的向往和憧憬。《重庆森林》已经被我看过4、5遍，里面没有讲述重庆、也没有讲述森林，而当你想恋爱了、当你失恋了，这部电影就很贴近你的生活，就和你有关系了。即便是1994年的老电影，至今 2021 年仍然爱不释手。但今天要说的不是《重庆森林》，而是另一部听名字就有点意思的电影——《当男人恋爱时》。
发现 最初了解到这部电影的时候是无意间看到的一篇影评，2021年6月11日在中国大陆上映了电影《当男人恋爱时》[1]，这篇影评不仅讲述了电影中的情节，还将另外一部于2014年1月22日上映的同名电影的故事情节和剧照都晒了出来。真的是没有对比，就不会知道自己喜欢哪个。当我一看到这副剧照，我就知道，我喜欢老版本的电影！（左图）
感受（略有剧透警告） 这是一部出产于韩国出产的电影，我们都知道前些年，韩国在爱情无论是电影还是电视剧上都是比较俗套的，但这个俗套不是贬义，而是说韩国做的挺好，对于爱情剧情的理解以及形成了套路。虽然抱有一点，烂俗韩剧的心理去看电影，但看完之后真的让我忍不住想推荐，尤其是很难找到那么清新脱俗的痞子。
剧中饰演男主的黄政民，是个混混老大，但他看起来并没有我们刻板印象中的傲慢不羁或者凶神恶煞。而一如反常的是呆萌的形象，你能想象，兔子生气了冲撞你吗？哈哈。不过确实，黄政民大叔在剧中的代入感真的太强了，从收租要钱打架斗殴，到温文尔雅绘图签字，再到二人对视哭泣，每一幕的演技都细致入微。前部分塑造的粗犷暖男形象，和后半部分营造出的密集泪点效果都简直出神入化。就像一位评论者所说：“来为黄政民大叔写个影评 这片要是换个帅哥演，我真不一定看。 ”
剧情我就不介绍了，仅用几句电影中的话，来表达我在整个电影的直观的感受：
 喂！我都说爱你了，你什么感觉都没有吗？！
  哥，你倒是知道什么是爱情吗？最起码不是这样的，以后利息钱我会汇给你，不要再联系了！
  以前其实我差点结了婚的，但是我他妈的给搞砸了
  （花大钱给妹妹买了新的店外装饰）这是我妈给你的（钱），怕你没钱用，说要跟我爸保密。。这是我把给你的，还说要更我爸保密。。我爸我妈完全不沟通，这是个事啊。
  （一边吃着泡面一边和他爸爸交待身后事）因为她是您儿子这一生最爱的女人啊
 原本我以为爱情电影都是这样的狗血，剧情都会多少有煽情、有泪点。已经有心理防备的我，在感受到剧中男主女主面对面那份伤心时，也忍不住眼睛红了。我想，如果你是个泪点低的，那么这部电影真的可以算上，好好哭。
总之，这是一部很 man 、很直男、很浪漫、很悲催而又很美好的爱情电影，至今也让我回味无穷，所有的剧情可能都忘了，但还是忘不了看起来萌萌的男主说出的那句表白的话：“我爱你，妈的”。 哈哈，真是率真又可爱。
最后，可以去豆瓣点个在看，点评一下看过的电影或者看过什么书。如果你和我读过、看过的有相同，那可真是幸运，欢迎关注我的书评、影评：Jupiter 的个人主页-豆瓣
资料
[1] 台韓男人的浪漫大戰？《當男人戀愛時》與原版《不標準情人》有何不同？穆光光, marieclaire, 2021-05-03
[2] 当男人恋爱时, 豆瓣
[3] 如何看待黄政民在电影《当男人恋爱时》中的表演？知乎
[4] 影迷评《当男人恋爱时》：演技精湛 催泪感人, 新浪娱乐, 2021-06-08</description>
    </item>
    
    <item>
      <title>论—如何看论文与写技术文章</title>
      <link>https://jupiterxue.github.i/posts/2021-08-12-write/</link>
      <pubDate>Thu, 12 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-12-write/</guid>
      <description>最近成长会的小伙伴推荐了一个系列讲座“2021年“研究生科研素养提升”系列公益讲座”，看到这个题目，不禁联想起自己大学最初的梦想，如果，如果没有当初也便没有现在的自己，就不多说了。翻了翻里面有哪些主题的课程讲座，发现最让我感兴趣的是徐铭梓老师推出的“中国知网辅助论文读写效率提升”，今天讲的主题就是“论—如何看论文与写技术文章”。
这里又不得不提及，在我们成长会中，每年 Scalers 老师都会亲自带队，在为期几个月的时间内带我们进行专题性阅读。什么是专题阅读？比如这期的主题是“经济学”，我们会从曼昆的《经济学原理》的微观与宏观开始看，再到《经济思想史》和《解读中国经济》。像《经济学原理》都是经贸领域同学的本科专业教材，都是大部头，不过我们也是按照每天一章、两章的阅读量在阅读。光阅读还不够，我们每天还会回答 S 老师布置的问题，当天看书当天答题，我们社群有个全新的文化——日毕。我参加过几期这样的专题读书活动，也深刻感受到 S 老师出题之深刻，就比如：调研和概述中国近20年的财政情况、股票市场是否存在稳赚不赔的方法、2018年中美贸易摩擦到现在的变化情况，以及搜集近五年政府工作报告分析财政与货币在政策上的变化等。这些问题无一不是好几篇研究生甚至博士生所研究的问题，因此我们在回答这些问题的时候会经常性地去关注学术论文是怎样看待这些问题的。
既然要看学术论文，有没有什么常识或者说常用的套路呢？回到最开始提及的那位老师，徐铭梓。我好奇地拿着她的名字在谷歌上搜了一下，没想到直接找到了她在去年4月份在知网上发表的一篇免费教学PPT——《论文阅读与写作入门》，里面详细地讲述了作为一个科研人员，需要保持什么样的做学术和看论文的正确理念，分类地讲述了不同段位的研究者应该从哪里、看什么、怎样看论文，详尽地阐述了论文的基本阅读方法。
然后徐老师又说到了笔记与文献的摘录，她引用了梁启超先生的一句话：
 读书莫要于笔记，朱子谓当如老吏断狱一字不放过， 学者凡读书，必每句深求其故，以自出议论为主，久 之触发自多，见地自进，始能贯串群书，自成条理。 经学、子学尤要， 无笔记则必不经心，不经心则虽读 犹不读而已。
什么方法呢？极笨极麻烦的， 抄录或笔记 ——梁启超《读书分月课程·学要十五则》
 这里让我联想起了，我们程序员应该怎样来写科技文章。最近在 Go 技术群里，在热烈地讨论一个问题“作为程序员，自己知道点东西，但写着就感觉别扭，于是就写不下去。并且大多时候都像是知识储备不够，每次都感觉在抄袭别人的”，大家都表示同感，毕竟东西就是那些。还有有些同学自我安慰道，就觉得是把别人的文章用自己的话说一遍，把别人画好的图自己再画一遍。
在我们群里的技术巨佬，他们是怎么说的：
  把别人文章中的图自己画一遍，不算盗图，并且自己画一遍挺好的。
  程序员写文章整段整段贴代码不合适，贴出来关键核心代码就可以了，然后重点的是要有一些提纲，例如你分析过程，总结这些。
  总的来说，一篇优秀的技术文需要有：
 取好标题，醒目突出中心
图文并茂，适当配图说明
篇幅适宜，不宜过短也避免冗长
格式统一，基本排版规则需要遵守
细节处理，错别字标点处理正确。
   是的，就像我所喜爱的作者王垠所说“每次仇恨一个东西，你就失去了向它学习的机会。”，我们普通人没有经过专门的写作训练，面对一下写几千字是比较困难的，更难得说输出技术文章。在我看来，学习技术都是从模仿开始，不要介意抄袭别人的，不要介意别人已经做过了，要亲自动手，事必躬亲。你要清楚地知道，那是别人的东西，不是你自己的，就像那是装在别人兜兜里的钱，不是你自己能使用的。
关于《论文阅读与写作入门》我就不继续展开来讲了，如果你有兴趣，就去探索吧！好奇心，能够让你学会更多知识与技能！</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试2</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day4-run/</link>
      <pubDate>Wed, 11 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day4-run/</guid>
      <description>上回我们说到，利用调试工具 readelf 读取我们在 Linux 上编译的可执行文件 hello，并且找到了查看 Go 底层的入口 entry point address，今天我们尝试踏进底层调试的大门，看一看我们平时所说的底层，是否真的很困难，今天的主题是“初探Go底层”
[toc]
实验环境与回顾  操作系统：CentOS 7
Go：1.14.12
调试工具：readelf、dlv
 这里我们同样运行曹大提供的实验环境，并且挂载映射到本地项目，然后进入到这个容器环境中。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 4# 进入项目目录 5cd /project/work/ch01 6# 查看文件 7ls 8 这里的绿色 hello，就是我们 Go 语言编译后产生的 ELF 格式可执行程序（ELF 不知道是什么，可回顾上期文章）
我们一般通过工具 readelf 来找到进入可执行程序底层的入口 entry point address，通过以下命令来实现，这里的 -h 表示去读取 header
 -h &amp;ndash;file-header	Display the ELF file header
 1readelf -h hello 开始底层调试 当找我们通过 readelf 找到了调试入口的十六进制地址码，我们还需要用另一个工具 dlv 才能来调试 Golang 程序。再次之前，来简单说明一下什么是 readelf、什么是 dlv。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试2</title>
      <link>https://jupiterxue.github.i/posts/2021-08-11-go-top-day4-run/</link>
      <pubDate>Wed, 11 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-11-go-top-day4-run/</guid>
      <description>上回我们说到，利用调试工具 readelf 读取我们在 Linux 上编译的可执行文件 hello，并且找到了查看 Go 底层的入口 entry point address，今天我们尝试踏进底层调试的大门，看一看我们平时所说的底层，是否真的很困难，今天的主题是“初探Go底层”
[toc]
实验环境与回顾  操作系统：CentOS 7
Go：1.14.12
调试工具：readelf、dlv
 这里我们同样运行曹大提供的实验环境，并且挂载映射到本地项目，然后进入到这个容器环境中。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 4# 进入项目目录 5cd /project/work/ch01 6# 查看文件 7ls 8 这里的绿色 hello，就是我们 Go 语言编译后产生的 ELF 格式可执行程序（ELF 不知道是什么，可回顾上期文章）
我们一般通过工具 readelf 来找到进入可执行程序底层的入口 entry point address，通过以下命令来实现，这里的 -h 表示去读取 header
 -h &amp;ndash;file-header	Display the ELF file header
 1readelf -h hello 开始底层调试 当找我们通过 readelf 找到了调试入口的十六进制地址码，我们还需要用另一个工具 dlv 才能来调试 Golang 程序。再次之前，来简单说明一下什么是 readelf、什么是 dlv。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day3-run/</guid>
      <description>今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我一步步走肯定都能理解。
既然要进行代码实践操作，首先要考虑的就是Go语言编译器（也就是Go）、Go 编程环境以及 Go 代码的调试环境，这里我们需要用到的版本：
 操作系统：CentOS7 或其他 Linux 环境
Go：1.14.12
Go 调试工具：readelf
 是不是有点复杂？如果版本和我的不一样，那么实验结果可能不一样。如果版本比较低，有的工具需要自己去找旧版本的去匹配安装。那有没有什么办法可以简化这些实验环境的搭建呢？用上容器技术——Docker。简单说，当你用 Docker 的时候，就像在自己的电脑中装上了我所说版本的实验环境，里面包括了上面所说的所有东西。你可以用我给出的定制环境（我们称之为镜像），也可以用其他人给出的定制环境，并且可以做到无缝切换。就这么说，在你的 windows 上可以运行 CentOS、Ubuntu，甚至还能在 windows 上运行一个微型 windows，是不是很神奇？OK，我们说回今天的实验，在开始之前希望你能去了解 Docker 是怎样操作的，这里推荐我非常喜爱的 B 站 UP 主“遇见狂神说”推出的 Docker 教程。好，就当你已经会基本操作啦，跟我开始敲代码了：
 搭建实验环境  1docker run -it xargin/go1.14.12-dev bash 这里我们运行了曹大（曹春晖）提供的实验环境，并且进入到这个容器环境中。但是存在一个问题，我们在这里面写的代码在这个容器销毁后就没有了，所以我们需要对容器做一个映射，在容器中写了文件，在我们本地也有一份记录。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 创建目录与文件  在home目录下创建文件夹所有实验目录 work，创建第一个实验目录 ch。（这里的样式和大家不一样是因为 安装了 zsh ，你不一定也要按照，如果感兴趣，请自行搜索安装，当前配色主题是 ys）
实验环境准备完毕。
编写一段简单代码  我们来打开一个叫做 hello.go 的文件，写一段我们最熟悉的代码：
1vi hello.go 1// hello.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>https://jupiterxue.github.i/posts/2021-08-09-go-top-day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-09-go-top-day3-run/</guid>
      <description>今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我一步步走肯定都能理解。
既然要进行代码实践操作，首先要考虑的就是Go语言编译器（也就是Go）、Go 编程环境以及 Go 代码的调试环境，这里我们需要用到的版本：
 操作系统：CentOS7 或其他 Linux 环境
Go：1.14.12
Go 调试工具：readelf
 是不是有点复杂？如果版本和我的不一样，那么实验结果可能不一样。如果版本比较低，有的工具需要自己去找旧版本的去匹配安装。那有没有什么办法可以简化这些实验环境的搭建呢？用上容器技术——Docker。简单说，当你用 Docker 的时候，就像在自己的电脑中装上了我所说版本的实验环境，里面包括了上面所说的所有东西。你可以用我给出的定制环境（我们称之为镜像），也可以用其他人给出的定制环境，并且可以做到无缝切换。就这么说，在你的 windows 上可以运行 CentOS、Ubuntu，甚至还能在 windows 上运行一个微型 windows，是不是很神奇？OK，我们说回今天的实验，在开始之前希望你能去了解 Docker 是怎样操作的，这里推荐我非常喜爱的 B 站 UP 主“遇见狂神说”推出的 Docker 教程。好，就当你已经会基本操作啦，跟我开始敲代码了：
 搭建实验环境  1docker run -it xargin/go1.14.12-dev bash 这里我们运行了曹大（曹春晖）提供的实验环境，并且进入到这个容器环境中。但是存在一个问题，我们在这里面写的代码在这个容器销毁后就没有了，所以我们需要对容器做一个映射，在容器中写了文件，在我们本地也有一份记录。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 创建目录与文件  在home目录下创建文件夹所有实验目录 work，创建第一个实验目录 ch。（这里的样式和大家不一样是因为 安装了 zsh ，你不一定也要按照，如果感兴趣，请自行搜索安装，当前配色主题是 ys）
实验环境准备完毕。
编写一段简单代码  我们来打开一个叫做 hello.go 的文件，写一段我们最熟悉的代码：
1vi hello.go 1// hello.</description>
    </item>
    
    <item>
      <title>微信公众排版</title>
      <link>https://jupiterxue.github.i/posts/2021-08-08-wxpb/</link>
      <pubDate>Sun, 08 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-08-wxpb/</guid>
      <description>已经开通微信公众号两周了，但公众号的发文机制和排版机制让我有些头疼，今天来探讨一下——微信公众号的排版与运作机制，先列出我在这里写作最直观的感受：
 不能用 Markdown 写文章，识别不出来，空行也会被解析掉。 一天只能发布一篇文章，第二天才有新的可发布量。 可以修改文章，但修改后的关注公众号的读者看的文章还是以前的文章。 修改后想让读者看到，就需要重新发一篇，以前的会保留。  所以我的问题来了：
 文本输入不能支持 Markdown 语法那支持什么语法？还是说有什么办法可以转化？ 一天只有一篇文章的发布量，是否有什么方法增加发布量？或者说有预发布功能？ 想要修改文章、能够让读者看见，又不减少发布量，有可行的方法吗？  作为程序员，我们一般习惯用 Markdown 来写文章，因为排版的方式有点类似于代码的方式，并且操作的方式也类似于编码的方式，有快捷键、能插入不同语言代码。如果你想试用，这里推荐你试用一下 Typora，一个看起来非常的美观的基于 Markdown 的编辑和预览器，这个软件还有一个视图查看方式就叫做“源代码模式”。但是问题就出在，直接复制用 Markdown 写好的源代码文章，粘贴到微信公众号却不能直接识别出来，里面的文本和标识符识被识别为了纯文本，空行没有了，文字上的超链接没有了，图片也没有了。真的有点，气急败坏。然后尝试直接复制 Typora 预览模式下的文章到公众号。确实效果达到了，但也出现了一个问题：用了引用的格式却不能删除、多复制了几段空行却不能删除。又是气急败坏，去找了下解决方案，一开始找到了网站 Mardkown 转 微信公众号，经过一次尝试发现有的图片没有加载进去，遂放弃。后来几经折腾发现还是这个网站有用。第一次真的眼睛瞎了，为啥没尽早用到！！
官方怎么说 下午的时候对以前发过的公众号文章做了修改，但是只有自己能够看到。已经关注的粉丝（粉丝竟是我自己）查看文章还是原来的样子。所以去看了看一些资料，惊奇地发现，能改内容，但是：
 已群发的图文消息可以修改，其他类型消息暂不支持。每篇图文支持修改1次，且最多可以修改10个错别字（注：标点、英文、数字、空格都计算在内），支持增删。 如果要修改需要：登录微信公众号电脑端 → 首页 → 已群发 → 消息列表 → 悬停点击已群发单篇图文上有个“改”的按钮，点击即可打开修改页面，修改提交后需要管理员微信扫码验证。 微信官方希望每条推送都是公众号运营者深思熟虑的结果。秉承对读者负责的原则，更好的保证用户的阅读体验，修改五个以下的错别字也是为了尽量避免出现重复阅读时内容上前后不一致的情况。 推送到用户端的内容无修改权限，不仅仅是为了尊重用户前后一致的感知，技术上也不能对用户端的内容做修改。 有两种情况无法修改：一、辟谣：文章被发起辟谣且待审核或文章被发起辟谣且审核通过；二、已删除的文章。  总之，写公众号都是在每次深思熟虑之后再写，并且今天在探索后发现，还有预览的功能。
最后的最后，不要水微信公众号，不然又浪费一天 （的发布量）：）。
一些常识和技巧  不加首行缩进。 默认微信字体 16 号，建议用 15 px。粘贴字体进入微信后，先全选“清除格式”（或者 Ctrl+shift+V，直接祛除格式粘贴），就会变成微信默认字体，再选中 15 px 字体 间距 1.5 当文字之间有图片时，上下空一行。给受众呈现更好的阅读体验。 段落保持在三思行。 两端缩进。更适合手机阅读，看起来更有质感。但不太适合代码阅读，因为展示面小了点。 GIF动图。保存动图时需注意格式应为GIF格式且不能大于2M。 永久链接。即预览文章，如果需要别人帮忙改，预览的链接具有时效性。所以去用户界面找到自己的微信，把你想要预览的文章发给自己即可【注意:48小时内自己与自己的公众号互动才行】  常用编辑器好用推荐   秀米 主要用。 有非常多的漂亮模板，可以粘贴全部或部分。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day2</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day2-scheduler/</link>
      <pubDate>Thu, 05 Aug 2021 14:45:19 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day2-scheduler/</guid>
      <description>上回说到 Go 的调度流程本质上是⼀个⽣产-消费流程，今天来讲一讲“调度组件与调度循环”，再来回顾一下两个生动的动画 goroutine 的⽣产端, goroutine 的消费端。
当 goroutine 处于生产端时，M 执行调度循环时，必须与一个 P 绑定。并且我们常说的 Work stealing 就是说的 runqsteal -&amp;gt; runqgrab 这个流程。
当 goroutine 处于消费端时，执行的是一个循环：runtime.schedule → execute → runtime.gogo → runtime.goexit → runtime.schedule（回到原点），并且最终 P.schedtick = 0。
初学 scheduler 对于以上的流程感受是比较浅的，再来看看这些符号所代表的含义，就能更好地理解了：
 G: goroutine，计算任务。由需要执行的代码和其上下文组成。（上下文包括：当前代码位置，栈顶、栈底地址，状态等）
  M: machine，系统线程，执行实体，想要在 CPU 上来执行代码，必须有线程，与 C 语言中的线程相同，通过系统调用 clone 来创建。
  P: processor，虚拟处理器，M 必须获得 P 才能执行代码，否则必须陷入休眠（后台监控线程除外），你也可以将其理解为一种 token，有了这个 token，才有在物理 CPU 核心上执行的权利。
 上面所说的循环调度流程，都是在正常情况下运作的。而实际业务中我们往往还会遇到其他情况——阻塞。如果程序中有阻塞，那么线程不就全部被堵上，程序就卡住了么？
让我们来看看以下几种情况，在线程发生阻塞的时候，是否会无限地创新线程？（并不会）
案例1：
// channel send: var ch = make(chan int) ch &amp;lt;- 1 // channel recv: var ch = make(chan int) &amp;lt;- ch 案例2：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day2</title>
      <link>https://jupiterxue.github.i/posts/2021-08-05-go-top-day2-scheduler/</link>
      <pubDate>Thu, 05 Aug 2021 14:45:19 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-05-go-top-day2-scheduler/</guid>
      <description>1package main 2 3// sd1 4 5func main() { 6 // test 7} </description>
    </item>
    
    <item>
      <title>如何在 Go 高级工程师训练营生存</title>
      <link>https://jupiterxue.github.i/posts/2021-08-04-how-to-survive-in-senior-go-class/</link>
      <pubDate>Wed, 04 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-04-how-to-survive-in-senior-go-class/</guid>
      <description>前言 大家好，我是 Jupiter，目前从事的是 Pyhon 和 Go 的后端开发，现在是我们 Go 高级工程师第一期的学员，也是 3 班 7 组的组长。这周三的时候谢大邀请我来做个学习交流，很荣幸能有这样的机会给大家做个这样的交流。
一听到第一期学员，大家是不是觉得很厉害的样子。啊，没错，面向谷歌编程，复制粘贴代码的能力还是挺厉害的。不是，这期训练营教会我的当然不是复制粘贴那么简单，而是一个全方面的提高、一次格局拓展的经历。
像大家一样，看到有这么一个大咖云集的训练营，曹大、谢大、askuy、小 R 大（额，这里有的套娃）、听闻、邓大明、博锋，已经热血沸腾。再看了看价格，也不算很贵。相比于出门左转右转看到的黑马达内千峰，在价格上已经比较低了。机不可失时不再来，如果要问还有没有下一期，那可能我们第二期可能就是最后一期，嗯，最后一个第二期。
制定学习计划 在这次训练营开始前 5 月初时候，我是有点焦虑的。我是从 Python 转到 Go，几乎是没有什么 Go 基础，而这个训练营是面向 Go 高级工程师的。好像大家常见的语言转换和零基础，都被我撞上了。好在开营还有十多天，我做了两件事，让我在后面的学习节奏保持一个相对稳定的状态。
第一个就是制定学习计划。为期四个月的时间，120天，我很期待这期间所能够发生的许多奇妙化学反应。像往常一样，课前XXX，课中XXX，课后XXX。
课前：
   学习工具：搭建好环境、购买好 tizi 和相关工具 预习：把曹大推荐资料都读完，课程大纲自己绘制熟悉于心 问题：每次提前阅读完材料，一定要带着问题去听直播    课中：
   社群：积极参与任务，主动担当队长、副队长、主动去整理资料告知信息争做小助手 社区：每日浏览 GoCN 新闻，浏览关注的Go博主公众号和 Up 主视频 直播课堂：每次直播课都准时到，积极参加回答 大佬：多和老师曹大、助教、谢大沟通    课后：
   整理课堂笔记，发知识星球或者成立小组。整理出 github 博客 每次作业最迟第二天完成，不拖到第三天。 每天掌握一个面试问答。需要记录下来，整理出 github 博客    当然还不止这些，我还用到了风险管理与保险原理的一些方法。我向自己提问，风险有哪些？防控措施有哪些？</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>https://jupiterxue.github.i/go-to-top/go-top-day1-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/go-to-top/go-top-day1-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>https://jupiterxue.github.i/posts/2021-08-03-go-top-day1-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-03-go-top-day1-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>https://jupiterxue.github.i/posts/2021-08-03-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-03-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>从“名家谈写作”我学到了什么</title>
      <link>https://jupiterxue.github.i/posts/2021-08-02-learn-from-top-writer/</link>
      <pubDate>Mon, 02 Aug 2021 09:36:25 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-08-02-learn-from-top-writer/</guid>
      <description>下定决心想要做好写文章的习惯。给自己树立的目标是先行动起来，并且完成不那么困难的事情，当行动系统建立起来了，当日毕日更做到了，再是说更高的目标，更宏远的理想。
我创立这个公众号与技术博客（后续会开通）的原意在于做些技术分享，并且坚持更新，在一个领域中做到扎根与深入。我也清醒地认识到，这个目标过于长远，还得从长计议，因此目前的计划是给自己一个缓冲的时间，一天更新纯技术一天更新技术心得或生活感悟，这样不会有太大难度的技术壁垒，也能够形成一个缓冲期，后面形成了习惯就能做纯技术输出。
我认为，既然要开始写作，那么掌握写作的框架结构和常用套路是很有必要的。去看了几位写作名家谈论如何写作，包括：胡鞍钢、毛泽东、矛盾等。以下来谈谈我的心得体会。
胡大和毛大都强调写出好的文章第一个要注意的是了解和理解你的写作对象。并且你写的文章不是给自己看，而是要给别人看。并且要有服务读者的理念，写出让读者爱看的文章。
大人，时代变了。以前的我确实是这么想的，我们写文章最重要的是要了解读者是谁，然后才能写出好的文章。而对现在的从事互联网行业的我来说，我只是一个小喽喽，自己写的文章自己都不想看，何况别人看。虽然会编程的人都可以说自己是做互联网行业，但光就编程语言就有几十上百种，各种日新月异的技术层出不穷，互联网也有非常多的分支。所以我写文章的出发点更多的是写出自己都愿意看的文章，写自己领域的技术技能。
我一直以来的想法都是，如果写出的文章。自己也喜欢那么肯定能够吸引到和你一样的人。技术文章有时候讲起来过于细碎，有时候即便同方向的别人也不知道你在干什么。因此最后还是回到了：照顾好自己，吸引那些喜欢你、认可你的人。
第二点，也是三位大家都在强调的：反复修改文章。好的文章就像好的代码，虽然一开始跑的很快有初稿有初步代码，但想要修正自己的认知、提升自己的写作能力、突破自己的编程瓶颈就得真正做好这件事。更重要的是，要有勇气面对自己，接纳不完美的自己，拥抱你能够做得更好的地方。
最后一点是矛大所说的，向生活学习。我向来认为，一个会生活的人，写出的文章是能够从中体会到柴米油盐酱醋茶的酸甜苦辣。一个会编程的人，写出的代码是洞悉世界的底层规律，严谨且确定的。同时艰巨这二者的人，便是会生活，会编程，懂得学习与接纳，拥有自己思想的人。简单的说，就是你们所谓，我之所想的——有趣的人。比如我公众号第一篇文章，就是我非常喜爱的一位既是编程者也是写作者的人。
今天也是我写作日更第一天的开始，时间有点压。明天开始还是要早点行动，早点完成写作。先建立行动习惯，再去尝试更多想法。先做到提前写作，再做到超前写作。一起加油。</description>
    </item>
    
    <item>
      <title>Grafana 条形图实践</title>
      <link>https://jupiterxue.github.i/posts/2021-07-29-grafana-bar-chart/</link>
      <pubDate>Thu, 29 Jul 2021 09:56:39 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-07-29-grafana-bar-chart/</guid>
      <description>前言 可视化平台有很多，最重要的是选择符合业务需求的方案，费用低、学习曲线低、易于上手、集成性好这些都是加分项。众望所归，我选择了 Grafana。
特点 让我们康康 Grafana 是怎样的：
 免费。Grafana 是一个开源的独立日志分析和监视工具。 开发少可直接用。面向分析师和一般使用者，一般不需要做多少编码工作就能直接拿来分析数据、搭建可视化系统。 界面炫酷。来看看官网的展示 Grafana 官网概述 丰富集成。Grafana 是跨平台工具，它提供了与各种平台和数据库的集成，持 InfluxDB，AWS，MySQL，PostgreSQL 等。 用户交互体验好。展示连续实时监控指标（如 CPU 负载，内存）、对数据提供自定义实时警报、提供基于数据库及其查询语法的命令列界面。  准备工作-采集器 一个可视化平台，重要的是有数据来做支撑，像上面所说的数据库。本文采取具有灵活查询和实时报警构建的时序数据库 promethues 来作为数据管理端。
作为圣火的传人，promethues 有着各种采集器小弟，如服务器资源采集器 node-exporter、进程资源采集器 process-exporter、服务资源采集器 blackbox-exporter， 有了这些采集器就可以直接搭建起监控和警报
服务器监控 进程监控 服务监控 最后再配有 docker 微服务，你的监控和警报平台就能够一键部署起来了。 准备工作-定制化 有了各种采集器，其实能够满足大部分通用监控的需求，但往往我们的业务是不一样的，那么就需要进行定制。
用到了胶水语言 Python 在 promethues 的模块 promethues_client，就能开始定制了！
制作一个条形图 其实这个标题，我最先想取 “fuck the bar chart”，其他定制化的数据，表格、饼图、折线图都是能够在粗略熟悉 Grafana 后可以自己上手做的。
而这个条形图困扰了我整整一周的时间，各种找插件、换版本、调格式、选展示方式，都没有达到理想效果：
今天来彻底搞定这个问题！！
版本    工具 版本     Docker 1.13.1   Go 1.</description>
    </item>
    
    <item>
      <title>Python 答疑复盘</title>
      <link>https://jupiterxue.github.i/posts/2021-07-28-python-replay/</link>
      <pubDate>Wed, 28 Jul 2021 09:49:15 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-07-28-python-replay/</guid>
      <description>在成长会中，我们会自发组建小组学习各种知识与技能，比如新概念英语朗读、经济学专题晨读、瘦下来、相亲、太极、书法、早起锁定以及 Python 基础入门小组。如果没有你感兴趣的小组，也可以你来组建这么个小组，因为，成长会的同学五湖四海，肯定有喜欢你的人 :)
今年的 2 月到 6 月我在保险学专题晨读活动中担任小队队长，听起来有点高大上，做起来就是催作业（其实不是）。我们的晨读活动是每天看一两章专业领域的书，然后当天答题，没答题的就会被踢出群。而我作为队长，并没有过多地去催作业，我们小队的同学都比较自觉，嘻嘻。更重要的是，在担任队长期间，我去开发了一套小程序，能够帮助我和其他12个队长统计作业、统计没有完成名单、收集本队作业以及统计复盘。虽然已经有一套比较复杂的工程软件来统计，但普通人一般用不了，比较麻烦，所以最后还是落到人工统计上，而队长所谓的人工统计，就是让队员自己统计？自从我在当队员的时候看到这个问题，就开始萌生要做一个统计软件的想法。现在已经实现了，并且不同主题晨读活动的队长拿着我的代码也能够进行作业统计，只需要看我的文档就会操作，一般不需要辅导。因为里面已经有封装为 exe 的程序或者源码和一两部操作就能跑的说明。
大概7月初，我们在成长会的知识星球会写个人的半年总结，我写到了些事。有一天一个成长会的同学想组织大家学 Python，通过知识星球的半年总结帖发现了我 Python 用的还可以，就让我进入小组担任答疑官。于是就有了今天组织大家线上答疑复盘的经历。
我是在早上醒来发现这位 Python 学习小组长来联系，邀请我进行答疑，询问我的时间情况。就今天拉。然后她收集好大家在学 Python 过程中的问题便发了一份 Jupyter 打开的文件给我。我也在抽空的时间写了笔记并且提供给大家提前看了看，也算是我从另外一位答疑官朋友那里吸取的翻车经验吧——即便自己能力再厉害，遇到基础还是要踏踏实实。
今晚也算是我第一是上麦直播分享纯 Python 技术，这种体验对我来说真的不一样。以前一直想有机会开直播讲解技术，但一直感觉自己的技术能力很差不够格去讲。现在深刻感悟到，我已经踏进门了一步，相比于想要入门的同学，分享的任何东西相对来说都是对他们有价值的。同时也发现，对基础概念的理解需要细细揣摩才能理解。同学们问的基础问题也值得留意，因为自己当初也是那么稀里糊涂地过来的，现在还能回答上吗？如果不能那就赶紧动起来，二次学习的机会到了！
其实这是第一次讲授代码的课，一开始我陷入了一句句讲解代码的过程，讲了第一题我自己就觉得有点累遭不住，美其名曰地问了一句大家觉得我这个讲解方式还适应吗，其实是想让大家说只想听思路，hhh。现在看来，一句句讲解是有必要的，一句句代码给大家演示也是有必要的，因此需要做好基本功的储备。同时，授课的时候要去倾听听众的感受，让我们一起将这堂课圆满完成。</description>
    </item>
    
    <item>
      <title>Go 实用小工具</title>
      <link>https://jupiterxue.github.i/posts/2021-07-26-go-tools-kit/</link>
      <pubDate>Mon, 26 Jul 2021 11:00:46 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-07-26-go-tools-kit/</guid>
      <description>Go 小工具 执行命令行 1package main 2 3import ( 4	&amp;#34;flag&amp;#34; 5	&amp;#34;fmt&amp;#34; 6	&amp;#34;runtime&amp;#34; 7 &amp;#34;os/exec&amp;#34; 8 &amp;#34;strings&amp;#34; 9) 10 11func main() { 12	// flag 包使用方法：flag.Type(&amp;#34;flagName&amp;#34;,defaultValue,&amp;#34;help message&amp;#34;) *Type 13	var name = flag.String(&amp;#34;name&amp;#34;,&amp;#34;ls&amp;#34;,&amp;#34;info: 命令&amp;#34;) 14	var args = flag.String(&amp;#34;args&amp;#34;,&amp;#34;-h&amp;#34;,&amp;#34;info: 多个参数&amp;#34;) 15 flag.Parse() 16	fmt.Println(*name) 17	fmt.Println(*args) 18	cmd := *name + &amp;#34; &amp;#34; + *args 19	fmt.Println(&amp;#34;Command: %s&amp;#34;, cmd) 20	out, err := exec.Command(&amp;#34;bash&amp;#34;, &amp;#34;-c&amp;#34;, cmd).CombinedOutput() 21	if runtime.GOOS == &amp;#34;windows&amp;#34; &amp;amp;&amp;amp; err !</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://jupiterxue.github.i/about/</link>
      <pubDate>Sat, 24 Jul 2021 17:51:42 +0000</pubDate>
      
      <guid>https://jupiterxue.github.i/about/</guid>
      <description>Github: Jupiter</description>
    </item>
    
    <item>
      <title>王垠的智慧</title>
      <link>https://jupiterxue.github.i/posts/2021-07-23-idea-from-wangyin/</link>
      <pubDate>Fri, 23 Jul 2021 18:21:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2021-07-23-idea-from-wangyin/</guid>
      <description>王垠的智慧 王垠是谁？去谷歌知乎简单搜搜就能很快知道这个大名鼎鼎之人。对我来说，他是具有叛逆精神、擅长质疑与逻辑推断的人。他的求学经历让我感到惋惜，与此同时，他的学习能力让我膜拜，他对计算器编译器的深刻洞见让我崇拜。最让我痴迷的是，还是他在自己的博客 “当然我在扯淡”中记录了四篇他的智慧：
参考链接
《编程的智慧》http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy
《生活的智慧》http://www.yinwang.org/blog-cn/2017/07/08/living-philosophy
《旅行的智慧》http://www.yinwang.org/blog-cn/2017/08/14/travel-wisdom
《学习的智慧》http://www.yinwang.org/blog-cn/2019/07/12/learning-philosophy
心得感悟 我是从大学开始接触编程，也是从大学才接触到的王垠。那时候无意之间闯入了 GNU 的新世界，王垠已经在这个广阔天地被人们称为了大牛。和计算机课本上那些枯燥、机械的例子不同，他将算法的思想融入到了生活的点点滴滴当中。不管你是否是从事计算机行业，相信看了这几篇文章都会被他的思想吸引住，想去一一尝试一下。
如果你从事计算机行业，掌握编程，那么你很荣幸，我们最大的乐趣就在于创造，它能让你脱离低级的趣味。我们学习技术，最直观的学习是在实践中进行的，学了代码就去写，掌握思想就能改，实践多了就能大胆创新。这时候，编辑器你的画笔，可以让你成为神笔马良；编译器是你的电脑笔友，细心地告诉你在哪里你要去往哪里。
我们做程序的，习惯叫自己程序员 / 程序媛 / 码农，就从码农可以看出，是勤勤恳恳的。确实，在编程领域当中，一分耕耘一分收获。大家学习技术，也许不单纯为了一份工作，我相信热爱技术的你，是想通过自己的双手，通过对技术的理解，创造出对世界、对社会有价值、有贡献的东西。当然，我们沉迷技术，却不是脱离生活，我们希望技术能够改善生活，我们希望算法的思想能够让这个社会变得更加美好，我们希望这个世界变得更加智慧。
生活不止眼前的代码，还有流淌于柴米油盐之间的智慧。
参考资料 [1]
[2] 最“狂”天才，保送清华读博，3次退学，怒怼阿里 P10，被微软全球封杀！ https://jishuin.proginn.com/p/763bfbd2b5c2</description>
    </item>
    
    <item>
      <title>Algorithms - Graphs</title>
      <link>https://jupiterxue.github.i/posts/2020-05-01-algorithms-graphs/</link>
      <pubDate>Fri, 01 May 2020 09:00:00 +0000</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2020-05-01-algorithms-graphs/</guid>
      <description>Undirected Graphs Some problems  Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once  classical NP-complete problem.   Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical?  No one knows so far. A lonstanding open problem    Representations Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree).</description>
    </item>
    
    <item>
      <title>Racket notes</title>
      <link>https://jupiterxue.github.i/posts/2020-02-29-racket/</link>
      <pubDate>Sat, 29 Feb 2020 09:00:00 +0000</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2020-02-29-racket/</guid>
      <description>Basic 1#lang racket 2(provide (all-defined-out)) 3 4;this is a comment 5 6(define s &amp;#34;hello&amp;#34;) 7 8(define x 3) 9(define y (+ x 2)) 10 11(define cube1 12 (lambda (x) 13 (* x (* x x)))) 14 15(define cube2 16 (lambda (x) 17 (* x x x))) 18 19(define (cube3 x) 20 (* x x x)) 21 22(define (pow1 x y) 23 (if (=y 0) 24 1 25 (* x (pow1 x (- y 1))))) 26 27; currying 28(define pow2 29 (lambda (x) 30 (lambda (y) 31 (pow1 x y)))) 32 List  Empty list: null  () doesn&amp;quot;t work for null but &#39;() does   build a list: (list e1 .</description>
    </item>
    
    <item>
      <title>ruby学习笔记</title>
      <link>https://jupiterxue.github.i/posts/2016-12-08-ruby-notes/</link>
      <pubDate>Thu, 08 Dec 2016 22:54:49 +0000</pubDate>
      
      <guid>https://jupiterxue.github.i/posts/2016-12-08-ruby-notes/</guid>
      <description>regular expressions =~是用于正则表达式的匹配操作符。返回匹配到的字符串位置或nil。
1&amp;#34;abcdef&amp;#34; =~ /d/ # return 3 2&amp;#34;aaaaaa&amp;#34; =~ /d/ # return nil !和? The exclamation point (!, sometimes pronounced aloud as &amp;ldquo;bang!&amp;quot;) indicates something potentially destructive, that is to say, something that can change the value of what it touches.
ruby&amp;gt; s1 = &amp;quot;forth&amp;quot; &amp;quot;forth&amp;quot; ruby&amp;gt; s1.chop! # This changes s1. &amp;quot;fort&amp;quot; ruby&amp;gt; s2 = s1.chop # This puts a changed copy in s2, &amp;quot;for&amp;quot; ruby&amp;gt; s1 # .</description>
    </item>
    
  </channel>
</rss>
