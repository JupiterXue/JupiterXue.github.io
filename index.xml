<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>木夜星空的个人博客</title>
    <link>https://jupiterxue.github.io/</link>
    <description>Recent content on 木夜星空的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>JupiterXue</copyright>
    <lastBuildDate>Mon, 25 Oct 2021 23:20:11 +0800</lastBuildDate><atom:link href="https://jupiterxue.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2021 10 25 Escape From Escape Analysis</title>
      <link>https://jupiterxue.github.io/posts/2021-10-25-escape-from-escape-analysis/</link>
      <pubDate>Mon, 25 Oct 2021 23:20:11 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-10-25-escape-from-escape-analysis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Leetcode 刷题初探</title>
      <link>https://jupiterxue.github.io/posts/2021-10-13-leetcode-thinking/</link>
      <pubDate>Wed, 13 Oct 2021 23:04:46 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-10-13-leetcode-thinking/</guid>
      <description>题外话 已经有刚好一个月的时间没有写文章了，其实每天都会想着要写些什么，包括 Go 高级技术、《DDIA》的阅读进展，以及一些零散的即兴写作。其实之前写文章有接近日毕的好习惯，这真的是沿袭成长会的优良传统。虽然文章不一定写得好，但只要持续每天写，总有时间去做得更高，而不是一直在等自己状态好，一些补完所有学习/写文章等想法。
还有一点是我参与了成长会的写作日毕小组，借此机（ya）会（li）能够尽可能达到每天写文章的状态。而上个月的今天，也就是小组结束的时候，我也没有让自认为建立起的日毕习惯带动我继续写文章。还是得承认，我是个懒人。
但我也没有闲下来，这一个月的时间，刷了一些 Leetcode 题，一些思考和感悟和大家分享一下，包括为什么想刷题，如何刷题，学习材料，刷题的收获、小组氛围和自己的一些见解等。
开启刷题之路 为什么想刷题 其实很直白的就是为了大厂的面试。每个小程序员心中都有个纯粹地去大厂的梦。但发自内心还是想把算法能力提高，增加对编程语言的理解。然而在今年成长会中，暂时还没有适合自己的技术类小组，既然没有就自己做吧。我也是第一次尝试建立小组，想调动做技术类同学的一个学习氛围。
如何刷题 其实我是调研了许多 github 项目、知乎、简书上的攻略，然后总结了如下一个要点：
（1）短期大量训练。虽然小组是短跑，但想要提高必然要大量练习，不如在这个小组的压力下多 push 一下自己。一天中有时间就去刷一道题。
（2）刷题顺序。由于长期没有刷题的习惯，对算法生疏，对平台的机制不熟悉。先找简单题摸索，多通过些题，既培养刷题感觉、自信，也慢慢培养刷题的好习惯。刷通一遍简单提后，刷中等题。（据了解，大厂出题难度也就中等）
（3）刷题习惯，做难事必有所得。首先脱离一切，去看问题，写代码尝试，直到想不清楚逻辑、彻底忘记了某数据结构，然后先复习数据结构再刷题。还是没通过，找答案通过，然后手抄一遍并标记下来。
（4）学习习惯。每天精读一篇《刷题攻略》/ 刷一集刷题视频 / 一篇公众号博文 / 关注博主随便看看。
学习材料 已经开展了两期刷题小组，学习资料都是源自 github 中 star 很多的项目。
第一期我们用到的是 《LeetCode 刷题攻略》https://github.com/youngyangyang04/leetcode-master ，第一期简单刷了大部分后发现，这个材料还是零零散散。
所以第二期换了学习材料，用的是 《LeetCode Solutions》https://github.com/azl397985856/leetcode ，让我有点意外的是以下几点：
（1）相比上期材料，题目罗列更清晰，更有条理，也更好用来出题。
（2）没想到刷题还有浏览器插件，调研和试用了两个不错的：
 - **Leetcode Editor**，作为 JetBrains 全家桶中的编辑器能够按照插件，可以直接选择题目，并打开题目模板，不用自己再复制。（强烈推荐）   - **leetcode cheatsheet**，作者给出的插件，提供了一些解题的模板，可惜只有 js 和 py 版本。（一些树、图、动态规划等题目可以先用起来）  （3）一直想了解一下 Anki，都没一个感兴趣的主题，没想到 Leetcode 也有，而且意外发现非常适合。
刷题收获 （1）刷题量，两道简单一道中等还行，但多一道中等就有点难受了。
（2）粗略复习了八种数据结构（数组、链表、哈希表、字符串、栈与队列、树、回溯、排序）和两种编程语言的常用基础语法（Python 和 Go 都用到了）。总结了：链表、哈希表、回溯、树类型题目中的关键步骤。
（3）尝试用不同编程语言实现算法，增加了对算法思想的印象、加深了对编程语言的熟悉度。 （4）掌握了一天当中刷题的节奏：</description>
    </item>
    
    <item>
      <title>2021 09 19 Ddia Chapter4</title>
      <link>https://jupiterxue.github.io/posts/2021-09-19-ddia-chapter4/</link>
      <pubDate>Sat, 18 Sep 2021 22:20:31 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-19-ddia-chapter4/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Day21 Garbage_collection</title>
      <link>https://jupiterxue.github.io/go-to-top/day21-garbage_collection/</link>
      <pubDate>Sat, 18 Sep 2021 22:19:25 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day21-garbage_collection/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内存管理</title>
      <link>https://jupiterxue.github.io/go-to-top/day20-memory_management/</link>
      <pubDate>Sun, 12 Sep 2021 10:01:17 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day20-memory_management/</guid>
      <description>发生内存泄露时，要知道内存如何进行分配，垃圾回收要找出哪些对象有用，哪些对象无用。尤其当系统到达高并发瓶颈时，更需要垃圾回收这一角色做好风险把控，否则就是大型灾难现场。今天就来聊聊内存管理与垃圾回收。
背景介绍 垃圾回收 Garbage Collection ，我们一般称为 GC。在现实世界中，说到垃圾，指的就是那些不读的书、不穿的衣服等。在计算机中，GC 把程序不用的内存空间视为垃圾。但究其本质，GC 本身也是一个程序，如果满足两项功能的程序，我们就可以叫它 GC：
 找到内存空间中的垃圾 回收空间，让程序员能够再次利用这部分空间。  在没有 GC 的年代，像 C 语言程序员必须自己手动去分配内存，必须确保申请多少大小的内存空间，在程序执行完释放不再需要的空间。因为在当时计算机的内存资源是稀缺和昂贵的，现在我们买一个 G 内存条的价格相当于当时买 1 KB 的价格，所以程序员写代码时操作都是小心谨慎的。
人为操作，难免有疏忽的地方。如果忘记释放内存空间，该内存空间就会发生泄露。意味着这块空间将会继续维持被使用的状态，无法被使用。一部分内存泄露放任不管，直到所有内存被占满了，整个系统也就崩溃了。
另外，在释放内存空间时，如果忘记初始化用于释放内存的指针，这个指针就会一直指向释放完成的内存空间。更有甚者，释放的空间错误，导致下次程序使用这个空间时发生故障。这些内存上的 bug 都是难以确定真实原因的，因为与内存分配时疏忽造成的 bug 和真实场景下发生的位置（或时间）是不一致的。
为了略去以上种种的麻烦与困难，聪明的人们研发了 GC，即把内存管理的工作交给计算机，程序员就不用想着什么时候要释放内存，不用再担心忘记释放内存所导致的 bug，从而大大减轻负担，将更多精力和注意力放在业务开发上。
在学习难度上，如果说内存分配难度在 2 ，那么垃圾回收的难度就在 4，相比之下难度翻倍。并且学习垃圾回收必须掌握扎实的理论基础，否则难以读懂代码，不知道在干什么。有三本关于垃圾回收的书，可以去读一读：《垃圾回收的算法与实现》、《垃圾回收算法手册-自动内存管理的艺术》、《深入 Java 虚拟机》。
 实际上，Go 官方的 runtime 作者中能够去维护 GC 代码的人也很少。
据说，GC 是因为 Java 的发布而一举成名。
 基础概念 我们在学习内存分配的和 GC 的时候需要经常去问自己一些问题，顺着问题的思路去找代码会方便些。如果直接埋头去看 Go 语言内存相关的代码肯定会很蒙蔽的，毕竟内部数据结构真的很多。
 内存分配：
 内存从哪里来？ 内存要到哪里去？  GC 中标记流程：
 标记对象从哪里来？ 标记对象到哪里去？  GC 中清扫：</description>
    </item>
    
    <item>
      <title>2021 09 12 Ddia Chapter3</title>
      <link>https://jupiterxue.github.io/posts/2021-09-12-ddia-chapter3/</link>
      <pubDate>Sun, 12 Sep 2021 00:07:08 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-12-ddia-chapter3/</guid>
      <description>已经读完第三章，这里对前面三个章节做个总结，与其说是讲如何设计技术架构，不如说分布式技术的一些常识：
 后端和服务端都值得学习分布式 日志以追加写入更高效，分文件存放便于检索 图模型  第三章笔记 </description>
    </item>
    
    <item>
      <title>读经典《DDIA》-第二章</title>
      <link>https://jupiterxue.github.io/posts/2021-09-11-ddia-chapter2/</link>
      <pubDate>Sat, 11 Sep 2021 23:02:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-11-ddia-chapter2/</guid>
      <description>已经看完第二章《DDIA》，说下我是怎么抄书的，以及我有什么收获。
0.什么？抄书？没错，我是边抄边写笔记。因为我就和你一样，看不进书（当然你比我更自律点）。开玩笑啦
1.当你不想看书的时候，就抄书；当你抄书抄到不想抄了，就想看了。虽然这句话被 S 老师作为段子来传颂，但我看到了有人抄过化学，有人抄过高数。我没有这种经历，也想亲自去实践一下到底有怎样的魔力。其次，我认为好的书是浅显易懂，深入浅出的，值得揣摩。
2.求其上者得其中，求其中者得其下，求其下着无所得。刚开始抄书是一件有点兴奋的事，因为抄这个动作是比较轻松的，因为理想中这是不怎么动脑子的。实际上由于你的专注，你会不由自主地关注作者在说些什么（虽然有时也会走神不知道作者在说什么）。并且由于抄书，你会开始对作者某个词语进行或多或少的思考。而抄书的困难也正是源于此，认真看和思绪漫游会导致你的阅读速度极大地降低，尤其在你发现抄了一两个小时，连一半都没有的时候，心情是有点绝望的，好在，你还可以明天抄嘛：） giao！
3.实事求是，实地考察。抄书中，你会发现作者写的话有多少冗余、多少用词不当。尤其我看的这本书原版是英文，翻译过来连句法还是英语的语法，根本不符合中文逻辑。所以我会将这句话进行汉译汉，转化为我自己能够理解的。大家都认为看技术不要看中文，因为中文和蹩脚，是的。但我再补充一句，你可以自己把蹩脚化为流畅。
4.简明扼要，提高速度。一直这么慢的抄写肯定不行，我在抄的过程中也逐步掌握了一些技巧：着重摘录抽象句式和实用句式，代码复制（看代码其实是最直接和方便的），详细参数说明忽略，图能动就不抄，不能动就用文字描述，不能用文字就截图、先摘录一二级标题，然后一个个攻坚（会有点成就感）。
5.暴力破解，巨无事细。抄书意味着会对每个地方都看一遍，找出是否有价值的地方。所以会对每个文字做一次简单的“有什么有用，是否摘要”的编码动作，这不同于看书。看书的时候，我很有可能是在想“这个不重要，过”。所以抄一遍下来，老师如果问哪一页哪个知识点，虽然你答不上来在哪里，但你知道，我确实看过，而不是看，过了。
6.建立根据地，逐步发展。即便中文的技术书读起来不是很顺畅，但大体意思作者是能够把握。最重要的是，当我看完了中文，我会对原书作者讲了什么内容有个大概的把握。所以看起英文来就更加流畅。
最后，这篇文章不是给看中文技术书洗白，只是想表达我在参与过程中的收获和感受。按照成熟的技术方法来说，看书、看文档还是以官方为准，以原版语言为准。地道的语言和没有信息损失的一手材料，才是好的学习资料。毕竟，高级食材，我们都吃原材料。
和小伙伴讨论章节内容，一个意外收获：
  我说：几种 Datalog 方法都没有听过，没有见过。好像是在说图结构有哪些处理方式，怎么表示更简洁、更高效
Helios 回复：主要还是场景不一样。
场景说得好，看完就局限在代码层面，一下又跳了出来。
  第二章笔记 第二章
数据模型在软件开发中最重要。不仅影响软件编写方式，还影响解题思路。
多数应用用使用层层叠加的数据模型构建，关键问题：如何用低一层数据模型表示。例如：
\1. 用对象或数据结构以及 API 来建模现实世界。
\2. 用数据模式表示存储结构。如 JSON、XML、数据库表、图，
\3. 用内存、磁盘或网络字节表示 JSON/XML/关系/图数据，进而来查询、搜索、操作。
\4. 在更低层次，用电流、光脉冲、磁场或其他东西表示字节。
复杂应用程序有更多中间层，如 API 的 API。但思想仍一样：提供明确数据模型来因此更低层次复杂性。这个抽象使得不同人员能够参与协作。
选择一个适合数据模型非常重要。因为种类很多，易用但不易支持，可操作但表现差，数据转化有的自然有的麻烦。
关系模型与文档模型
最著名数据模型——SQL。1970年 Edgar Codd 提出关系模型：数据为关系，关系是元素的无序集合。
关系数据库起源于商业数据处理，今天来看显得很平常：典型事物处理。
&amp;gt; 如：将销售或银行交易，航空公司预订，库存管理信息记录在库）和批处理（客户发票，工资单，报告）
并且当时数据库迫使开发者必须考虑数据库内部的数据表示形式。关系模型解决的是在实现细节隐藏在更简洁的接口之后。
网络模型和分词模型在 70、80 年代的主要选择，但关系模型随后占据主导。对象数据库在 90 年代由盛而衰。XML 数据出现于 21世纪初。
2010 年，NoSQL 开始萌芽，虽名字没有涉及任何技术，最初只是 Twitter 标签，2009 年非关系数据库开源会上这个术语的出现，迅速得到了传播。NoSQL 被重新解释为不仅是 SQL（Not Only SQL），NoSQL 流行的几个因素：</description>
    </item>
    
    <item>
      <title>GO 翻山越岭——系统调用调试工具</title>
      <link>https://jupiterxue.github.io/go-to-top/day19-tools_and_sys/</link>
      <pubDate>Thu, 09 Sep 2021 22:43:41 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day19-tools_and_sys/</guid>
      <description>了解系统调用就能在业务发生问题时有更多招数，见招拆招。知道了系统调用的概念，有时候我们还需要用工具去实际观察进程是如何发起系统调用，对操作系统做了哪些请求，今天就来聊一聊。
观察系统调用工具 在 Linux 中我们常用用观察系统调用的工具是 strace，在 macOS 系统上常用的是 dtruss
案例1，通过 strace 可以看到一个 Go 进程的启动过程到底调用了哪些系统调用，这里有个例子（具体代码不用关注）：
使用 strace 指令 + 可执行文件x，看到了有哪些系统调用函数被调用。execve 执行哪个二进制文件，arch_prctl、sched_getaffinity 设计 CPU 亲和度，oepnat 加载相关文件，mmap 系统映射，gettid 获取线程 ID。
案例2，通过 strace 还可以查看一些软件的做了哪些系统调用，比如查看 nginx 的：
我们知道 nginx 在平时不服务的时候都是阻塞的状态，即阻塞在某个系统调用上。使用 strace 指令 + -f 参数 + nginx 可以观察它启动的过程。如果这个软件需要创建多个进程，就需要这里的 -f 的 flag 参数，跟踪所有刚启动线程创建的其他进程。最后我们可以发现 nginx 阻塞在 pid 为 224 的 epoll_wait 上。
注意：在 docker 中用这个命令可能会遇到一些问题，可以参考这个链接《Why strace doesn&amp;rsquo;t work in Docker》https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/
案例3，通过 strace 观察一个 Go 语言 Hello world 程序生命周期中系统调用情况。</description>
    </item>
    
    <item>
      <title>读经典《DDIA》-第一章</title>
      <link>https://jupiterxue.github.io/posts/2021-09-08-ddia-chapter1/</link>
      <pubDate>Wed, 08 Sep 2021 23:25:30 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-08-ddia-chapter1/</guid>
      <description>算是等了好久，终于有机会来读这本书《Designing Data Intensive Applications》，中文名《设计数据密集型应用》，我们一般简称《DDIA》或者猪书（因为书的封面是一头野猪，Hog Riderrrrr～！）。读完这本书第一章，我也想极力向推荐给计算机和互联网行业做后端和服务端的同学。阅读背景 最初了解这本书是在曹大（曹春晖）的第一堂课上。曹大说自己看了那么多书，只有这一本是最好的，也推荐给大家（当时听完就有点热血沸腾）。后来我还发现，draveness 大佬在它的《程序员可能必读书单推荐（一）》https://draveness.me/books-1/ 中最后一本也提到了此神书。再后来，又去豆瓣看了看，中英文都是 9.7 分：
简单介绍一下，读《DDIA》能够 帮助我们建立一个分布式系统的全局概念，但还需要根据自己所在行业、所处业务和所面对的需求。前面一些章节和 rpc 有关系，中间一些和存储关系比较大，后面将大数据和流式计算。内容比较全，看完就知道分布式系统有哪些问题。
一个人可以走得很快，而一群人能够走得很远。读这本书，其实我是参与了一个小组的 github 读书项目，如果你感兴趣也可以联系我，我们一起参与这次读书之旅。
好，话不多说，开始卷！（以下为我简明扼要摘录的笔记，可以快速浏览）
第一章笔记 为什么要设计 现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。
CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。
数据密集型应用：
- 存储数据
- 缓存
- 索引
- 流处理
- 批处理
看上去平淡无奇是因为数据系统在抽象层面做得非常成功。工程师常常直接拿来用，而不是自己去做开发，因为数据库已经足够完美。
然而现实中还有各种不同的需求：多种缓存，多级搜索。重要的是有必要先弄清楚最适合当前业务的工具和方法。当单个工具已经解决不了我们的问题时，组合使用也有些难度。因此本书在探索如何设计数据密集应用的方法，以实现可靠、可伸缩、可维护的数据系统。
数据系统的思考 按我们的常识，为认为数据库、消息队列、缓存这些工具都是有差异的，但我们还是归类为 数据系统当中。虽然新出现了许多数据存储工具和数据处理工具，但类别之间的界限越来越模糊，比如：数据存储可以作为消息队列（Redis），消息队列带有类似数据库的持久保证（Apache Kafka）。
当单个工具不足以满足所有数据处理和存储需求，就需要将总体工作拆分成一系列能够被单个工具高效完成，并且通过应用代码缝合起来。如缓存（Memcached）和全文搜索（ES）结合将主数据库剥离，由应用代码来让缓存或索引和主数据库保持同步。
一个可能的组合使用多个组件的数据系统架构
多个工具组合提供服务，服务的接口或应用程序编程接口 API 会向客户隐藏实现细节。
设计 DIA 会遇到问题：系统故障，如何保证数据正确性和完整性？系统退化降级，如何给客户提供始终如一的良好性能。负载增加，如何扩容？什么样的 API 是好的？
影响设计的因素：参与者技能和经验、历史遗留问题、系统路径依赖、交付时限、公司风险容忍度、监管约束。
本书重点讨论：
- 可靠性。在 adversity 中（包括：硬件、软件、人为 故障或错误）仍可以正常工作。
- 可伸缩性。合理应对系统增长（数据量，流量，复杂性）
- 可维护性。不同参与者，在不同生命周期都能高效地在系统上工作（适应新的应用场景）。
可靠性 常见期望：
- 符合用户期望的功能
- 允许出错，还能正常使用软件</description>
    </item>
    
    <item>
      <title>GO 翻山越岭——Go 常见系统调用</title>
      <link>https://jupiterxue.github.io/go-to-top/day18-go_and_sys/</link>
      <pubDate>Tue, 07 Sep 2021 07:28:31 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day18-go_and_sys/</guid>
      <description>系统调用，是操作系统内核为应用提供的 API。今天继续来讲一个系统调用案例和 Go 中常见系统调用
   arch syscall NR return arg0 arg1 arg2 arg3 arg4 arg5     213 epoll_create man/ cs/ 0xd5 int size - - - -    来源：https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit
这是 Linux 中的系统调用，编号是 213，我们可以从一下代码了解更多信息：
1# define SYS_epoll_create 213 2 3TEXT runtime.epoll_create(SB), NOSPLIT, $0 4	MOVL	size+0(FP), DI 5	MOVL	$SYS_epoll_create, AX 6	SYSCALL 7	MOVL	AX, ret+8(FP) 8	RET 编号 213 按照调用规约会被存储在 rax 寄存器中，也就是这里的 AX 寄存器。epoll_create 只有一个阐述传递，也就是 int 类型的 size。SYSCALL 直接进入内核去了。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——系统调用基础</title>
      <link>https://jupiterxue.github.io/go-to-top/day17-lang_and_sys/</link>
      <pubDate>Mon, 06 Sep 2021 20:26:32 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day17-lang_and_sys/</guid>
      <description>编程语言和操作系统之间的桥梁，也就是我们所说的系统调用。今天来聊聊，系统调用的基础概念。
什么是系统调用 我们在了解系统调用之前，需要对操作系统有个简单的了解。操作系统（operating system,OS）是资源的管理器，也是计算机系统的内核与基石，其管理的资源都是经过了抽象。而对计算机来说，资源是硬件信息：CPU、RAM 内存、I/O 设备，以及进一步抽象的软件资源，如进程。
为什么说操作系统是对资源进行了抽象呢？因为操作不方便、操作不安全，我们平时接触到的不是直接的硬件，比如磁盘操作，不会去操作扇区（嵌入式系统除外）。而我们所面对的都是这些：
 磁盘抽象：文件夹 内存抽象：虚拟内存 CPU 抽象：时间片  有了操作系统，我们对计算机的调度还是不够的。说白了，操作系统也是一个应用程序，底层还是一堆代码和汇编指令。这时候，我们需要由硬件提供支持，在应用和操作系统之间进行一层或多层隔离。
CPU 已经为操作系统提供了特殊的安全支持——分级保护域（protection ring）。操作系统内核运行在特殊模式下，即图中的 ring-0 ，而应用运行在 ring-3，但权限被严格限制。因此，在代码中我们没办法直接去调用系统资源，就需要操作系统帮助我们去调用，并把相应的操作抽象成 API 来供我们使用。
 Intel64 有四个特权级别，不过实际上只用到了其中两个 ring-0 和 ring-3。ring-1 和 ring-2 本来计划是为了驱动程序和 OS 服务用，不过流行的 OS 们都没有接受这个方案。
 说到这里，答案已经揭晓。系统调用，是操作系统内核为应用提供的 API。可以理解为内核为应用提供服务，操作系统就位我们的上层应用程序提供了一系列“标准库”。比如我们常见的后端服务：APP 发起请求 request → 操作系统 Operating System 接收、处理并响应 → APP 接收 response。
 对于应用来说，系统调用可以实现超出自己能力以外的事情。
 那么 Go 语言中的系统调用是怎样的呢？在此之前，还需要提及 Go 语言调用规约。我们在做函数调用的时候没有使用寄存器，而是将参数都放在栈上。但在其他编程语言中做参数传递和函数调用都是用到了寄存器。举个例子：
1func hello() { 2 x, y, z := 1, 3, 3, 3 3 a, b, c := multi(x, y) 4} 5 6func multi(x, y int) (a, b, c int) { 7 r, s, t := 1, 2, 3 8 return x+1, x+2, x+3 9} 这段代码的调用规约如下：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Context</title>
      <link>https://jupiterxue.github.io/go-to-top/day16-data-structure_context/</link>
      <pubDate>Sun, 05 Sep 2021 15:48:38 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day16-data-structure_context/</guid>
      <description>Go 语言在 1.16 版本之后加入了新的内置数据结构 Context，虽然在代码中使用都比较简单，但语言内部还是做了许多区分，今天来分析一下 Context。
Context 虽然在使用 context 的时候，看起来都是 context.* 的结构，但 Go 语言内部做了这样一个区分：
具体说明如下：
 emptyCtx：所有 ctx 类型的根 valueCtx：主要为了在 ctx 中嵌入上下文数据，一个简单的 k 和 v 结构，同一个 ctx 内只支持一对 kv，需要更多的 kv 的话，会形成树形结构。 cancelCtx：取消程序的执行树 timerCtx：在 cancelCtx 上包了一层，支持基于时间的 cancel  这里有个例子
1package main 2 3import ( 4 &amp;#34;context&amp;#34; 5 &amp;#34;fmt&amp;#34; 6) 7 8type orderID int 9 10func main() { 11 var x = context.TODO() 12 x = context.WithValue(x, orderID(1), &amp;#34;1234&amp;#34;) 13 x = context.</description>
    </item>
    
    <item>
      <title>反法西斯胜利，再读《毛选》</title>
      <link>https://jupiterxue.github.io/posts/2021-09-03-anti-jp-victory/</link>
      <pubDate>Fri, 03 Sep 2021 23:00:50 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-03-anti-jp-victory/</guid>
      <description>今天是个特殊的日子，9月3日更是个特殊的日子，从1945年开始的到今天、以后每年的9月3日也是最为特殊的日子——中国抗日战争胜利纪念日、世界反法西斯战争胜利纪念日。虽说是纪念战争胜利，但那个人伏案奋笔疾书的样子依旧在我心头萦绕，他就是我们可爱的毛委员。
大家都习惯尊称他为毛主席称，其实毛主席更希望群众称他为“毛委员”。在1927年3月完成的《湖南农民运动考察报告》后，他提到：“我到各处，常常遇到这种人，这样向我求情：‘请省里来的委员作保！’，自此大家都开始称他为，毛委员。
再读《毛选》 今天又重新翻了翻折满边边角角的《毛选》，按照时间线简单梳理了几篇比较耐看的文章：
第一卷：
 《中国社会各阶级的分析》	《湖南农民运动考察报告》
《中国的红色政权为什么能够存在？》 《星星之火，可以燎原》
《反对本本主义》	《论持久战》
《论反对日本帝国主义的策略》	《中国革命战争的战略问题》
《实践论》	《矛盾论》
 第二卷：
 《〈共产党人〉发刊词》	《新民主主义论》
 第三卷：
 《论联合政府》
 想到了什么 谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。——《中国社会各阶级的分析》
在真实世界有很多以上类似的情况，一个东西的表现和本质有差异。我们应该更多地在于发现一个事物它本来的样子，然后去接受它本来的样子，而不应该以我们自己的设想去看事情。
许多农民运动的道理，和在汉口、长沙从绅士阶级那里听得的道理，完全相反。——《湖南农民运动考察报告》
当你开始做一些事情的时候，有些东西和成长励志故事的逻辑是相反的。
有些同志在困难和危机的时候，往往怀疑这样的红色政权的存在，而发生悲观的情绪。这是没有找出这种红色政权所以发生和存在的正确的解释的缘故。——《中国的红色政权为什么能够存在？》
有些人会害怕走弯路，但只要花费了脑力、体力一定会有收获的。尤其做难事必有所得。
我们在红军中工作的人，一遇到败仗，或四面被围，或强敌跟追的时候，往往不自觉地把这种一时的特殊的小环境，一般化扩大化起来，往往不自觉地1把这种一时的特殊的小环境，一般化扩大化起来，仿佛全国全世界的形式概属未可乐观，革命胜利的前途未免渺茫得很。—— 《星星之火，可以燎原》
有些时候我们遇到小问题，会把它推演的过于悲观
中国全国都布满了干柴，很快就会燃成烈火。—— 《星星之火，可以燎原》
任何前进的方向，都有失败的可能。但对未来的良好信心，来自于一个基本面的判断。当抓好了基本面，就不怕上上下下的起伏。
结语 其实，《毛选》不仅仅是军事战略者常看的书，现今天的创业者也很热衷于此，更让你我没想到的是，还有一篇文章叫做《婚恋大事问毛选》。可以说《毛选》已经进入了我们家家户户，承载了我们中华文明最灿烂的一刻。
推荐大家去看一部电影，最能近距离感受到毛委员的亲切——《古田军号》。故事情节紧凑，人物细致，尤其细节做得很好，陈毅反复划窗以表思念、毛泽东得了疟疾而党员们在想怎样给他弄到金鸡纳霜治疗、朱毛会师时双手握手的交付，新泉会议时朱毛同板凳共思想屁股决定脑袋等等。
最后，感谢毛委员，给了我们这样一个盛世。</description>
    </item>
    
    <item>
      <title>业界大数据备份，还看爱数</title>
      <link>https://jupiterxue.github.io/posts/2021-09-02-bigdata-backup/</link>
      <pubDate>Thu, 02 Sep 2021 23:28:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-02-bigdata-backup/</guid>
      <description>随着进入信息时代，各行各业的数据都在爆炸性地增长，给人们带来便利的同时，也给人们对安全的担忧更胜一筹。目前，数据容灾备份领域呈现蓬勃发展，尤其在大数据软件灾备板块现实出了极大的市场潜力，比较知名和具有潜力的灾备公司有：爱数、精容数安、鼎甲科技。今天就来聊聊行业龙头“爱数”的大数据保护方案 Anyway。（图没有放，感兴趣可以看看参考资料）
行情介绍 市场情况——大数据平台市场规模持续增长
全球规模：4813.6亿 RMB
中国大数据软硬件：677.3 亿 RMB
中国大数据软件：92.2亿
预计未来5年大数据平台市场平均增长率为 25%
大数据分析业务，很重要，也是主要业务之一
应用行业
金融、医疗、电力、交通 等等各行各业
风险
一旦丢失，业务连续性无法得到保障！
三个主要问题：
  风险无法预测
  物资无法调配
  应急调度无法指挥
  挑战与常见问题（各行各业）
- PB 级数据，如何在有限的备份窗口内完成备份？
- 长时间保留海量大数据备份副本，如何降低成本？
- 如何确保备份数据的安全存储与合规保留？
- 如何实现精准备份和异构版本兼容？
爱数——AnyBackup 大数据平台保护方案 整个方案可以为不同大数据平台提供备份和恢复的能力，包括：Apache Hadoop、华为 Inside、CLOUDERA CDH、星环科技 TDH。
在这些大数据平台下，爱数能够提供的备份能力：面向表级别粒度的备份恢复、数据一致性问题、基于 hdfs、hive 等不同组件来实现永久增量备份和多节点之间并发备份，还提供重复数据删除等基本能力。
提供的恢复能力：表级粒度恢复，多并发恢复，任意时间点恢复，不同大数据平台之间异构的恢复能力，
爱数还提供的独有能力：96 倍备份效率，90% 存储资源节省，数据安全存储和规范，面向不同的大数据平台、不同大数据组件提供全面保护
具体说明-爱数的特点
 提升 96 倍以上备份效率  传统备份方案，全备数据量要备份 1PB，备份时间在 6-7 天。
爱数完成全备后，后续都是增量备份，并且以 10T 为单位。在更短的备份窗口中完成全备
节约 90%存储资源  通常在给用户做备份策略配置的时候，是保留一个月备份数据。其中会进行四次全备，每天实现增量备份。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Map</title>
      <link>https://jupiterxue.github.io/go-to-top/day15-data-structure_map/</link>
      <pubDate>Thu, 02 Sep 2021 23:23:12 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day15-data-structure_map/</guid>
      <description>Map 有时能够返回一个值，有时候能够返回多个值，这是 Map 的特权语法。今天继续从底层角度来聊聊 Go 语言内置数据结构，Map。
Map Map 中大量类似但又冗余的函数，原因之一便是没有泛型。
1package main 2 3var m = make(map[int] int, 10) 4 5func main() { 6 v1 := m[1] 7 v2, ok := m[2] 8 println(v1, v2, ok) 9} 利用之前提到的工具 go tool objdump 能够获得反汇编后的函数：
 make → runtime.makemap 10 → hint m[1] → runtime.mapaccess1_fast64 m[2] → runtime.mapaccess2_fast64  以上这些过程都是编译器帮我完成的，编译器判断赋值语句，如左边有一个值就翻译为 runtime.mapaccess1_fast64， 需要注意以下三点：
 当 hint 大小大于 8 时，采用的是 makemap 当 hint 小于 8 时，采用的是 makemap_small map 分配栈上时，不一定会调用 makemap  为什么一个 Go 语言内置数据结构就有这么多情况，那如果 Go 的 20 来个内置数据结构都有这种判定，岂不是底层就有差不多 60 个不同判定结构？确实是这样的，map 中存在大量类似但又冗余的函数，但不至于把性能拉低很多。这种问题主要是原因之一是 Go 语言在 1.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Timer</title>
      <link>https://jupiterxue.github.io/go-to-top/day14-data-structure_timer/</link>
      <pubDate>Mon, 30 Aug 2021 23:13:54 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day14-data-structure_timer/</guid>
      <description>上期 Go 文章说道了 Go 内置数据结构，从底层源码角度简单地描述了 channel。今天继续分析其他的内置数据结构 Timer。
Timer Timer 在 golang 1.14 版本以前比较简单，整个 Timer.go 文件中代码 才 700 行左右。整个代码就是一个数据结构和许多 goroutine。但 golang 到了 1.14 版本以后，由于官方的升级维护就变得非常复杂。所以这里笔者简单讲一下 Timer 的迭代历史，状态机制不会涉及到。
从这张图可以看到**，最早的 Timer 就是一个四叉堆**。我们平时写算法的时候二叉堆见得比较多，那是不是理解这个更困难？不是的，我们着重看 Timer 的结构和演进。像最早的 time.Sleep 或者 time.After 这两个函数，实际上我们创建了两个 Timer 类，这个 Timer 会最终加到我们的 runtime 维护的四叉堆里面。这个四叉堆其实是很好理解的，其实是有个基准的。
堆顶要放什么元素，元素如何排列？都是以触发时间为准。也就是说离当前时间最近的，一定是在堆顶的。如果来了一个新的 Timer ，它是在这个时间之后，它就会继续往堆下面走。如果比堆顶小就会涉及到对当前四叉堆的调整了，这个和写二叉堆调整算法很类似。
最老的 Timer 实现全局只有一个四叉堆，这个四叉堆专门启用一个叫做 timerproc 的 goroutine。这个 goroutine 的逻辑也不复杂，就是用一个 for 循环。这个 for 循环会不断地检查堆顶元素是不是已经到期了，如果到期了就会触发，在触发的同时会逐渐地调整堆，直到把所有需要触发的 Timer 都触发完毕为止，继续去休眠。
但这种单一的四叉堆会有一个问题。当前 Go 程序所有的 goroutine 在执行 Timer 相关操作的时候都需要去抢占操作这个堆的全局锁，而其实这个锁都是写锁。如果并发量很高，那么就会导致程序整体的吞吐量下降。全局锁对于任何程序来说，性能影响都比较大，这个问题导致了 go 程序在多核处理器上性能不佳，有人专门提了一个 issues：https://github.com/golang/go/issues/15133。（就 python 来说， 虽然 python 支持多进程，也支持多线程。但因为 GIL 全局解释器锁的存在，python 的多线程程序在同一时间只有一个线程在运行。所以多线程 Python 程序只是并发，而不是并行）</description>
    </item>
    
    <item>
      <title>自己做菜自己吃，两个小汤菜</title>
      <link>https://jupiterxue.github.io/posts/2021-08-29-two-meal/</link>
      <pubDate>Sun, 29 Aug 2021 18:24:02 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-29-two-meal/</guid>
      <description>昨天闲来无事，历时3小时，自己动手做了两道菜：酸汤肥牛和清炖排骨。自己很少做菜，也几乎没怎么做过菜，没想到第一次做出来味道也还可以，但也有几个踩坑的地方，今天来复盘一下。
买菜篇 一是被推荐有个小程序“叮咚买菜”，二是平时通勤发现外卖小哥都有专门送叮咚买菜的车和衣服，三是因为是新人注册，有满减优惠券。有了网上买菜+配送，打消了我不想出门、不想到处逛选菜的麻烦；有了满减优惠，让我忍不住多买了些食材：
 肥牛卷 300 g，24 玉米 550g，9 山药片 200g，6.5 鹿茸菇 125g，2 番茄 500g，3 猪肘块 350g，10 绿豆芽 300g，2 排骨 300g，20 金针菇 200g，5 酸汤肥牛调味料 95g，12 贴心调味组合（小米辣+蒜+姜） 120g，4 泡菜组合（小米辣+豇豆+青菜）850g，6.5 蒜蓉酱 240g，12  新人卷 45-20、49-19，所以最后开销为 77 元，真的没想到自己买菜来做这么便宜，两个菜的食材价格能够顶得上外面一个菜的价格。
小细节 网上下好单，叮咚买菜的小哥过了大概30分钟就提着大包小包送到了我的家门口。像易碎的蒜蓉酱（瓶装）还单独给我装了一个轻拿轻放提醒的袋子，隔绝了其他菜。小哥还很热心地自我介绍了一波。
食材处理篇 提前在 B 站上看一两个做菜短视频，熟悉了清炖排骨整个流程。
因为买了排骨和猪蹄肉块，担心有腥味。所以先用冷水+一点料酒提前浸泡了一个小时，然后跑到一遍去玩了：）
轻煮肉块。将浸泡料酒的肉冷水下锅煮，煮到没有血色就捞起。这里失误了，因为没有加姜葱蒜一起去腥，所以重新来了一遍，把肉捞起来，加入姜葱蒜，再煮了一会儿。
香煎肉块。锅热倒油，将煮好的肉块放入进去，煎到有点紧实和焦黄。
小火慢炖。往煎好的肉中加入少量料酒，再导入热水，盖上盖子小火炖煮一个小时。
在这个期间开始准备另一道菜，同样的先看了看两个酸汤肥牛的短视频，然后动动手了。
先将玉米切块，番茄分别切块（给清汤）和切碎（给酸汤），山药片和鹿茸菇都直接洗出来。金针菇和绿豆芽也直接洗出来，但总感觉不放心，去分别看了看大厨怎么处理这两个食材的。然后我也把金针菇的根切掉很多，把绿豆芽的头和尾都掐掉。
40分钟小时后将切好的玉米、山药、蘑菇都加到了清汤里和排骨猪蹄一起炖煮。
在这期间把肥牛拆开用冷水浸泡一分钟，过滤掉血水。烧热水，在锅中过5秒豆芽，过5秒金针菇。这里金针菇应该过 15 秒，所以捞出来看起来还有点生。
准备肥牛汤。锅热导入少量油，然后放入干辣椒、蒜蓉酱、姜、蒜，爆炒1分钟的样子，然后加入清水，把干辣椒、姜都捞出来。等到水热后加入肥牛汤料。
烹饪 清汤排骨猪蹄。在合着玉米、山药、蘑菇煮了一个小时后，加入番茄块煮10分钟。然后加入一点盐和鸡精。美味就起锅啦！
酸汤肥牛。在肥牛汤准备好后，加入肥牛煮熟，不需要多久。因为担心金针菇没有熟，就在肥牛煮熟后放进去再煮了一会儿，再加入绿豆芽。这里也弄错了，导致肥牛吃起来很老，应该先把肥牛、金针菇单独煮好，然后放进热汤中。
最后，两道菜就都成功啦。吃到我撑了，还想再吃一块排骨或者一夹脆脆的绿豆芽与金针菇。
总结总结  网上买菜非常方便，新人还有巨大优惠（快薅羊毛）。 处理肉类时，用到姜蒜葱和料酒一起提前煮可以去腥味。并且，料酒还是个煮汤的好伙伴。 易熟的菜和肉不能久煮，最后起锅、开动前再加入即可。 自己做菜自己吃，健康好吃还能吃，就是有点费时间。  </description>
    </item>
    
    <item>
      <title>对于&#39;极简主义&#39;的一点看法</title>
      <link>https://jupiterxue.github.io/posts/2021-08-29-minimalism/</link>
      <pubDate>Sun, 29 Aug 2021 18:21:22 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-29-minimalism/</guid>
      <description>前几天看到 “S522-花样”同学写的一篇文章《极简=极奢》，今天想来谈谈自己对于“极简主义”的想法和认知。
乔舒亚在《极简主义》中的概括为：极简主义不是要你一无所有，而是要你穿越物质的海洋，找到真正重要的东西。
虽然极简主义起源于 60 年代，但真正蓬勃发展，我想很大可能是因为史蒂夫·乔布斯。
最初了解到“极简理念”是在李善友老师的《第一性原理》中讲解“乔布斯专题”中的一个苹果公司动画，当时这个动画真的惊艳到我了，怎样的设计理念才能做出如此佳作，仅仅是黑白线条、原点和文字，就能尽情表达：行云流水，自然流畅、灵动跳跃、坠落与水流、突破预期、如吹自然界的风、如朋友间的沟通。话不多说，你可以康康：《苹果广告——至繁归于至简》https://www.bilibili.com/video/BV1Rs411E7Pw?from=search&amp;amp;seid=13506173852847306812
因此，我从18年到现在，就一直很喜欢关于“极简主义”的话题。尤其在看《乔布斯传》的时候特别痴迷，《乔布斯在他的家中，1982年12月15日》，这幅图片一直印象深刻（虽然每次看都像是汤姆·克鲁斯），每当我想到极简生活就会联想到：https://o.aolcdn.com/images/dar/5845cadfecd996e0372f/81062ddbeaac7699cf47b901b18adebdb48c046d/aHR0cDovL3d3dy5ibG9nY2RuLmNvbS9jbi5lbmdhZGdldC5jb20vbWVkaWEvMjAwOS8wMS8wNjJiLmpwZw==
![u=1816380262,1947610985&amp;amp;fm=173&amp;amp;app=25&amp;amp;f=JPEG (1)](C:\Users\Xfavor\Desktop\u=1816380262,1947610985&amp;amp;fm=173&amp;amp;app=25&amp;amp;f=JPEG (1).jpg)
这张照片拍摄于乔布斯27岁，并登上《时代》杂志封面。正如乔布斯给这张照片写了题词：&amp;ldquo;这是一个经典时刻。我独自一人，所需要的不过是一杯茶、一盏灯和一台音响。你知道，这就是我的全部。&amp;rdquo;
很喜欢像乔布斯当时所处的环境，一盏灯、一个什么都没有的空荡荡的房间，当时在大学就在想，我以后的生活，也想这样过。后来，现在自己也确实在这样做（当然遭罪的是自己）。然后慢慢体会到，极简是从最简单开始，而生活不是苦修，需要什么再慢慢添加什么。
再后来，读到一篇王垠对苹果手机 Home 键的批判中终于脱离了这种类似宗教的信念。王垠说到，虽然苹果手机在界面上之保留了一个按钮，给用户带来了极大的简化，但内部的细节无疑非常复杂，给维护的人员造成了极大的复杂。所以，极简一说也有对象之分。
不过，现在的极简主义的理念也逐渐被商业化了。相比于消费主义和物质主义，无疑减少自己的欲望、少购物是极简主义所倡导的。但商业总是无孔不入，商业是制造需求。既然我们那么崇拜极简主义，那么就推出看似极简的产品与服务让你购买。并且这些产品旁通常还放有单一色彩的广告语“拥有的越少，生活过的越有意义”之类的语录。正是这种类别划分，将极简主义完全商业化。越来越多自称为“极简主义者”的人忙着营销和收割。
如今，大家都在提倡极简，时尚极简、家具极简、生活极简，甚至精神极简。这些都没有问题，甚至是好事，因为在这样一个复杂度不断增大，熵不断增加的世界，有人在反向探索。探索社交的初心，探索生活的放心，探索精神的静心。商业社会虽然会把种种妖魔化，但并不阻碍探寻真相的勇士逆流而上，找到那个本源，找到那个一。
[1] 从苹果产品的设计错误学教训, 王垠
http://www.yinwang.org/resources/ciia1.pdf
[2] 极简主义, 豆瓣
https://book.douban.com/subject/34901087/
[3] 极简主义真的能让我们更快乐吗？
https://www.thepaper.cn/newsDetail_forward_7120725</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——内置数据结构-Channel</title>
      <link>https://jupiterxue.github.io/go-to-top/day13-data-structure_channel/</link>
      <pubDate>Sun, 29 Aug 2021 14:47:52 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day13-data-structure_channel/</guid>
      <description>内置数据结构是一门编程语言的基础核心，了解基本语法就能够让我们进行简单的开发。今天开始，就来系统地研究 Go 语言内置数据结构。
首先，先来看看所有的Go 语言所有内置数据结构都有哪些，如下图所示，列出了思维导图：
既然是系统地研究，这里就需要用到暴力破解的思想——把每个数据结构都遍历吃透。
Channel 之前的文章中提到了通过反汇编调试工具来查看 Go 语言的源码。还提到了三种情况会导致 panic 的关键函数 chansend、chanrecv，下面来进行源码逻辑分析。忽略一些细节实现，来看看 chansend 的流程图：
图上省略了：
 select dafault 的情况。 逻辑执行时碰到 ch 已 close 的情况。  从流程图，能够清晰地看到 在 chansend 的内置函数中，Go 语言是如何处理我们发送的数据。紧接着我们再来看看 chanrecv 的流程图：
图上也省略了：
 select default 的情况。 逻辑执行时碰到 ch 已经 close 的情况。  对比发现，两个流程差不多，因此 channel 的发送和接收的逻辑都是差不多的，都要判断是否为空，是否阻塞，然后看缓存情况，一个明显不一样的特征是 chansend 要判断满，chanrecv 要判断空。
我们常说Go 语言中 channel 是并发安全的，什么意思呢？从上面的流程可以发现：chansend、chanrecv、closechan 都是要加锁的。即便如此，从代码层面我们还是看不到这些锁，那我们能否通过代码来看，“并发安全”具体而言是什么意思呢？下面罗列了三者的源码：
1// chansend 源码 2func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { 3 if c ==nil { 4 if !</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译器应用（3）</title>
      <link>https://jupiterxue.github.io/go-to-top/day12-parser_app/</link>
      <pubDate>Sat, 28 Aug 2021 15:14:37 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day12-parser_app/</guid>
      <description>上期说到两种复杂的 Parser场景，通过借鉴业界成熟的技术方案，能够大大节约我们自己的时间。今天再来谈谈最后一个 Parser 应用场景和 Parser 总结。
客户定制需求  场景8，我们公司是做 ToB 的服务，我们的软件会先编译完再卖出去，比如我们公司是用 Go 开发的，假如我们是卖 gRPC 服务的，而用户想要在此基础上做一些定制，他们也有自己的开发人员，比如说实现内部的 RPC 协议。用户想定制，而我们想不给他们源代码并且能够支持他们的定制需求，这就需要些技术手段来解决。（特别是 Go 语言的生态还不是很完善，并且每个方案都有自己的缺陷）
 我们在给客户交接系统的时候，客户想要自己的 RD去做些开发工作（一般指研发工程师）。而我们知道，Go 程序需要编译成二进制文件才能使用，因此让 Go 模块去做热更新是非常难的。为了满足这样的需求，我们应该怎样来做扩展呢？业界目前有四种方案：
 RPC go-plugin REPL，社区的解释器方案 WASM  以上四种方案都有不足，具体还是要看我们在真实业务场景中能够接受哪种折中的。
RPC 中，在两个系统之间定义好交互的 API，要做扩展那么就将新系统中所有的扩展做成 API，要实现这个扩展，就在原系统中调用一下就好。但 RPC 自身也有一定性能问题，如做些网关之类的扩展就不适合。
go-plugin 在Go 1.8版本就有，但也是有缺陷的：不同版本编译不兼容。用户编译出的 plugin 和我们的原始二进制文件必须要用相同的版本去编译才能通过。
REPL，社区的解释器方案例如 gopherjs、gopherlua，这些都是不错的项目，在可以在线上去用这些东西，并给用户提供局部热更新的功能。但问题就在于，有些业务需求不一定社区有。
WASM（webAssemble）是一种不针对特定平台的二进制格式文件，也是目前比较新的方案。理论上在每个语言直接互相调用没有性能损失的，但 Go 语言版本不是很完善，所以这个方案也是在调研阶段。有些公司只是在做些宣传、
Parser 总结 OK，到目前为止，我们了解了编译和反编译工具去找 Go 程序的语法具体实现，以及用到 Parser 知识可以在实际公司的业务里面去做些探索。但说到底，如果我们掌握了编译原理的知识就能够在很多场景下找到比较灵活的方案。
对于像笔者一样大学毕业工作不久，因工作需要转到用 Go 语言，而 Go 语言入门又没多久的同学来说。大学期间我们学习编译原理感到 枯燥、困难，略有些脱离实践，因此学习得不扎实，勉强通过。而工作期间又确确实实需要这方面实打实的知识，怎么办？边做边看。既然大学的时光已经过去，一去不复返，那么能抓住的就是现在。业务上需要什么我们去看什么，同时多去逛逛技术社区和论坛，比如汇总整理了几个有意思 Parser 项目的项目：https://github.com/cch123/parser_example，将自己的技术面拓宽，尽可能地边实践，边回顾理论。
之前总结了 8 个 Parser 场景，其实我也只经历了两个的样子。经验非常受到局限，但是我们通过学习，通过学习技术前辈曹大所经历的、所见识的，就能让我们也坐上通往技术前方的高铁。不知道，不擅长没关系；先了解，多了解，以后总还有可能遇到。到时我们就不再是愁思苦想，而是胸有成竹了。
参考资料
[1] Go进行wasm编程, 博客园</description>
    </item>
    
    <item>
      <title>两个自动化管理工具</title>
      <link>https://jupiterxue.github.io/posts/2021-08-25-github_action-and-review_dog/</link>
      <pubDate>Wed, 25 Aug 2021 23:10:23 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-25-github_action-and-review_dog/</guid>
      <description>最近在写微信公众号的同时，也在同步开通 Hugo 搭建的个人博客。在曹大的课上了解到了两个开源工具：Github Action 和 Reviewdog，都是和 CI/CD 自动化相关的。而我最早是在 B 站一个 UP 主“遇见狂神说” 的 10 分钟短视频讲解中了解到的 CI/CD。惊奇地发现 Hugo 搭建的博客特别适合用到这两个工具。于是怀着特别的兴趣和好奇，去了解了一下。今天仅简单地来谈谈这两个工具的相关介绍。
CI/CD 首先，什么是 CI/CD？其实说的是三件事情：持续集成 (Continuous Integration, CI)、持续交付(Continuous Delivery)、持续部署 (Continuous Deployment)。其实这里单独一件事拎出来做也能做个不错的项目，不过三者搭配食用，风味更佳。
持续集成 (Continuous Integration, CI)，通常是指在程序员合并 merge 代码的时候不断对代码变更进行验证。一般用于集成时跑单元测试或者接口测试，如果未通过，那么工作流会用社交软件或者邮件通知相应的开发者。更重要的是，CI 流程中的测试代码既保证了新代码不会破坏老的业务功能，还保证新代码能编译通过。预期输入应该能够得到预期输出，如不符合的结果要报错飘红。
持续交付(Continuous Delivery)的目的是最小化部署或释放过程中固有的摩擦。它的实现通常能够将构建部署的每个步骤自动化，以便任何时刻能够安全地完成代码发布（理想情况下）。
持续部署 (Continuous Deployment)，是一种更高程度的自动化，无论何时对代码进行重大更改，都会自动进行构建/部署。能够将部署流程平台化，可以按照天、周、双周发布。发布只需要点一个按钮，就可以把代码部署到测试或者线上环境。并且即便每次改动都很小，部署流程也能够在有问题的时候及时发现。目前大多数公司都在使用这种流程。
GIthub Action CI/CD 持续集成可以玩很多有意思的东西，比如自动抓取数据、定期测试代码、一键打包项目自动登录远程服务器并发布到第三方服务等等。
作为全世界最大交流平台，GitHub 在这方面有一定话语，把这些操作统称为 actions。GitHub 注意到，由于许多操作在不同项目里面是类似的，且可以实现完全共享。于是想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，这样其他开发者也可以使用。如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 就好。因此，整个持续集成过程，就变成了一个 actions 的组合。
Review Dog reviewdog 是一种可以与任何代码分析工具持续集成的自动化代码审查工具，无论是什么样的编程语言都可以接入。
reviewdog 提供了一种特殊方法，通过与任何linter工具轻松集成，自动将审查意见发布到代码托管服务。它使用 lint 工具的输出，并在发现需要审查的补丁时将其作为评论发布。正如其名字所说，拥有一只能够做代码评审的狗勾，让你的代码库保持健康。
结语，后面有机会对这两个工具的使用做一个详细的介绍，敬请期待。
参考资料
[1] 【狂神说】CI/CD到底是什么？十分钟理解企业级DevOps, Bilibili
https://www.bilibili.com/video/BV1zf4y127vu?from=search&amp;amp;seid=15753722902113310493
[2] 什么是 CI/CD？Linux.cn
https://linux.cn/article-9926-1.html</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——解释器</title>
      <link>https://jupiterxue.github.io/go-to-top/day10-parser/</link>
      <pubDate>Sun, 22 Aug 2021 22:51:00 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day10-parser/</guid>
      <description>上期文章遗留了一个问题“三个 panic 在 runtime 代码的具体哪个位置输出”，如果通过汇编调试工具找出来。今天来动手实践，并且尝试解决另一个业务问题。
问题回顾  分别有三种情况的 panic：
 往已经关闭的 channel中写入数据 关闭一个是 nil 值的 channel 关闭一个已经是关闭状态的 channel   要找出它们在 runtime 代码中具体位置，首先我们先写几个小型代码，来完全模拟这几种情况。
情况1：往已经关闭的 channel中写入数据，文件名 send_to_close.go
1package main 2 3func main() { 4 var ch chan int 5 close(ch) 6 ch &amp;lt;- 1 7} 1go tool compile -S send_to_close.go | grep &amp;#34;send_to_close.go:6&amp;#34; 通过反汇编和文本搜索，找到了关键信息 runtime.chansend1(SB)
情况2：关闭一个是 nil 值的 channel，文件名 close_nil.go
1package main 2 3func main() { 4 var ch chan int 5 ch = nil 6 close(ch) 7} 1go tool compile -S close_nil.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——语法分析实现</title>
      <link>https://jupiterxue.github.io/go-to-top/day9-parsing_implementation/</link>
      <pubDate>Sun, 22 Aug 2021 08:34:33 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day9-parsing_implementation/</guid>
      <description>之前的文章提到：Go 程序编译和链接涉及到工具 go tool compile 、go tool objdump 和 SSA func build 将源代码转化成静态单赋值形式的中间代码。这些工具都可以直接上手玩一玩，即便对编译原理的理论不熟悉，在实践后还是会逐步明白的，Go 的工程化在这方面做得挺不错。今天来讲一讲“GO 语言语法分析的具体实现”
调试工具回顾 通过命令 readelf -h 可以查看 ELF 可执行文件的头信息，发现调试入口的十六进制地址码，然后用 dlv 来调试 Go 程序。
在 dlv 中，打断点有三种常用方式：
 b * 地址 b 函数名 b 文件名:行数  指令 c 是从一个断点跳到另一个断点。如果打多个断点，那么可以做连续代码的跳转。
指令 si 是单步调试，调试汇编时常用于使用 si 到 jmp 目标位置，即一步步跳转。
我们用工具 go tool objdump 来做反汇编，而它输出的是 plan9 形式的汇编。其实在 dlv 中内置了反汇编工具，disass，不过它输出的是另一种形式的汇编。这里，我们可以掌握多种调试工具，平时就用自己擅长点的，而遇到了没弄明白的，也许另一个工具换来使用有不一样的效果。
之前我们都是遇到问题搜资料，我想系统学习 dlv 怎么办呢？就像上期文章讲到的，还是去看官方文档：https://github.com/go-delve/delve/tree/master/Documentation/cli
简单浏览一下官方文档可以发现，官方也在逐步添加新的功能。比如说，现在有一个地址，我可以直接用 dlv 中的 x 指令查看一段连续内存里存储的值，这个有点像 gdb 中的 x（另一个调试工具，用于查看内存地址的值）。这个指令在 runtime 中有些开头是 len，然后跟着 unsafe pointer 之类的，我能看到 unsafe pointer ，但它后面的结构直接调试可能看不到，这时候用到 x 指令就可以看到它后面内存里存储的是什么值了。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——反编译</title>
      <link>https://jupiterxue.github.io/go-to-top/day8-disassembly/</link>
      <pubDate>Sat, 21 Aug 2021 15:25:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day8-disassembly/</guid>
      <description>Go 语言常用的两个查看汇编代码的工具是 go tool compile 和 go tool objdump。上期文章说到通过 go tool compile -S 可以查看实现相同功能，两个不同的代码在性能上有什么区别，可从反编译出的汇编代码看出，二者的性能一样。今天再来聊一聊另外一个工具的使用。
 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？
 在解决这种类似问题之前，我们其实可以查阅官方的资料 spec，国外源地址：https://golang.org/ref/spec ，国内看这个：https://golang.google.cn/ref/spec
这个 spec 讲述了 Go 语言内部的语法可以怎么用。在 spec 中出现的东西，也就是官方认为是正确的东西。而如果一个用法没有在 spec 中提到，那么我们就没有办法去依赖输出结论。
举个例子，我们用到一个函数，这个函数用到了指针和 Error，如果这个返回的 Error 是非空的时候，我就不能依赖它的指针返回值。我们要依赖这个值，就需要 Error 是空。这种情况就是语言的确定性，如果我们依赖了有 Error 的结果，那么就是非确定性的。这个非确定性，我们会经常看到一个名词叫做 Undefined Behavior。我们初学 Go 语言，或者习惯于写动态语言，如 Python 的同学，会非常依赖这种写代码习惯，这其实是非常危险的。它可能会给我们带来隐藏的线上 Bug，很多时候都是难发现的，特别是在做语言 SDK 升级的时候，可能会导致比较严重的问题。
所以我们要去查询 Go 语言内部的函数或者结构的用法的话，一定要去看官方的资料。不要去看网上的博客来作为自己的结论，因为别人写的不一定对，尤其是当我们使用了错误的博客内容来操作，会给业务带来更多麻烦。
OK，打开 spec 网址，我们来看看，哥们，你这瓜多少钱一斤？
spec 告诉我们，make 可以用在三种结构上的：slice，map，channel。也就说明，我们要研究 make 的实现，就去看这三种结构上执行 make 具体会执行哪个函数就好。
我们来实现这段代码，文件名为 make.go
1package main 2 3func main() { 4 // make slice 5 // 空间开的比较大，是为了让这个 slice 分配到堆上。空间小的话会默认分配到栈上，而栈上的 slice 和堆上的 slice 底层实现会不一样。 6 var sl = make([]int, 100000) 7 println(sl) 8 9 // make channel 10 var ch = make(chan int, 5) 11 println(ch) 12 13 // make map 14 var m = make(map[int]int, 22) 15 println(m) 16} 1&amp;gt;&amp;gt;&amp;gt; go build make.</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译与反编译</title>
      <link>https://jupiterxue.github.io/go-to-top/day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day7-assembly/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。
重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。
 Quote
 1package main 2 3func main() { 4 5} 具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）
编译与反编译工具 我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。
1go tool 这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：
 几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。
 再让我们看看这两句指令在具体场合下都是什么意思：
 go tool compile -S main.go # 反编译代码为汇编代码。
  go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）</description>
    </item>
    
    <item>
      <title>性感、美食和学术？</title>
      <link>https://jupiterxue.github.io/posts/2021-08-18-sex-research/</link>
      <pubDate>Wed, 18 Aug 2021 22:01:22 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-18-sex-research/</guid>
      <description>当我们的开始看论文、接触到学术研究后会形成一个感知：科研工作往往都是在进行复杂的实验、写出带有各种样式的图表和复杂的数学公式，最终生成的长篇大论。但今天我彻底颠覆了这一刻板印象——做科研也是“性感”的。？？？对，你没有看错，今天想来讨论中国知网推出的《研究生科研素养提升》系列学术讲座的其中一期。
介绍 这期讲座是在 2021-08-18 15:30~17:10 开展的。主讲人是北京交通大学教授、博导师，华国伟。他的主讲题目是《做最“性感”的研究》，一看到题目，是不是就觉得有点意思？
华老师开篇讲到，“性感”这个词常用于表达吸引异性的场合，而他的讲座并没有这个裸露的含义，而是隐喻：我们做学术也可以吸引其他做学术的人。同时，华老师还提到了一个小故事：
 有本书，名叫 《How to change your wife in 30 days》，一个星期之內售出200万本。直到作者发现，书名拼写错误，正确的应该是： 《How to change your life in 30 days》。改正后整整一个星期，只卖了3本。
 华老师希望我们来听他的讲座不是因为他的主题名字吸引了我们，而是真正对科研感兴趣，对科研是“性感”的、如何做好科研这个话题感兴趣来听的。
华老师为了做这场讲座看了许多论文和书籍，也推荐我们去看两本书：《靠近点 科学史最性感的世界观》、《性感的公司》
然后明确了这期讲座的三大言简意赅的提纲，向我们提出了三个问题：
开始正经 好，华老师开始正经地讲授科研了，大家严肃一点！
（缓冲区）
（缓冲区）
（缓冲区）
同学们，我们做学术是要有预期的，最开始我们是&amp;hellip;
不敢相信，这是科研讲座？？
哎呀呀，同学们，你们一定要记住，科研的三条秘籍：勤奋！勤奋！勤奋！连最聪明的人都在用着这个最笨的办法，但这还不够，做科研还要 欲望！冲动！血脉喷张！
这。。。我们做科研要像毛！血！旺！
小插曲 由于其他同学听得太用心，已经开始产生了幻觉，上演了一场买瓜好戏？
知网官方：同学们不要讨论其他与学习无关的东西
那么你的问题来了，买大西瓜还是小西瓜合算呢？
（两块钱一斤！哈哈哈，作为理科生的我，羞耻地去搜了搜答案）
做有价值的工作 华老师对我们科研宝贝们的论文比喻简直了，一个字，绝！
看论文我们要看看国外是怎么做的，这又会遇到一个问题：
（这么一堂科研学术讲座，活生生地做成了一趟美食之旅，让公屏后面的同学们都馋哭了吧）
写论文的要点，老师比喻地真是无懈可击。
我们看到数字对比能更加敏感，看到图片能够直观感受，听到老师的段子会忍不住哈哈大笑。
引用的故事在老师讲起来真是太搞笑了吧。
以上都是在听讲座过程中随手截取的图。
最后，华老师以优雅的姿态结束了本次讲座，惊艳了我们所有人：
（华老师结语祝福，希望你能看懂）
为什么这堂讲座口碑这么好 华老师在课间答疑说道：这个 PPT 其实在 2008、2009 年就有了，但新书一直都没有憋出来。也想出一个课程，希望能够对大家感兴趣、有困难的科研部分提供一些帮助。并且在这次讲座之前已经有300页的 PPT 内容，近好几个小时的演讲量。而为了这次讲座，将 PPT 极力压缩到了 80 页左右，为期 一个半小时讲座时间内完成。
后来，我思考了为什么华老师的讲座口碑这么好？华老师在讲授期间金句频繁，绘声绘色、有段子还有图片。背后是老师长达十多年的积累、对生活的热爱、对时尚潮流的关注以及对科研最崇高地尊敬。虽然老师有的比喻不是很恰当，略有点直白和低俗，但可以发现老师将他科研毕生所学的抽象概念都融汇在了我们生活点点滴滴的真实案例中。我们缺少阅历，但并不妨碍我们能够像老师学习，学习换位思考，尽可能地去设想另一个学者、编辑、作家、医生在想什么、做什么。并且我们能够在华老师这么一堂声色俱佳的讲座上重新捡回做科研那份初心，始终不忘如何探究、如何概括和总结。
最后，讲座不用我强烈推荐了吧，看图就好了，记得关注老师的微博“我是华国伟”，关注老师出书和课程的最新动态。放一下讲座 《华国伟 - 做最“性感”的研究》源地址：https://k.</description>
    </item>
    
    <item>
      <title>写技术文章的要点</title>
      <link>https://jupiterxue.github.io/posts/2021-08-16-tech_write/</link>
      <pubDate>Mon, 16 Aug 2021 22:52:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-16-tech_write/</guid>
      <description>磨刀不误砍柴工，程序员在写代码、写文章之余还是值得去了解重构代码、测试代码、如何写文章等辅助性的技能，虽然有时有点务虚，但从长远看却是实打实地有用。今天讨论的主题是“写技术文章有哪些要点”。
首先，我们需要对技术文章进行一个分类：
 知识总结。  比如你在公司内想要做个什么系统，你不知道，就去 Google 用英文搜一下。把第一页都消化吸收了就能出一篇总结性文章了（也就是老板常说的去调研一下）。业务问题 → Google 搜索 → 消化内容 → 总结 最近对流式计算感兴趣，我也可以 Google 去搜 &amp;ldquo;stream processing&amp;rdquo;，不过搜出来的知识点都比较零散。而我想要更完整的知识体系，那么我就去亚马逊搜书 &amp;ldquo;stream processing&amp;rdquo;。大致了解到有哪些关键词后，我们就去更加专业的渠道去阅读它——learning.oreily.com/library，然后就可以输出笔记了。 流式计算感兴趣 → 读书 → 读书笔记。   项目总结。  公司项目 → 完成之后 → 调研更高级项目 → 复盘总结。 公司问题提炼。业务脱敏，只把关键技术部分整理出来 → 输出。   教程指引。翻译官方文档，补充一些在使用时候会遇到的坑。  Yutube 上很好的国外的视频分享 → 怕忘记、感兴趣 → 结合自己的理解记下来。 内容翻译。medium，lobster，acm 里不错的新论文，acm queue，macm 杂志上的文章，都是不错的翻译目标。    小插曲：注册 ACM 会员再用同样的账号去注册O`reily，能够免费阅读里面大部分的书。价格为 25 刀，可以搞个双币信用卡呀，招行就行，现在学生账号可能不行了，不过用绑了 paypal 的卡就行好像。
 如果对电子书不排斥的话，目前比较经济的选择是申请一个国内的 ACM 会员，并且用该会员去注册oreily 在线书店。一年大概 20 美元，可以及时地阅读到大部分出版社的技术出版物。因为现在出版社的网站大多还支持 early preview，所以你甚至可以在书籍还没有上市之前就预先学习内容，第一时间获取整个业界的一线情报，能够帮助你站在时代的潮头。——曹大</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>https://jupiterxue.github.io/go-to-top/day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day6-parse/</guid>
      <description>上回我们说到 8 个常见 Go 业务场景，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础”
回顾 Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，我们可以通过这句代码，编译一段简单的 “Hello World！” 程序看到：
1go build -x hello.go 编译原理基础 我们可以把编译分为两个部分：编译器前端和编译器后端，如图所示：（这些都是我们软件工程专业课上的基础知识）
**词法分析（Lexical Analysis）**是计算机科学中将字符序列转换为标记（token）序列的过程。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 println(1 + 2) 7} 我们这里有一段简单代码，通过词法分析的方法，转化为 token 就是如下结果：
我们在 Go 语言中没有分号，但其实像很多其他编程语言一样，是需要的。
语法分析（syntactic analysis，又称 parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。当我们对 Go 源代码进行词法分析后，会形成上图的 token 流，我们想要把这个再转换成汇编还是不行，还需要转换一步，转换为另一种数据结构——AST 语法树，才能够用计算机的逻辑去处理。
抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。
这里提供一个在线编译 AST 的网站：https://astexplorer.net/，将上面的代码粘贴进来，就可以发现如下结果：
左边是代码，右边会把所有代码相应地转换成了树结构呈现出来。（建议大家动手玩一玩，里面会有语法高亮和代码与树一一匹配的功能。如果未来你有机会写一些解释器，很可能会用到这个）
语义分析（Semantic Analysis）是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。比如我们写了类似这样的代码：
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var x int = &amp;#34;abc&amp;#34; 7 println(x) 8} 作为一个找茬小能手（当然不是买瓜），可以发现，字符串 &amp;ldquo;abc&amp;rdquo; 是不能赋值为 int 变量 x，这时候我们直接编译 go build 就会出现如下问题：</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>https://jupiterxue.github.io/go-to-top/day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day5-problem/</guid>
      <description>上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调试啊。关于业务，写代码当然可以，而当我们面临性能问题时，就需要涉及算法与数据结构。糟糕，你一说到算法我就心虚。如果你算法基础薄一点，没关系，东方不亮西方亮，算法走不通，我们走查看修改底层代码做起，仅需要细心和逻辑推理就能解决部分问题。因此，今天的主题是“探究 Go 语法背后的秘密”。
常见业务场景 你说写业务不用关心底层，OK，那我们今天先讲原理，直接上业务场景。
场景1，这两段代码运行速度怎样？第一个比第二个快？
1// 代码1 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var a = &amp;amp;person{111} 10 fmt.Println(a) 11} 1// 对比代码2 2package main 3 4type person struct { 5 age int 6} 7 8func main() { 9 var b = person {111} 10 var a = &amp;amp;b 11 fmt.Println(a) 12} 场景2，类型转换的原理是怎样的？
1package main 2 3func main() { 4 var a = &amp;#34;hello&amp;#34; 5 var b = []byte(a) 6 println(b) 7} 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？</description>
    </item>
    
    <item>
      <title>七夕荐电影《当男人恋爱时》</title>
      <link>https://jupiterxue.github.io/posts/2021-08-13-when-man-love/</link>
      <pubDate>Fri, 13 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-13-when-man-love/</guid>
      <description>明天就是七夕节了，本来今天应该更技术文章，暂时放一放，让美好暂留一天，今天来聊一部爱情电影。
爱情并不完美，而爱情电影往往都是那么天真浪漫，这和现实生活产生了巨大的冲突和矛盾，即便如此，依就阻止不了我们对于美好爱情的向往和憧憬。《重庆森林》已经被我看过4、5遍，里面没有讲述重庆、也没有讲述森林，而当你想恋爱了、当你失恋了，这部电影就很贴近你的生活，就和你有关系了。即便是1994年的老电影，至今 2021 年仍然爱不释手。但今天要说的不是《重庆森林》，而是另一部听名字就有点意思的电影——《当男人恋爱时》。
发现 最初了解到这部电影的时候是无意间看到的一篇影评，2021年6月11日在中国大陆上映了电影《当男人恋爱时》[1]，这篇影评不仅讲述了电影中的情节，还将另外一部于2014年1月22日上映的同名电影的故事情节和剧照都晒了出来。真的是没有对比，就不会知道自己喜欢哪个。当我一看到这副剧照，我就知道，我喜欢老版本的电影！（左图）
感受（略有剧透警告） 这是一部出产于韩国出产的电影，我们都知道前些年，韩国在爱情无论是电影还是电视剧上都是比较俗套的，但这个俗套不是贬义，而是说韩国做的挺好，对于爱情剧情的理解以及形成了套路。虽然抱有一点，烂俗韩剧的心理去看电影，但看完之后真的让我忍不住想推荐，尤其是很难找到那么清新脱俗的痞子。
剧中饰演男主的黄政民，是个混混老大，但他看起来并没有我们刻板印象中的傲慢不羁或者凶神恶煞。而一如反常的是呆萌的形象，你能想象，兔子生气了冲撞你吗？哈哈。不过确实，黄政民大叔在剧中的代入感真的太强了，从收租要钱打架斗殴，到温文尔雅绘图签字，再到二人对视哭泣，每一幕的演技都细致入微。前部分塑造的粗犷暖男形象，和后半部分营造出的密集泪点效果都简直出神入化。就像一位评论者所说：“来为黄政民大叔写个影评 这片要是换个帅哥演，我真不一定看。 ”
剧情我就不介绍了，仅用几句电影中的话，来表达我在整个电影的直观的感受：
 喂！我都说爱你了，你什么感觉都没有吗？！
  哥，你倒是知道什么是爱情吗？最起码不是这样的，以后利息钱我会汇给你，不要再联系了！
  以前其实我差点结了婚的，但是我他妈的给搞砸了
  （花大钱给妹妹买了新的店外装饰）这是我妈给你的（钱），怕你没钱用，说要跟我爸保密。。这是我把给你的，还说要更我爸保密。。我爸我妈完全不沟通，这是个事啊。
  （一边吃着泡面一边和他爸爸交待身后事）因为她是您儿子这一生最爱的女人啊
 原本我以为爱情电影都是这样的狗血，剧情都会多少有煽情、有泪点。已经有心理防备的我，在感受到剧中男主女主面对面那份伤心时，也忍不住眼睛红了。我想，如果你是个泪点低的，那么这部电影真的可以算上，好好哭。
总之，这是一部很 man 、很直男、很浪漫、很悲催而又很美好的爱情电影，至今也让我回味无穷，所有的剧情可能都忘了，但还是忘不了看起来萌萌的男主说出的那句表白的话：“我爱你，妈的”。 哈哈，真是率真又可爱。
最后，可以去豆瓣点个在看，点评一下看过的电影或者看过什么书。如果你和我读过、看过的有相同，那可真是幸运，欢迎关注我的书评、影评：Jupiter 的个人主页-豆瓣
资料
[1] 台韓男人的浪漫大戰？《當男人戀愛時》與原版《不標準情人》有何不同？穆光光, marieclaire, 2021-05-03
[2] 当男人恋爱时, 豆瓣
[3] 如何看待黄政民在电影《当男人恋爱时》中的表演？知乎
[4] 影迷评《当男人恋爱时》：演技精湛 催泪感人, 新浪娱乐, 2021-06-08</description>
    </item>
    
    <item>
      <title>论—如何看论文与写技术文章</title>
      <link>https://jupiterxue.github.io/posts/2021-08-12-write/</link>
      <pubDate>Thu, 12 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-12-write/</guid>
      <description>最近成长会的小伙伴推荐了一个系列讲座“2021年“研究生科研素养提升”系列公益讲座”，看到这个题目，不禁联想起自己大学最初的梦想，如果，如果没有当初也便没有现在的自己，就不多说了。翻了翻里面有哪些主题的课程讲座，发现最让我感兴趣的是徐铭梓老师推出的“中国知网辅助论文读写效率提升”，今天讲的主题就是“论—如何看论文与写技术文章”。
这里又不得不提及，在我们成长会中，每年 Scalers 老师都会亲自带队，在为期几个月的时间内带我们进行专题性阅读。什么是专题阅读？比如这期的主题是“经济学”，我们会从曼昆的《经济学原理》的微观与宏观开始看，再到《经济思想史》和《解读中国经济》。像《经济学原理》都是经贸领域同学的本科专业教材，都是大部头，不过我们也是按照每天一章、两章的阅读量在阅读。光阅读还不够，我们每天还会回答 S 老师布置的问题，当天看书当天答题，我们社群有个全新的文化——日毕。我参加过几期这样的专题读书活动，也深刻感受到 S 老师出题之深刻，就比如：调研和概述中国近20年的财政情况、股票市场是否存在稳赚不赔的方法、2018年中美贸易摩擦到现在的变化情况，以及搜集近五年政府工作报告分析财政与货币在政策上的变化等。这些问题无一不是好几篇研究生甚至博士生所研究的问题，因此我们在回答这些问题的时候会经常性地去关注学术论文是怎样看待这些问题的。
既然要看学术论文，有没有什么常识或者说常用的套路呢？回到最开始提及的那位老师，徐铭梓。我好奇地拿着她的名字在谷歌上搜了一下，没想到直接找到了她在去年4月份在知网上发表的一篇免费教学PPT——《论文阅读与写作入门》，里面详细地讲述了作为一个科研人员，需要保持什么样的做学术和看论文的正确理念，分类地讲述了不同段位的研究者应该从哪里、看什么、怎样看论文，详尽地阐述了论文的基本阅读方法。
然后徐老师又说到了笔记与文献的摘录，她引用了梁启超先生的一句话：
 读书莫要于笔记，朱子谓当如老吏断狱一字不放过， 学者凡读书，必每句深求其故，以自出议论为主，久 之触发自多，见地自进，始能贯串群书，自成条理。 经学、子学尤要， 无笔记则必不经心，不经心则虽读 犹不读而已。
什么方法呢？极笨极麻烦的， 抄录或笔记 ——梁启超《读书分月课程·学要十五则》
 这里让我联想起了，我们程序员应该怎样来写科技文章。最近在 Go 技术群里，在热烈地讨论一个问题“作为程序员，自己知道点东西，但写着就感觉别扭，于是就写不下去。并且大多时候都像是知识储备不够，每次都感觉在抄袭别人的”，大家都表示同感，毕竟东西就是那些。还有有些同学自我安慰道，就觉得是把别人的文章用自己的话说一遍，把别人画好的图自己再画一遍。
在我们群里的技术巨佬，他们是怎么说的：
  把别人文章中的图自己画一遍，不算盗图，并且自己画一遍挺好的。
  程序员写文章整段整段贴代码不合适，贴出来关键核心代码就可以了，然后重点的是要有一些提纲，例如你分析过程，总结这些。
  总的来说，一篇优秀的技术文需要有：
 取好标题，醒目突出中心
图文并茂，适当配图说明
篇幅适宜，不宜过短也避免冗长
格式统一，基本排版规则需要遵守
细节处理，错别字标点处理正确。
   是的，就像我所喜爱的作者王垠所说“每次仇恨一个东西，你就失去了向它学习的机会。”，我们普通人没有经过专门的写作训练，面对一下写几千字是比较困难的，更难得说输出技术文章。在我看来，学习技术都是从模仿开始，不要介意抄袭别人的，不要介意别人已经做过了，要亲自动手，事必躬亲。你要清楚地知道，那是别人的东西，不是你自己的，就像那是装在别人兜兜里的钱，不是你自己能使用的。
关于《论文阅读与写作入门》我就不继续展开来讲了，如果你有兴趣，就去探索吧！好奇心，能够让你学会更多知识与技能！</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试2</title>
      <link>https://jupiterxue.github.io/go-to-top/day4-run/</link>
      <pubDate>Wed, 11 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day4-run/</guid>
      <description>上回我们说到，利用调试工具 readelf 读取我们在 Linux 上编译的可执行文件 hello，并且找到了查看 Go 底层的入口 entry point address，今天我们尝试踏进底层调试的大门，看一看我们平时所说的底层，是否真的很困难，今天的主题是“初探Go底层”
[toc]
实验环境与回顾  操作系统：CentOS 7
Go：1.14.12
调试工具：readelf、dlv
 这里我们同样运行曹大提供的实验环境，并且挂载映射到本地项目，然后进入到这个容器环境中。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 4# 进入项目目录 5cd /project/work/ch01 6# 查看文件 7ls 8 这里的绿色 hello，就是我们 Go 语言编译后产生的 ELF 格式可执行程序（ELF 不知道是什么，可回顾上期文章）
我们一般通过工具 readelf 来找到进入可执行程序底层的入口 entry point address，通过以下命令来实现，这里的 -h 表示去读取 header
 -h &amp;ndash;file-header	Display the ELF file header
 1readelf -h hello 开始底层调试 当找我们通过 readelf 找到了调试入口的十六进制地址码，我们还需要用另一个工具 dlv 才能来调试 Golang 程序。再次之前，来简单说明一下什么是 readelf、什么是 dlv。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>https://jupiterxue.github.io/go-to-top/day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day3-run/</guid>
      <description>今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我一步步走肯定都能理解。
既然要进行代码实践操作，首先要考虑的就是Go语言编译器（也就是Go）、Go 编程环境以及 Go 代码的调试环境，这里我们需要用到的版本：
 操作系统：CentOS7 或其他 Linux 环境
Go：1.14.12
Go 调试工具：readelf
 是不是有点复杂？如果版本和我的不一样，那么实验结果可能不一样。如果版本比较低，有的工具需要自己去找旧版本的去匹配安装。那有没有什么办法可以简化这些实验环境的搭建呢？用上容器技术——Docker。简单说，当你用 Docker 的时候，就像在自己的电脑中装上了我所说版本的实验环境，里面包括了上面所说的所有东西。你可以用我给出的定制环境（我们称之为镜像），也可以用其他人给出的定制环境，并且可以做到无缝切换。就这么说，在你的 windows 上可以运行 CentOS、Ubuntu，甚至还能在 windows 上运行一个微型 windows，是不是很神奇？OK，我们说回今天的实验，在开始之前希望你能去了解 Docker 是怎样操作的，这里推荐我非常喜爱的 B 站 UP 主“遇见狂神说”推出的 Docker 教程。好，就当你已经会基本操作啦，跟我开始敲代码了：
 搭建实验环境  1docker run -it xargin/go1.14.12-dev bash 这里我们运行了曹大（曹春晖）提供的实验环境，并且进入到这个容器环境中。但是存在一个问题，我们在这里面写的代码在这个容器销毁后就没有了，所以我们需要对容器做一个映射，在容器中写了文件，在我们本地也有一份记录。
1# 挂载目录，文件也可以生成 2docker run -it -v /root/project/dockerProject:/root/project xargin/go1.14.12-dev /bin/bash 3 创建目录与文件  在home目录下创建文件夹所有实验目录 work，创建第一个实验目录 ch。（这里的样式和大家不一样是因为 安装了 zsh ，你不一定也要按照，如果感兴趣，请自行搜索安装，当前配色主题是 ys）
实验环境准备完毕。
编写一段简单代码  我们来打开一个叫做 hello.go 的文件，写一段我们最熟悉的代码：
1vi hello.go 1// hello.</description>
    </item>
    
    <item>
      <title>微信公众排版</title>
      <link>https://jupiterxue.github.io/posts/2021-08-08-wxpb/</link>
      <pubDate>Sun, 08 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-08-wxpb/</guid>
      <description>已经开通微信公众号两周了，但公众号的发文机制和排版机制让我有些头疼，今天来探讨一下——微信公众号的排版与运作机制，先列出我在这里写作最直观的感受：
 不能用 Markdown 写文章，识别不出来，空行也会被解析掉。 一天只能发布一篇文章，第二天才有新的可发布量。 可以修改文章，但修改后的关注公众号的读者看的文章还是以前的文章。 修改后想让读者看到，就需要重新发一篇，以前的会保留。  所以我的问题来了：
 文本输入不能支持 Markdown 语法那支持什么语法？还是说有什么办法可以转化？ 一天只有一篇文章的发布量，是否有什么方法增加发布量？或者说有预发布功能？ 想要修改文章、能够让读者看见，又不减少发布量，有可行的方法吗？  作为程序员，我们一般习惯用 Markdown 来写文章，因为排版的方式有点类似于代码的方式，并且操作的方式也类似于编码的方式，有快捷键、能插入不同语言代码。如果你想试用，这里推荐你试用一下 Typora，一个看起来非常的美观的基于 Markdown 的编辑和预览器，这个软件还有一个视图查看方式就叫做“源代码模式”。但是问题就出在，直接复制用 Markdown 写好的源代码文章，粘贴到微信公众号却不能直接识别出来，里面的文本和标识符识被识别为了纯文本，空行没有了，文字上的超链接没有了，图片也没有了。真的有点，气急败坏。然后尝试直接复制 Typora 预览模式下的文章到公众号。确实效果达到了，但也出现了一个问题：用了引用的格式却不能删除、多复制了几段空行却不能删除。又是气急败坏，去找了下解决方案，一开始找到了网站 Mardkown 转 微信公众号，经过一次尝试发现有的图片没有加载进去，遂放弃。后来几经折腾发现还是这个网站有用。第一次真的眼睛瞎了，为啥没尽早用到！！
官方怎么说 下午的时候对以前发过的公众号文章做了修改，但是只有自己能够看到。已经关注的粉丝（粉丝竟是我自己）查看文章还是原来的样子。所以去看了看一些资料，惊奇地发现，能改内容，但是：
 已群发的图文消息可以修改，其他类型消息暂不支持。每篇图文支持修改1次，且最多可以修改10个错别字（注：标点、英文、数字、空格都计算在内），支持增删。 如果要修改需要：登录微信公众号电脑端 → 首页 → 已群发 → 消息列表 → 悬停点击已群发单篇图文上有个“改”的按钮，点击即可打开修改页面，修改提交后需要管理员微信扫码验证。 微信官方希望每条推送都是公众号运营者深思熟虑的结果。秉承对读者负责的原则，更好的保证用户的阅读体验，修改五个以下的错别字也是为了尽量避免出现重复阅读时内容上前后不一致的情况。 推送到用户端的内容无修改权限，不仅仅是为了尊重用户前后一致的感知，技术上也不能对用户端的内容做修改。 有两种情况无法修改：一、辟谣：文章被发起辟谣且待审核或文章被发起辟谣且审核通过；二、已删除的文章。  总之，写公众号都是在每次深思熟虑之后再写，并且今天在探索后发现，还有预览的功能。
最后的最后，不要水微信公众号，不然又浪费一天 （的发布量）：）。
一些常识和技巧  不加首行缩进。 默认微信字体 16 号，建议用 15 px。粘贴字体进入微信后，先全选“清除格式”（或者 Ctrl+shift+V，直接祛除格式粘贴），就会变成微信默认字体，再选中 15 px 字体 间距 1.5 当文字之间有图片时，上下空一行。给受众呈现更好的阅读体验。 段落保持在三思行。 两端缩进。更适合手机阅读，看起来更有质感。但不太适合代码阅读，因为展示面小了点。 GIF动图。保存动图时需注意格式应为GIF格式且不能大于2M。 永久链接。即预览文章，如果需要别人帮忙改，预览的链接具有时效性。所以去用户界面找到自己的微信，把你想要预览的文章发给自己即可【注意:48小时内自己与自己的公众号互动才行】  常用编辑器好用推荐   秀米 主要用。 有非常多的漂亮模板，可以粘贴全部或部分。</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day2</title>
      <link>https://jupiterxue.github.io/go-to-top/day2-scheduler/</link>
      <pubDate>Thu, 05 Aug 2021 14:45:19 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day2-scheduler/</guid>
      <description>上回说到 Go 的调度流程本质上是⼀个⽣产-消费流程，今天来讲一讲“调度组件与调度循环”，再来回顾一下两个生动的动画 goroutine 的⽣产端, goroutine 的消费端。
当 goroutine 处于生产端时，M 执行调度循环时，必须与一个 P 绑定。并且我们常说的 Work stealing 就是说的 runqsteal -&amp;gt; runqgrab 这个流程。
当 goroutine 处于消费端时，执行的是一个循环：runtime.schedule → execute → runtime.gogo → runtime.goexit → runtime.schedule（回到原点），并且最终 P.schedtick = 0。
初学 scheduler 对于以上的流程感受是比较浅的，再来看看这些符号所代表的含义，就能更好地理解了：
 G: goroutine，计算任务。由需要执行的代码和其上下文组成。（上下文包括：当前代码位置，栈顶、栈底地址，状态等）
  M: machine，系统线程，执行实体，想要在 CPU 上来执行代码，必须有线程，与 C 语言中的线程相同，通过系统调用 clone 来创建。
  P: processor，虚拟处理器，M 必须获得 P 才能执行代码，否则必须陷入休眠（后台监控线程除外），你也可以将其理解为一种 token，有了这个 token，才有在物理 CPU 核心上执行的权利。
 上面所说的循环调度流程，都是在正常情况下运作的。而实际业务中我们往往还会遇到其他情况——阻塞。如果程序中有阻塞，那么线程不就全部被堵上，程序就卡住了么？
让我们来看看以下几种情况，在线程发生阻塞的时候，是否会无限地创新线程？（并不会）
案例1：
// channel send: var ch = make(chan int) ch &amp;lt;- 1 // channel recv: var ch = make(chan int) &amp;lt;- ch 案例2：</description>
    </item>
    
    <item>
      <title>如何在 Go 高级工程师训练营生存</title>
      <link>https://jupiterxue.github.io/posts/2021-08-04-how-to-survive-in-senior-go-class/</link>
      <pubDate>Wed, 04 Aug 2021 14:42:49 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-04-how-to-survive-in-senior-go-class/</guid>
      <description>前言 大家好，我是 Jupiter，目前从事的是 Pyhon 和 Go 的后端开发，现在是我们 Go 高级工程师第一期的学员，也是 3 班 7 组的组长。这周三的时候谢大邀请我来做个学习交流，很荣幸能有这样的机会给大家做个这样的交流。
一听到第一期学员，大家是不是觉得很厉害的样子。啊，没错，面向谷歌编程，复制粘贴代码的能力还是挺厉害的。不是，这期训练营教会我的当然不是复制粘贴那么简单，而是一个全方面的提高、一次格局拓展的经历。
像大家一样，看到有这么一个大咖云集的训练营，曹大、谢大、askuy、小 R 大（额，这里有的套娃）、听闻、邓大明、博锋，已经热血沸腾。再看了看价格，也不算很贵。相比于出门左转右转看到的黑马达内千峰，在价格上已经比较低了。机不可失时不再来，如果要问还有没有下一期，那可能我们第二期可能就是最后一期，嗯，最后一个第二期。
制定学习计划 在这次训练营开始前 5 月初时候，我是有点焦虑的。我是从 Python 转到 Go，几乎是没有什么 Go 基础，而这个训练营是面向 Go 高级工程师的。好像大家常见的语言转换和零基础，都被我撞上了。好在开营还有十多天，我做了两件事，让我在后面的学习节奏保持一个相对稳定的状态。
第一个就是制定学习计划。为期四个月的时间，120天，我很期待这期间所能够发生的许多奇妙化学反应。像往常一样，课前XXX，课中XXX，课后XXX。
课前：
   学习工具：搭建好环境、购买好 tizi 和相关工具 预习：把曹大推荐资料都读完，课程大纲自己绘制熟悉于心 问题：每次提前阅读完材料，一定要带着问题去听直播    课中：
   社群：积极参与任务，主动担当队长、副队长、主动去整理资料告知信息争做小助手 社区：每日浏览 GoCN 新闻，浏览关注的Go博主公众号和 Up 主视频 直播课堂：每次直播课都准时到，积极参加回答 大佬：多和老师曹大、助教、谢大沟通    课后：
   整理课堂笔记，发知识星球或者成立小组。整理出 github 博客 每次作业最迟第二天完成，不拖到第三天。 每天掌握一个面试问答。需要记录下来，整理出 github 博客    当然还不止这些，我还用到了风险管理与保险原理的一些方法。我向自己提问，风险有哪些？防控措施有哪些？</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>https://jupiterxue.github.io/go-to-top/day1-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/go-to-top/day1-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只是看作者如何挖掘。
Golang 四座大山 作为 Go 语言进阶的一个标识，是磕磕绊绊地翻过 runtime 四座大山，包括：
 Scheduler	：调度器管理所有的 G，M，P，在后台执行调度循环
Netpoll	：网络轮询负责管理网络 DF 相关的读写、就绪事项
Memory	：当代码需要内存时，负责内存分配工作
Garbage	：当内存不再需要时，负责回收内存
 而这些模块中，最核心的就是 Scheduler 调度，它负责串联所有的 runtime 流程。“要去到哪里,就从哪里开始”，既然选择学习 Golang，我们就直面这个第一个难题。
调度器的发展历史 如果你学习数学感觉困难，那么可以去读数学史。如果学习 Go 语言调度感到困难，那么我们先老了解调度的发展历史。再反过来想一下，如果你是一个领域的专家，是否应该比较熟悉该领域的发展历史？ 哲学家培根说过：“读史使人明智，读诗使人灵秀，数学使人周密，科学使人深刻，伦理使人庄重，逻辑修辞之学使人善辩“。那么就开始我们的调度器发展史：
什么是调度1,2 举个例子，十字路口的红绿灯，就是一种调度系统。因为车速过快，人工去做疏导指挥的效率太低而采取的一种自动化的处理流程，为了限制这些车辆不随意行驶，便有了红绿灯调度系统。 Go 调度是为了多个协程能合理的利用线程。这里的协程（goroutine）相当于车辆了，线程相当于十字路口。程序在运行时，会运行很多协程 goroutine，也就是我们常说的并发，为了保障这些协程能够有序快速地在线程上执行，这时候就引入可调度 Scheduler。 一个简短的例子 每当我们写下这样形式的代码，到底发生了什么事情呢？
1go func() { 2println(&amp;#34;hello world in goroutine!&amp;#34;) 3} 这里我们是向 runtime 提交了一个计算任务，并且 func() { xxx } 里包裹的代码，就是这个计算任务的内容。 Go调度流程的本质 也许这里还不清楚，但请记住，Go 的调度流程本质上是一个生产—消费流程。在后面的讲解中你会更加深刻了解到这句话的深意。 这里有两个动画便于你理解：
Goroutine 生产过程3,4
Goroutine 消费过程
想要学好编程，就需要下功夫，多投入时间去理解与实践。想要学好 Go 语言，就需要跋山涉水，为你我愿意翻山越岭。 （未完待续）</description>
    </item>
    
    <item>
      <title>从“名家谈写作”我学到了什么</title>
      <link>https://jupiterxue.github.io/posts/2021-08-02-learn-from-top-writer/</link>
      <pubDate>Mon, 02 Aug 2021 09:36:25 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-08-02-learn-from-top-writer/</guid>
      <description>下定决心想要做好写文章的习惯。给自己树立的目标是先行动起来，并且完成不那么困难的事情，当行动系统建立起来了，当日毕日更做到了，再是说更高的目标，更宏远的理想。
我创立这个公众号与技术博客（后续会开通）的原意在于做些技术分享，并且坚持更新，在一个领域中做到扎根与深入。我也清醒地认识到，这个目标过于长远，还得从长计议，因此目前的计划是给自己一个缓冲的时间，一天更新纯技术一天更新技术心得或生活感悟，这样不会有太大难度的技术壁垒，也能够形成一个缓冲期，后面形成了习惯就能做纯技术输出。
我认为，既然要开始写作，那么掌握写作的框架结构和常用套路是很有必要的。去看了几位写作名家谈论如何写作，包括：胡鞍钢、毛泽东、矛盾等。以下来谈谈我的心得体会。
胡大和毛大都强调写出好的文章第一个要注意的是了解和理解你的写作对象。并且你写的文章不是给自己看，而是要给别人看。并且要有服务读者的理念，写出让读者爱看的文章。
大人，时代变了。以前的我确实是这么想的，我们写文章最重要的是要了解读者是谁，然后才能写出好的文章。而对现在的从事互联网行业的我来说，我只是一个小喽喽，自己写的文章自己都不想看，何况别人看。虽然会编程的人都可以说自己是做互联网行业，但光就编程语言就有几十上百种，各种日新月异的技术层出不穷，互联网也有非常多的分支。所以我写文章的出发点更多的是写出自己都愿意看的文章，写自己领域的技术技能。
我一直以来的想法都是，如果写出的文章。自己也喜欢那么肯定能够吸引到和你一样的人。技术文章有时候讲起来过于细碎，有时候即便同方向的别人也不知道你在干什么。因此最后还是回到了：照顾好自己，吸引那些喜欢你、认可你的人。
第二点，也是三位大家都在强调的：反复修改文章。好的文章就像好的代码，虽然一开始跑的很快有初稿有初步代码，但想要修正自己的认知、提升自己的写作能力、突破自己的编程瓶颈就得真正做好这件事。更重要的是，要有勇气面对自己，接纳不完美的自己，拥抱你能够做得更好的地方。
最后一点是矛大所说的，向生活学习。我向来认为，一个会生活的人，写出的文章是能够从中体会到柴米油盐酱醋茶的酸甜苦辣。一个会编程的人，写出的代码是洞悉世界的底层规律，严谨且确定的。同时艰巨这二者的人，便是会生活，会编程，懂得学习与接纳，拥有自己思想的人。简单的说，就是你们所谓，我之所想的——有趣的人。比如我公众号第一篇文章，就是我非常喜爱的一位既是编程者也是写作者的人。
今天也是我写作日更第一天的开始，时间有点压。明天开始还是要早点行动，早点完成写作。先建立行动习惯，再去尝试更多想法。先做到提前写作，再做到超前写作。一起加油。</description>
    </item>
    
    <item>
      <title>Grafana 条形图实践</title>
      <link>https://jupiterxue.github.io/posts/2021-07-29-grafana-bar-chart/</link>
      <pubDate>Thu, 29 Jul 2021 09:56:39 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-07-29-grafana-bar-chart/</guid>
      <description>前言 可视化平台有很多，最重要的是选择符合业务需求的方案，费用低、学习曲线低、易于上手、集成性好这些都是加分项。众望所归，我选择了 Grafana。
特点 让我们康康 Grafana 是怎样的：
 免费。Grafana 是一个开源的独立日志分析和监视工具。 开发少可直接用。面向分析师和一般使用者，一般不需要做多少编码工作就能直接拿来分析数据、搭建可视化系统。 界面炫酷。来看看官网的展示 Grafana 官网概述 丰富集成。Grafana 是跨平台工具，它提供了与各种平台和数据库的集成，持 InfluxDB，AWS，MySQL，PostgreSQL 等。 用户交互体验好。展示连续实时监控指标（如 CPU 负载，内存）、对数据提供自定义实时警报、提供基于数据库及其查询语法的命令列界面。  准备工作-采集器 一个可视化平台，重要的是有数据来做支撑，像上面所说的数据库。本文采取具有灵活查询和实时报警构建的时序数据库 promethues 来作为数据管理端。
作为圣火的传人，promethues 有着各种采集器小弟，如服务器资源采集器 node-exporter、进程资源采集器 process-exporter、服务资源采集器 blackbox-exporter， 有了这些采集器就可以直接搭建起监控和警报
服务器监控 进程监控 服务监控 最后再配有 docker 微服务，你的监控和警报平台就能够一键部署起来了。 准备工作-定制化 有了各种采集器，其实能够满足大部分通用监控的需求，但往往我们的业务是不一样的，那么就需要进行定制。
用到了胶水语言 Python 在 promethues 的模块 promethues_client，就能开始定制了！
制作一个条形图 其实这个标题，我最先想取 “fuck the bar chart”，其他定制化的数据，表格、饼图、折线图都是能够在粗略熟悉 Grafana 后可以自己上手做的。
而这个条形图困扰了我整整一周的时间，各种找插件、换版本、调格式、选展示方式，都没有达到理想效果：
今天来彻底搞定这个问题！！
版本    工具 版本     Docker 1.13.1   Go 1.</description>
    </item>
    
    <item>
      <title>Python 答疑复盘</title>
      <link>https://jupiterxue.github.io/posts/2021-07-28-python-replay/</link>
      <pubDate>Wed, 28 Jul 2021 09:49:15 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-07-28-python-replay/</guid>
      <description>在成长会中，我们会自发组建小组学习各种知识与技能，比如新概念英语朗读、经济学专题晨读、瘦下来、相亲、太极、书法、早起锁定以及 Python 基础入门小组。如果没有你感兴趣的小组，也可以你来组建这么个小组，因为，成长会的同学五湖四海，肯定有喜欢你的人 :)
今年的 2 月到 6 月我在保险学专题晨读活动中担任小队队长，听起来有点高大上，做起来就是催作业（其实不是）。我们的晨读活动是每天看一两章专业领域的书，然后当天答题，没答题的就会被踢出群。而我作为队长，并没有过多地去催作业，我们小队的同学都比较自觉，嘻嘻。更重要的是，在担任队长期间，我去开发了一套小程序，能够帮助我和其他12个队长统计作业、统计没有完成名单、收集本队作业以及统计复盘。虽然已经有一套比较复杂的工程软件来统计，但普通人一般用不了，比较麻烦，所以最后还是落到人工统计上，而队长所谓的人工统计，就是让队员自己统计？自从我在当队员的时候看到这个问题，就开始萌生要做一个统计软件的想法。现在已经实现了，并且不同主题晨读活动的队长拿着我的代码也能够进行作业统计，只需要看我的文档就会操作，一般不需要辅导。因为里面已经有封装为 exe 的程序或者源码和一两部操作就能跑的说明。
大概7月初，我们在成长会的知识星球会写个人的半年总结，我写到了些事。有一天一个成长会的同学想组织大家学 Python，通过知识星球的半年总结帖发现了我 Python 用的还可以，就让我进入小组担任答疑官。于是就有了今天组织大家线上答疑复盘的经历。
我是在早上醒来发现这位 Python 学习小组长来联系，邀请我进行答疑，询问我的时间情况。就今天拉。然后她收集好大家在学 Python 过程中的问题便发了一份 Jupyter 打开的文件给我。我也在抽空的时间写了笔记并且提供给大家提前看了看，也算是我从另外一位答疑官朋友那里吸取的翻车经验吧——即便自己能力再厉害，遇到基础还是要踏踏实实。
今晚也算是我第一是上麦直播分享纯 Python 技术，这种体验对我来说真的不一样。以前一直想有机会开直播讲解技术，但一直感觉自己的技术能力很差不够格去讲。现在深刻感悟到，我已经踏进门了一步，相比于想要入门的同学，分享的任何东西相对来说都是对他们有价值的。同时也发现，对基础概念的理解需要细细揣摩才能理解。同学们问的基础问题也值得留意，因为自己当初也是那么稀里糊涂地过来的，现在还能回答上吗？如果不能那就赶紧动起来，二次学习的机会到了！
其实这是第一次讲授代码的课，一开始我陷入了一句句讲解代码的过程，讲了第一题我自己就觉得有点累遭不住，美其名曰地问了一句大家觉得我这个讲解方式还适应吗，其实是想让大家说只想听思路，hhh。现在看来，一句句讲解是有必要的，一句句代码给大家演示也是有必要的，因此需要做好基本功的储备。同时，授课的时候要去倾听听众的感受，让我们一起将这堂课圆满完成。</description>
    </item>
    
    <item>
      <title>Go 实用小工具</title>
      <link>https://jupiterxue.github.io/posts/2021-07-26-go-tools-kit/</link>
      <pubDate>Mon, 26 Jul 2021 11:00:46 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-07-26-go-tools-kit/</guid>
      <description>Go 小工具 执行命令行 1package main 2 3import ( 4	&amp;#34;flag&amp;#34; 5	&amp;#34;fmt&amp;#34; 6	&amp;#34;runtime&amp;#34; 7 &amp;#34;os/exec&amp;#34; 8 &amp;#34;strings&amp;#34; 9) 10 11func main() { 12	// flag 包使用方法：flag.Type(&amp;#34;flagName&amp;#34;,defaultValue,&amp;#34;help message&amp;#34;) *Type 13	var name = flag.String(&amp;#34;name&amp;#34;,&amp;#34;ls&amp;#34;,&amp;#34;info: 命令&amp;#34;) 14	var args = flag.String(&amp;#34;args&amp;#34;,&amp;#34;-h&amp;#34;,&amp;#34;info: 多个参数&amp;#34;) 15 flag.Parse() 16	fmt.Println(*name) 17	fmt.Println(*args) 18	cmd := *name + &amp;#34; &amp;#34; + *args 19	fmt.Println(&amp;#34;Command: %s&amp;#34;, cmd) 20	out, err := exec.Command(&amp;#34;bash&amp;#34;, &amp;#34;-c&amp;#34;, cmd).CombinedOutput() 21	if runtime.GOOS == &amp;#34;windows&amp;#34; &amp;amp;&amp;amp; err !</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://jupiterxue.github.io/about/</link>
      <pubDate>Sat, 24 Jul 2021 17:51:42 +0000</pubDate>
      
      <guid>https://jupiterxue.github.io/about/</guid>
      <description>技能栈，小公司后端研发，自我定位——全栈工程师 🦄
 语言：Golang 🐹、Python 🐍、JavaScript、Emacs Lisp
前端：Vue、Element-UI
后端：爬虫 🕷、FastApi、Ethereum 以太坊
数据库：MySQL、Redis、ElasticSearch
运维：Docker
监控：Promethues、Grafana
大数据：Hadoop、Hive、Hbase
 兴趣爱好，网瘾少年 🎮
 运动：跑步 👟
竞技：自走棋、LoL、王者
休闲：怪物猎人 🐗
 书单，当然看经典
 大部头：《资本论》、《市场营销》、《管理学》、《保险学》
个人成长：《刻意学习》、《持续行动》💁
历史典籍：《毛泽东选集》🌌、《明朝那些事》
人物自传：《乔布斯传》、《富兰克林传》、《穷查理宝典》
最近在嗑技术类：《SICP》、《DDIA》
 欢迎更多交流
Github 👨‍👦‍👦地址: Jupiter ，邮件📧：xfavor2top@gmail.com</description>
    </item>
    
    <item>
      <title>王垠的智慧</title>
      <link>https://jupiterxue.github.io/posts/2021-07-23-idea-from-wangyin/</link>
      <pubDate>Fri, 23 Jul 2021 18:21:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-07-23-idea-from-wangyin/</guid>
      <description>王垠的智慧 王垠是谁？去谷歌知乎简单搜搜就能很快知道这个大名鼎鼎之人。对我来说，他是具有叛逆精神、擅长质疑与逻辑推断的人。他的求学经历让我感到惋惜，与此同时，他的学习能力让我膜拜，他对计算器编译器的深刻洞见让我崇拜。最让我痴迷的是，还是他在自己的博客 “当然我在扯淡”中记录了四篇他的智慧：
参考链接
《编程的智慧》http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy
《生活的智慧》http://www.yinwang.org/blog-cn/2017/07/08/living-philosophy
《旅行的智慧》http://www.yinwang.org/blog-cn/2017/08/14/travel-wisdom
《学习的智慧》http://www.yinwang.org/blog-cn/2019/07/12/learning-philosophy
心得感悟 我是从大学开始接触编程，也是从大学才接触到的王垠。那时候无意之间闯入了 GNU 的新世界，王垠已经在这个广阔天地被人们称为了大牛。和计算机课本上那些枯燥、机械的例子不同，他将算法的思想融入到了生活的点点滴滴当中。不管你是否是从事计算机行业，相信看了这几篇文章都会被他的思想吸引住，想去一一尝试一下。
如果你从事计算机行业，掌握编程，那么你很荣幸，我们最大的乐趣就在于创造，它能让你脱离低级的趣味。我们学习技术，最直观的学习是在实践中进行的，学了代码就去写，掌握思想就能改，实践多了就能大胆创新。这时候，编辑器你的画笔，可以让你成为神笔马良；编译器是你的电脑笔友，细心地告诉你在哪里你要去往哪里。
我们做程序的，习惯叫自己程序员 / 程序媛 / 码农，就从码农可以看出，是勤勤恳恳的。确实，在编程领域当中，一分耕耘一分收获。大家学习技术，也许不单纯为了一份工作，我相信热爱技术的你，是想通过自己的双手，通过对技术的理解，创造出对世界、对社会有价值、有贡献的东西。当然，我们沉迷技术，却不是脱离生活，我们希望技术能够改善生活，我们希望算法的思想能够让这个社会变得更加美好，我们希望这个世界变得更加智慧。
生活不止眼前的代码，还有流淌于柴米油盐之间的智慧。
参考资料 [1]
[2] 最“狂”天才，保送清华读博，3次退学，怒怼阿里 P10，被微软全球封杀！ https://jishuin.proginn.com/p/763bfbd2b5c2</description>
    </item>
    
    <item>
      <title>Algorithms - Graphs</title>
      <link>https://jupiterxue.github.io/posts/2020-05-01-algorithms-graphs/</link>
      <pubDate>Fri, 01 May 2020 09:00:00 +0000</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2020-05-01-algorithms-graphs/</guid>
      <description>Undirected Graphs Some problems  Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once  classical NP-complete problem.   Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical?  No one knows so far. A lonstanding open problem    Representations Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree).</description>
    </item>
    
    <item>
      <title>Racket notes</title>
      <link>https://jupiterxue.github.io/posts/2020-02-29-racket/</link>
      <pubDate>Sat, 29 Feb 2020 09:00:00 +0000</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2020-02-29-racket/</guid>
      <description>Basic 1#lang racket 2(provide (all-defined-out)) 3 4;this is a comment 5 6(define s &amp;#34;hello&amp;#34;) 7 8(define x 3) 9(define y (+ x 2)) 10 11(define cube1 12 (lambda (x) 13 (* x (* x x)))) 14 15(define cube2 16 (lambda (x) 17 (* x x x))) 18 19(define (cube3 x) 20 (* x x x)) 21 22(define (pow1 x y) 23 (if (=y 0) 24 1 25 (* x (pow1 x (- y 1))))) 26 27; currying 28(define pow2 29 (lambda (x) 30 (lambda (y) 31 (pow1 x y)))) 32 List  Empty list: null  () doesn&amp;quot;t work for null but &#39;() does   build a list: (list e1 .</description>
    </item>
    
    <item>
      <title>ruby学习笔记</title>
      <link>https://jupiterxue.github.io/posts/2016-12-08-ruby-notes/</link>
      <pubDate>Thu, 08 Dec 2016 22:54:49 +0000</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2016-12-08-ruby-notes/</guid>
      <description>regular expressions =~是用于正则表达式的匹配操作符。返回匹配到的字符串位置或nil。
1&amp;#34;abcdef&amp;#34; =~ /d/ # return 3 2&amp;#34;aaaaaa&amp;#34; =~ /d/ # return nil !和? The exclamation point (!, sometimes pronounced aloud as &amp;ldquo;bang!&amp;quot;) indicates something potentially destructive, that is to say, something that can change the value of what it touches.
ruby&amp;gt; s1 = &amp;quot;forth&amp;quot; &amp;quot;forth&amp;quot; ruby&amp;gt; s1.chop! # This changes s1. &amp;quot;fort&amp;quot; ruby&amp;gt; s2 = s1.chop # This puts a changed copy in s2, &amp;quot;for&amp;quot; ruby&amp;gt; s1 # .</description>
    </item>
    
  </channel>
</rss>
