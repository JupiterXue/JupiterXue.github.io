<!doctype html><html lang=zh-cn>
<head>
<link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title> Go 翻山越岭——反编译2 | 木夜星空的个人博客</title>
<link rel=canonical href=https://jupiterxue.github.i/go-to-top/go-top-day8-disassembly/>
<meta name=description content="东方不亮木星亮，黑了白昼有星空">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="all,follow">
<meta name=googlebot content="index,follow,snippet,archive">
<meta property="og:title" content="Go 翻山越岭——反编译2">
<meta property="og:description" content="Go 语言常用的两个查看汇编代码的工具是 go tool compile 和 go tool objdump。上期文章说到通过 go tool compile -S 可以查看实现相同功能，两个不同的代码在性能上有什么区别，可从反编译出的汇编代码看出，二者的性能一样。今天再来聊一聊另外一个工具的使用。
 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？
 在解决这种类似问题之前，我们其实可以查阅官方的资料 spec，国外源地址：https://golang.org/ref/spec ，国内看这个：https://golang.google.cn/ref/spec
这个 spec 讲述了 Go 语言内部的语法可以怎么用。在 spec 中出现的东西，也就是官方认为是正确的东西。而如果一个用法没有在 spec 中提到，那么我们就没有办法去依赖输出结论。
举个例子，我们用到一个函数，这个函数用到了指针和 Error，如果这个返回的 Error 是非空的时候，我就不能依赖它的指针返回值。我们要依赖这个值，就需要 Error 是空。这种情况就是语言的确定性，如果我们依赖了有 Error 的结果，那么就是非确定性的。这个非确定性，我们会经常看到一个名词叫做 Undefined Behavior。我们初学 Go 语言，或者习惯于写动态语言，如 Python 的同学，会非常依赖这种写代码习惯，这其实是非常危险的。它可能会给我们带来隐藏的线上 Bug，很多时候都是难发现的，特别是在做语言 SDK 升级的时候，可能会导致比较严重的问题。
所以我们要去查询 Go 语言内部的函数或者结构的用法的话，一定要去看官方的资料。不要去看网上的博客来作为自己的结论，因为别人写的不一定对，尤其是当我们使用了错误的博客内容来操作，会给业务带来更多麻烦。
OK，打开 spec 网址，我们来看看，哥们，你这瓜多少钱一斤？
spec 告诉我们，make 可以用在三种结构上的：slice，map，channel。也就说明，我们要研究 make 的实现，就去看这三种结构上执行 make 具体会执行哪个函数就好。
我们来实现这段代码，文件名为 make.go
1package main 2 3func main() { 4 // make slice 5 // 空间开的比较大，是为了让这个 slice 分配到堆上。空间小的话会默认分配到栈上，而栈上的 slice 和堆上的 slice 底层实现会不一样。 6 var sl = make([]int, 100000) 7 println(sl) 8 9 // make channel 10 var ch = make(chan int, 5) 11 println(ch) 12 13 // make map 14 var m = make(map[int]int, 22) 15 println(m) 16} 1>>> go build make.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jupiterxue.github.i/go-to-top/go-top-day8-disassembly/"><meta property="article:section" content="go-to-top">
<meta property="article:published_time" content="2021-08-21T15:25:05+08:00">
<meta property="article:modified_time" content="2021-08-21T15:25:05+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Go 翻山越岭——反编译2">
<meta name=twitter:description content="Go 语言常用的两个查看汇编代码的工具是 go tool compile 和 go tool objdump。上期文章说到通过 go tool compile -S 可以查看实现相同功能，两个不同的代码在性能上有什么区别，可从反编译出的汇编代码看出，二者的性能一样。今天再来聊一聊另外一个工具的使用。
 场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？
 在解决这种类似问题之前，我们其实可以查阅官方的资料 spec，国外源地址：https://golang.org/ref/spec ，国内看这个：https://golang.google.cn/ref/spec
这个 spec 讲述了 Go 语言内部的语法可以怎么用。在 spec 中出现的东西，也就是官方认为是正确的东西。而如果一个用法没有在 spec 中提到，那么我们就没有办法去依赖输出结论。
举个例子，我们用到一个函数，这个函数用到了指针和 Error，如果这个返回的 Error 是非空的时候，我就不能依赖它的指针返回值。我们要依赖这个值，就需要 Error 是空。这种情况就是语言的确定性，如果我们依赖了有 Error 的结果，那么就是非确定性的。这个非确定性，我们会经常看到一个名词叫做 Undefined Behavior。我们初学 Go 语言，或者习惯于写动态语言，如 Python 的同学，会非常依赖这种写代码习惯，这其实是非常危险的。它可能会给我们带来隐藏的线上 Bug，很多时候都是难发现的，特别是在做语言 SDK 升级的时候，可能会导致比较严重的问题。
所以我们要去查询 Go 语言内部的函数或者结构的用法的话，一定要去看官方的资料。不要去看网上的博客来作为自己的结论，因为别人写的不一定对，尤其是当我们使用了错误的博客内容来操作，会给业务带来更多麻烦。
OK，打开 spec 网址，我们来看看，哥们，你这瓜多少钱一斤？
spec 告诉我们，make 可以用在三种结构上的：slice，map，channel。也就说明，我们要研究 make 的实现，就去看这三种结构上执行 make 具体会执行哪个函数就好。
我们来实现这段代码，文件名为 make.go
1package main 2 3func main() { 4 // make slice 5 // 空间开的比较大，是为了让这个 slice 分配到堆上。空间小的话会默认分配到栈上，而栈上的 slice 和堆上的 slice 底层实现会不一样。 6 var sl = make([]int, 100000) 7 println(sl) 8 9 // make channel 10 var ch = make(chan int, 5) 11 println(ch) 12 13 // make map 14 var m = make(map[int]int, 22) 15 println(m) 16} 1>>> go build make.">
<link rel=stylesheet href=https://jupiterxue.github.i/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-5QVC54HS9T')</script>
<link rel=icon type=image/png href=https://jupiterxue.github.i/images/favicon.ico>
</head>
<body class="max-width mx-auto px3 ltr">
<div class="content index py4">
<header id=header>
<a href=https://jupiterxue.github.i>
<div id=logo style=background-image:url(https://jupiterxue.github.i/images/logo.png)></div>
<div id=title>
<h1>木夜星空的个人博客</h1>
</div>
</a>
<div id=nav>
<ul>
<li class=icon>
<a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a>
</li>
<li><a href=/>主页</a></li>
<li><a href=/posts>文章</a></li>
<li><a href=/tags>归档</a></li>
<li><a href=/about>关于</a></li>
</ul>
</div>
</header>
<article class=post itemscope itemtype=http://schema.org/BlogPosting>
<div class=content itemprop=articleBody>
<p>Go 语言常用的两个查看汇编代码的工具是 <strong>go tool compile 和 go tool objdump</strong>。上期文章说到通过 go tool compile -S 可以查看实现相同功能，两个不同的代码在性能上有什么区别，可从反编译出的汇编代码看出，二者的性能一样。今天再来聊一聊另外一个工具的使用。</p>
<blockquote>
<p>场景3，怎么找到 make 和 new 这种 Go 语言自带数据结构的具体实现？</p>
</blockquote>
<p>在解决这种类似问题之前，我们其实可以<strong>查阅官方的资料 spec</strong>，国外源地址：https://golang.org/ref/spec ，国内看这个：https://golang.google.cn/ref/spec</p>
<p>这个 spec 讲述了 Go 语言内部的语法可以怎么用。在 spec 中出现的东西，也就是官方认为是正确的东西。而如果一个用法没有在 spec 中提到，那么我们就没有办法去依赖输出结论。</p>
<p>举个例子，我们用到一个函数，这个函数用到了指针和 Error，如果这个返回的 Error 是非空的时候，我就不能依赖它的指针返回值。我们要依赖这个值，就需要 Error 是空。这种情况就是<strong>语言的确定性</strong>，如果我们依赖了有 Error 的结果，那么就是非确定性的。这个非确定性，我们会经常看到一个名词叫做 <strong>Undefined Behavior</strong>。我们初学 Go 语言，或者习惯于写动态语言，如 Python 的同学，会非常依赖这种写代码习惯，这其实是非常危险的。它可能会给我们带来隐藏的线上 Bug，很多时候都是难发现的，特别是在做语言 SDK 升级的时候，可能会导致比较严重的问题。</p>
<p>所以我们要去查询 Go 语言内部的函数或者结构的用法的话，一定要去看官方的资料。不要去看网上的博客来作为自己的结论，因为别人写的不一定对，尤其是当我们使用了错误的博客内容来操作，会给业务带来更多麻烦。</p>
<p>OK，打开 spec 网址，我们来看看，哥们，你这瓜多少钱一斤？</p>
<p><img src=https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108212337904.png alt=image-20210821223659673></p>
<p>spec 告诉我们，make 可以用在三种结构上的：slice，map，channel。也就说明，我们要研究 make 的实现，就去看这三种结构上执行 make 具体会执行哪个函数就好。</p>
<p>我们来实现这段代码，文件名为 make.go</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span>    <span style=color:#75715e>// make slice
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span style=color:#75715e></span>    <span style=color:#75715e>// 空间开的比较大，是为了让这个 slice 分配到堆上。空间小的话会默认分配到栈上，而栈上的 slice 和堆上的 slice 底层实现会不一样。
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sl</span> = make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>100000</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>    println(<span style=color:#a6e22e>sl</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>    
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>    <span style=color:#75715e>// make channel
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ch</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>    println(<span style=color:#a6e22e>ch</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>    
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span>    <span style=color:#75715e>// make map
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>22</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span>    println(<span style=color:#a6e22e>m</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span>}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>&gt;&gt;&gt; go build make.go <span style=color:#f92672>&amp;&amp;</span> go tool objdump ./make | grep -E <span style=color:#e6db74>&#34;make.go:6|make.go:10|make.go:14&#34;</span>
</code></pre></div><p>命令说明，这里 go build make.go 是编译我们的 Go 程序代码，生成 ELF 可执行文件 make。然后用管道符 | 接住这个 ELF 文件，并用到反编译工具 go tool objdump 来反编译可执行文件 make。然后用管道符 | 接住结果，并用文本搜索工具 grep -E 指令来分割多个 pattern，以实现 OR 操作。</p>
<p><img src=https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108212337735.png alt=image-20210821231924986></p>
<p>初学Go语言中的汇编，我们不需要看懂所有的指令，我们只需要看代码在 runtime 中执行什么函数就好了。这里我们只需要关注 make.go 代码中第 6 行、第 10 行和第 14 行的结果就行了。接下来我们就去找汇编中 runtime.makeslice(SB)，runtime.makechan(SB)，runtime.makemap(SB) 等汇编指令都在干什么就好了。（下期讲如何看）</p>
<p>同样的方法，我们再来学习如何找 new 的实现，还是先问一下 spec，这瓜保熟嘛？</p>
<p><img src=https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108212338479.png alt=image-20210821232228535></p>
<p>如下文件名为 new.go （由于输出内容稍微复杂，建议大家跳读）</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>person</span> <span style=color:#66d9ef>struct</span> { <span style=color:#a6e22e>age</span> <span style=color:#66d9ef>int</span> }
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = new(<span style=color:#66d9ef>int</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> = new(<span style=color:#a6e22e>person</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> = new(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> = new(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>    
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>    println(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>&gt;&gt;&gt; go tool compile -N -S  new.go | grep -E <span style=color:#e6db74>&#34;new.go:6|new.go:7|new.go:8|new.go:9&#34;</span>
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108212338842.png alt=image-20210821232741718></p>
<p>由于官方对 new 优化比较多，会随着版本变化，最新的版本和现在我用的 go1.14.12 差别还是挺大的。从这里我们大概知道，new 的底层实现会返回一个指针，具体的类型会根据不同数据类型进行不同的细节操作。（这个过程不太好找，需要去看编译器内部的代码，曹大建议放弃）</p>
<p>最后，我们只要用了合适的查看汇编的方法，就不会迷失在庞大的 runtime 代码当中，也不会迷失在别人的博客结论中。值得注意的是，虽然汇编底层会随着 Go 版本变化，网上的源码分析文章过一两年就过时了，但我们只要记住结论、知道工具以后，随时都能自己手动去做实验，通过实现去拿到当前版本的结论，肯定是最靠谱的结论。</p>
<p>预告：下期文章将会讲如何使用汇编调试工具来进行语法实现的具体分析。</p>
<p><strong>参考资料</strong></p>
<p>[1] Golang specification</p>
<p><a href=https://golang.google.cn/ref/spec>https://golang.google.cn/ref/spec</a></p>
<p>[2] grep -E命令总结</p>
<p><a href=https://blog.csdn.net/hl980703/article/details/90228724>https://blog.csdn.net/hl980703/article/details/90228724</a></p>
</div>
</article>
<footer id=footer>
<div class=footer-left>
Copyright &copy; 2021 JupiterXue
</div>
<div class=footer-right>
<nav>
<ul>
<li><a href=/>主页</a></li>
<li><a href=/posts>文章</a></li>
<li><a href=/tags>归档</a></li>
<li><a href=/about>关于</a></li>
</ul>
</nav>
</div>
</footer>
</div>
</body>
<link rel=stylesheet href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>