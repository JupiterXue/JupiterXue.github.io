<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go-to-tops on 木夜星空的个人博客</title>
    <link>http://JupiterXue.github.io/go-to-top/</link>
    <description>Recent content in Go-to-tops on 木夜星空的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 22 Aug 2021 22:51:00 +0800</lastBuildDate><atom:link href="http://JupiterXue.github.io/go-to-top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 翻山越岭——解释器</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day10-parser/</link>
      <pubDate>Sun, 22 Aug 2021 22:51:00 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day10-parser/</guid>
      <description>上期文章遗留了一个问题“三个 panic 在 runtime 代码的具体哪个位置输出”，如果通过汇编调试工具找出来。今天来动手实践，并且尝试解决另一个业务问题。 问题回顾</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——语法分析实现</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day9-parsing_implementation/</link>
      <pubDate>Sun, 22 Aug 2021 08:34:33 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day9-parsing_implementation/</guid>
      <description>之前的文章提到：Go 程序编译和链接涉及到工具 go tool compile 、go tool objdump 和 SSA func build 将源代码转化成静态单赋值形式的中间代码。这些工具都可以直接上手玩一玩，即</description>
    </item>
    
    <item>
      <title>2021 08 21 Go Top Day8 Disassembly</title>
      <link>http://JupiterXue.github.io/go-to-top/2021-08-21-go-top-day8-disassembly/</link>
      <pubDate>Sat, 21 Aug 2021 15:25:05 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/2021-08-21-go-top-day8-disassembly/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go 翻山越岭——反编译2</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day8-disassembly/</link>
      <pubDate>Sat, 21 Aug 2021 15:25:05 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day8-disassembly/</guid>
      <description>Go 语言常用的两个查看汇编代码的工具是 go tool compile 和 go tool objdump。上期文章说到通过 go tool compile -S 可以查看实现相同功能，两个不同的代码在性能上有什么区</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译与反编译</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day7-assembly/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语</description>
    </item>
    
    <item>
      <title>编译与反编译</title>
      <link>http://JupiterXue.github.io/go-to-top/2021-08-19-go-top-day7-assembly/</link>
      <pubDate>Thu, 19 Aug 2021 23:02:38 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/2021-08-19-go-top-day7-assembly/</guid>
      <description>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——编译原理基础</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day6-parse/</link>
      <pubDate>Sun, 15 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day6-parse/</guid>
      <description>上回我们说到 8 个常见 Go 业务场景，并且可以通过探究 Go 语法背后的秘密就能去解决的问题，在我们开始动手之前，先打好“Go 语言中编译原理的基础” 回顾</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——常见业务问题</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day5-problem/</link>
      <pubDate>Sat, 14 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day5-problem/</guid>
      <description>上回说到通过工具 readelf 和 dlv 调试 Go 语言程序，为什么需要这么做调试代码呢？我单纯地想写个代码，不行吗，常见业务不都是代码实现没有听谁说过要进行底层调</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试2</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day4-run/</link>
      <pubDate>Wed, 11 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day4-run/</guid>
      <description>上回我们说到，利用调试工具 readelf 读取我们在 Linux 上编译的可执行文件 hello，并且找到了查看 Go 底层的入口 entry point address，今天我们尝试踏进底层调试</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调试1</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day3-run/</link>
      <pubDate>Mon, 09 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day3-run/</guid>
      <description>今天来动手实践看看，Go 的底层是如何运作、如何进行调度的，通过调试一段简单的代码，我将带你体验 Go 语言如何接触底层的知识。不会很复杂的，跟着我</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day2</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day2-scheduler/</link>
      <pubDate>Thu, 05 Aug 2021 14:45:19 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day2-scheduler/</guid>
      <description>上回说到 Go 的调度流程本质上是⼀个⽣产-消费流程，今天来讲一讲“调度组件与调度循环”，再来回顾一下两个生动的动画 goroutine 的⽣产端, goroutine 的消费端。 当 goroutine 处</description>
    </item>
    
    <item>
      <title>Go 翻山越岭——调度-day1</title>
      <link>http://JupiterXue.github.io/go-to-top/go-top-day1-scheduler/</link>
      <pubDate>Tue, 03 Aug 2021 09:38:51 +0800</pubDate>
      
      <guid>http://JupiterXue.github.io/go-to-top/go-top-day1-scheduler/</guid>
      <description>前言 Go 语言是一门入门容易深入难的编程语言。说得好像其他编程语言就有入门难深入简单的？其实每一门编程语言要深入学习都会有不一样的壁垒与门槛，只</description>
    </item>
    
  </channel>
</rss>
