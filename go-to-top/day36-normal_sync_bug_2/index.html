<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Go 翻山越岭——常见并发 bug（2） | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/day36-normal_sync_bug_2/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Go 翻山越岭——常见并发 bug（2）" />
<meta property="og:description" content="上期文章说到了一些常见并发 bug 的场景，本期文章继续聊聊 Go 语言中常见的一些 bug，继续写 bug（当然不是），并通过代码案例来讲解。
K8S 这里有段一篇论文的代码，这篇论文总结了业界比较知名的 bug，有一些是 k8s、docker 等耳熟能详的应用。因此，我们也可以发现，即便是 Google 的工程师，他们还是会写出来一些 bug，
1func finishReq(timeout time.Duration) r ob { 2 ch := make(chan ob) // before modify 3 ch := make(chan ob, 1) // modified 4 go func() { 5 result := fn() 6 ch &lt;- result // block 7 } () 8 select { 9 case result = &lt;- ch: 10 return result 11 case &lt;- time.After(timeout): 12 return nil 13 } 14} 这段代码的思路其实很简单：我现在想往外部发一个请求，同时要控制超时。如果请求超时那么就会给用户返回一个空。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/day36-normal_sync_bug_2/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-12-08T16:20:11+08:00" />
<meta property="article:modified_time" content="2021-12-08T16:20:11+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 翻山越岭——常见并发 bug（2）"/>
<meta name="twitter:description" content="上期文章说到了一些常见并发 bug 的场景，本期文章继续聊聊 Go 语言中常见的一些 bug，继续写 bug（当然不是），并通过代码案例来讲解。
K8S 这里有段一篇论文的代码，这篇论文总结了业界比较知名的 bug，有一些是 k8s、docker 等耳熟能详的应用。因此，我们也可以发现，即便是 Google 的工程师，他们还是会写出来一些 bug，
1func finishReq(timeout time.Duration) r ob { 2 ch := make(chan ob) // before modify 3 ch := make(chan ob, 1) // modified 4 go func() { 5 result := fn() 6 ch &lt;- result // block 7 } () 8 select { 9 case result = &lt;- ch: 10 return result 11 case &lt;- time.After(timeout): 12 return nil 13 } 14} 这段代码的思路其实很简单：我现在想往外部发一个请求，同时要控制超时。如果请求超时那么就会给用户返回一个空。"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/go-to-top">Go 语言系列</a></li>
      
        <li><a href="/posts">杂谈</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于我</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>上期文章说到了一些常见并发 bug 的场景，本期文章继续聊聊 Go 语言中常见的一些 bug，继续写 bug（当然不是），并通过代码案例来讲解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112081853217.png" alt="img"></p>
<h2 id="k8s">K8S</h2>
<p>这里有段一篇论文的代码，这篇论文总结了业界比较知名的 bug，有一些是 k8s、docker 等耳熟能详的应用。因此，我们也可以发现，即便是 Google 的工程师，他们还是会写出来一些 bug，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">finishReq</span>(<span style="color:#a6e22e">timeout</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">ob</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">ob</span>)  <span style="color:#75715e">// before modify
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">ob</span>, <span style="color:#ae81ff">1</span>)  <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>        <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fn</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>        <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">result</span> <span style="color:#75715e">// block
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#75715e"></span>    } ()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>    <span style="color:#66d9ef">select</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">result</span> = <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>:
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>        	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#a6e22e">timeout</span>):
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>        	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>}
</code></pre></div><p>这段代码的思路其实很简单：我现在想往外部发一个请求，同时要控制超时。如果请求超时那么就会给用户返回一个空。</p>
<p>这里前两行分别有两段注释，说的是官方修改前的代码 channel 没有缓冲，还有段是修改后的代码 channel 中加入了 1 的缓冲。如果是未修改前的代码，在整个程序跑起来后，我们可以自己先想一下可能会发生什么问题？</p>
<p>在启动了 goroutine 去向远端发起请求的时候，如果发生了超时，就会触发 select 直接返回空。说明 channel 的对端已经没有消费者在等待结果，而没有缓冲时，channel 的 buffer 为 0，那么往 channel 发送结果的 goroutine 一定会阻塞，也就意味着这个 goroutine 永远释放不了，最终造成 goroutine 泄露。也就是超时一次就泄露一个 goroutine，如果超时越多，泄露的 goroutine 涨幅也越多。</p>
<h2 id="syncwaitgroup">sync.WaitGroup</h2>
<p>这个是 sync.WaitGroup 的 bug</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">group</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Add</span>(len(<span style="color:#a6e22e">pm</span>.<span style="color:#a6e22e">plugins</span>))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pm</span>.<span style="color:#a6e22e">plugins</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">plugin</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>        <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Dont</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>    <span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Wait</span>()   <span style="color:#75715e">// before modify
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#75715e"></span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9</span><span style="color:#a6e22e">group</span>.<span style="color:#a6e22e">Wait</span>()   <span style="color:#75715e">// modified
</span></code></pre></div><p>看到代码大家可以思考一些这段代码有什么问题。</p>
<p>在此之前，我们先回顾一下 sync.WaitGroup，它的基本用法中 Add、Done 和 Wait 其实是不能并发的。虽然 Add 和 Done 可以并发，但 Wait 是不可以和另外两个一起并发。</p>
<p>这段代码中，我们原意是想让所有逻辑都运行完之后再退出，而事实上 Wait 和 Done 产生并发了，也就有可能没有执行等待，直接执行下方的逻辑，并且 Wait 永远退出不了。因此必须把 Wait 拿到外面去，让 Wait 单独地执行，而不是并发执行。</p>
<h2 id="contextwithcancel">context.WithCancel</h2>
<p>这个是个 context 的 bug</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#a6e22e">hctx</span>, <span style="color:#a6e22e">hcancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithCancel</span>(<span style="color:#a6e22e">ctx</span>)  <span style="color:#75715e">// before modify
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">hctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>   <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">hcancel</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">CancelFunc</span>   <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">timeout</span> &gt; <span style="color:#ae81ff">0</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>    <span style="color:#a6e22e">hctx</span>, <span style="color:#a6e22e">hcancel</span> = <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithTimeout</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">timeout</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>} <span style="color:#66d9ef">else</span> {   <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">hctx</span>, <span style="color:#a6e22e">hcancel</span> = <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithCancel</span>(<span style="color:#a6e22e">ctx</span>)   <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#75715e"></span>}
</code></pre></div><p>老代码的逻辑是如果有 timeout &gt; 0，就把原来的 context 覆盖掉就结束了。大家想想有没有什么问题？</p>
<p>在第一次生成 context 的时候，其实在底层会生成 goroutine 的。而当 timeout &gt; 0 直接覆盖掉原来的 context ，就相当于原来 context 中的 goroutine 完全没有办法去做控制了，最终导致这个 goroutine 泄露了。所以这种覆盖的方式其实是有问题的。</p>
<p>后期维护的代码也比较直观，根据是否有 timeout，分别生成两个 不同的 context，并且不再有覆盖的操作。</p>
<h2 id="死锁">死锁</h2>
<p>最后一个死锁的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goroutine1</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Lock</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">request</span> <span style="color:#75715e">// blocks,    before modify
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">select</span> {   <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">request</span>   <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">defautl</span>:   <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#75715e"></span>    }   <span style="color:#75715e">// modified
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Unlock</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goroutine2</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>    <span style="color:#66d9ef">for</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>        <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Lock</span>()  <span style="color:#75715e">// blocks
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Unlock</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>        <span style="color:#a6e22e">request</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>}
</code></pre></div><p>这段代码看起来较为简单，第一个 goroutine 中，全局变量 m 先抢占锁，然后 channel 发送值；第二个 goroutine 中，全局对象 m 抢占锁，再释放锁，channel 接收值。也就是说，如果先进入 goroutine1，这个 channel 没有缓冲，就会直接卡住。</p>
<p>修改后的代码是说，如果 channel 还不能暂时发送、对端没有阻塞了的话，那么就可以进入  default 结束，并且全局对象 m 释放锁。这样 goroutine2 接收端就可以进去。如果接收端可以进去了，发送端也便可以发数据了。这个例子算是个基本的死锁逻辑了。</p>
<p>OK，对于并发 bug，我们看得越多越容易在实际项目开发中定位到问题，下期文章再来看一些例子并做个小总结。</p>

  

  </div>
</article>
  
  













  
  
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
            repo= "JupiterXue/BlogComment"
            issue-term="title"
            theme="github-light"
    crossorigin="anonymous"
    async>
    </script>
  </div>
  




    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/go-to-top">Go 语言系列</a></li>
         
        <li><a href="/posts">杂谈</a></li>
         
        <li><a href="/tags">标签</a></li>
         
        <li><a href="/about">关于我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
