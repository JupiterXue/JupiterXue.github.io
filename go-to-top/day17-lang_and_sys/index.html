<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Go 翻山越岭——系统调用基础 | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/day17-lang_and_sys/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Go 翻山越岭——系统调用基础" />
<meta property="og:description" content="编程语言和操作系统之间的桥梁，也就是我们所说的系统调用。今天来聊聊，系统调用的基础概念。
什么是系统调用 我们在了解系统调用之前，需要对操作系统有个简单的了解。操作系统（operating system,OS）是资源的管理器，也是计算机系统的内核与基石，其管理的资源都是经过了抽象。而对计算机来说，资源是硬件信息：CPU、RAM 内存、I/O 设备，以及进一步抽象的软件资源，如进程。
为什么说操作系统是对资源进行了抽象呢？因为操作不方便、操作不安全，我们平时接触到的不是直接的硬件，比如磁盘操作，不会去操作扇区（嵌入式系统除外）。而我们所面对的都是这些：
 磁盘抽象：文件夹 内存抽象：虚拟内存 CPU 抽象：时间片  有了操作系统，我们对计算机的调度还是不够的。说白了，操作系统也是一个应用程序，底层还是一堆代码和汇编指令。这时候，我们需要由硬件提供支持，在应用和操作系统之间进行一层或多层隔离。
CPU 已经为操作系统提供了特殊的安全支持——分级保护域（protection ring）。操作系统内核运行在特殊模式下，即图中的 ring-0 ，而应用运行在 ring-3，但权限被严格限制。因此，在代码中我们没办法直接去调用系统资源，就需要操作系统帮助我们去调用，并把相应的操作抽象成 API 来供我们使用。
 Intel64 有四个特权级别，不过实际上只用到了其中两个 ring-0 和 ring-3。ring-1 和 ring-2 本来计划是为了驱动程序和 OS 服务用，不过流行的 OS 们都没有接受这个方案。
 说到这里，答案已经揭晓。系统调用，是操作系统内核为应用提供的 API。可以理解为内核为应用提供服务，操作系统就位我们的上层应用程序提供了一系列“标准库”。比如我们常见的后端服务：APP 发起请求 request → 操作系统 Operating System 接收、处理并响应 → APP 接收 response。
 对于应用来说，系统调用可以实现超出自己能力以外的事情。
 那么 Go 语言中的系统调用是怎样的呢？在此之前，还需要提及 Go 语言调用规约。我们在做函数调用的时候没有使用寄存器，而是将参数都放在栈上。但在其他编程语言中做参数传递和函数调用都是用到了寄存器。举个例子：
1func hello() { 2 x, y, z := 1, 3, 3, 3 3 a, b, c := multi(x, y) 4} 5 6func multi(x, y int) (a, b, c int) { 7 r, s, t := 1, 2, 3 8 return x&#43;1, x&#43;2, x&#43;3 9} 这段代码的调用规约如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/day17-lang_and_sys/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-09-06T20:26:32+08:00" />
<meta property="article:modified_time" content="2021-09-06T20:26:32+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 翻山越岭——系统调用基础"/>
<meta name="twitter:description" content="编程语言和操作系统之间的桥梁，也就是我们所说的系统调用。今天来聊聊，系统调用的基础概念。
什么是系统调用 我们在了解系统调用之前，需要对操作系统有个简单的了解。操作系统（operating system,OS）是资源的管理器，也是计算机系统的内核与基石，其管理的资源都是经过了抽象。而对计算机来说，资源是硬件信息：CPU、RAM 内存、I/O 设备，以及进一步抽象的软件资源，如进程。
为什么说操作系统是对资源进行了抽象呢？因为操作不方便、操作不安全，我们平时接触到的不是直接的硬件，比如磁盘操作，不会去操作扇区（嵌入式系统除外）。而我们所面对的都是这些：
 磁盘抽象：文件夹 内存抽象：虚拟内存 CPU 抽象：时间片  有了操作系统，我们对计算机的调度还是不够的。说白了，操作系统也是一个应用程序，底层还是一堆代码和汇编指令。这时候，我们需要由硬件提供支持，在应用和操作系统之间进行一层或多层隔离。
CPU 已经为操作系统提供了特殊的安全支持——分级保护域（protection ring）。操作系统内核运行在特殊模式下，即图中的 ring-0 ，而应用运行在 ring-3，但权限被严格限制。因此，在代码中我们没办法直接去调用系统资源，就需要操作系统帮助我们去调用，并把相应的操作抽象成 API 来供我们使用。
 Intel64 有四个特权级别，不过实际上只用到了其中两个 ring-0 和 ring-3。ring-1 和 ring-2 本来计划是为了驱动程序和 OS 服务用，不过流行的 OS 们都没有接受这个方案。
 说到这里，答案已经揭晓。系统调用，是操作系统内核为应用提供的 API。可以理解为内核为应用提供服务，操作系统就位我们的上层应用程序提供了一系列“标准库”。比如我们常见的后端服务：APP 发起请求 request → 操作系统 Operating System 接收、处理并响应 → APP 接收 response。
 对于应用来说，系统调用可以实现超出自己能力以外的事情。
 那么 Go 语言中的系统调用是怎样的呢？在此之前，还需要提及 Go 语言调用规约。我们在做函数调用的时候没有使用寄存器，而是将参数都放在栈上。但在其他编程语言中做参数传递和函数调用都是用到了寄存器。举个例子：
1func hello() { 2 x, y, z := 1, 3, 3, 3 3 a, b, c := multi(x, y) 4} 5 6func multi(x, y int) (a, b, c int) { 7 r, s, t := 1, 2, 3 8 return x&#43;1, x&#43;2, x&#43;3 9} 这段代码的调用规约如下："/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/go-to-top">Go 语言系列</a></li>
      
        <li><a href="/posts">杂谈</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于我</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>编程语言和操作系统之间的桥梁，也就是我们所说的系统调用。今天来聊聊，系统调用的基础概念。</p>
<h1 id="什么是系统调用">什么是系统调用</h1>
<p>我们在了解系统调用之前，需要对操作系统有个简单的了解。操作系统（operating system,OS）是<strong>资源的管理器</strong>，也是计算机系统的内核与基石，其管理的资源都是经过了抽象。而对计算机来说，资源是硬件信息：CPU、RAM 内存、I/O 设备，以及进一步抽象的软件资源，如进程。</p>
<p>为什么说操作系统是对资源进行了抽象呢？因为操作不方便、操作不安全，我们平时接触到的不是直接的硬件，比如磁盘操作，不会去操作扇区（嵌入式系统除外）。而我们所面对的都是这些：</p>
<ul>
<li>磁盘抽象：文件夹</li>
<li>内存抽象：虚拟内存</li>
<li>CPU 抽象：时间片</li>
</ul>
<p>有了操作系统，我们对计算机的调度还是不够的。说白了，操作系统也是一个应用程序，底层还是一堆代码和汇编指令。这时候，我们需要由硬件提供支持，在应用和操作系统之间进行一层或多层隔离。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109062101385.png" alt="image-20210906210117219"></p>
<!-- raw HTML omitted -->
<p>CPU 已经为操作系统提供了特殊的安全支持——分级保护域（protection ring）。操作系统内核运行在特殊模式下，即图中的 ring-0 ，而应用运行在 ring-3，但权限被严格限制。因此，在代码中我们没办法直接去调用系统资源，就需要操作系统帮助我们去调用，并把相应的操作抽象成 API 来供我们使用。</p>
<blockquote>
<p>Intel64 有四个特权级别，不过实际上只用到了其中两个 ring-0 和 ring-3。ring-1 和 ring-2 本来计划是为了驱动程序和 OS 服务用，不过流行的 OS 们都没有接受这个方案。</p>
</blockquote>
<p>说到这里，答案已经揭晓。<strong>系统调用，是操作系统内核为应用提供的 API</strong>。可以理解为内核为应用提供服务，操作系统就位我们的上层应用程序提供了一系列“标准库”。比如我们常见的后端服务：APP 发起请求 request → 操作系统 Operating System 接收、处理并响应 →  APP 接收 response。</p>
<blockquote>
<p>对于应用来说，系统调用可以实现超出自己能力以外的事情。</p>
</blockquote>
<p>那么 Go 语言中的系统调用是怎样的呢？在此之前，还需要提及 <strong>Go 语言调用规约</strong>。我们在做函数调用的时候没有使用寄存器，而是将参数都放在栈上。但在其他编程语言中做参数传递和函数调用都是用到了寄存器。举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>    <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>    <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">multi</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">multi</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>    <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9</span>}
</code></pre></div><p>这段代码的调用规约如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109062141634.png" alt="未命名文件 (5)"></p>
<!-- raw HTML omitted -->
<p>这里也说明一下什么是寄存器。寄存器，是CPU 内部的特殊存储单元。一般是用二极管做的，价格比较高，数量比较少。又因为寄存器少，所以有具体的名字。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109062206995.png" alt="CPU 与内存 (1)"></p>
<!-- raw HTML omitted -->
<p>CPU 包括了：Control Unit 控制单元，ALU 算术逻辑单元，Registers 寄存器。这些都封装在 CPU 内部的，而内存一般是在外面。寄存器里面可以防止一些地址，通过地址找到位置。</p>
<p>大概知道了寄存器的概念之后，我们再聊了解一下系统调用的调用规约。系统调用有一套自己的调用规约，需要使用寄存器。和 C 语言的调用规约相类似：</p>
<table>
<thead>
<tr>
<th style="text-align:center">arch</th>
<th style="text-align:center">syscall NR</th>
<th style="text-align:center">return</th>
<th style="text-align:center">arg0</th>
<th style="text-align:center">arg1</th>
<th style="text-align:center">arg2</th>
<th style="text-align:center">arg3</th>
<th style="text-align:center">arg4</th>
<th style="text-align:center">arg5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">arm</td>
<td style="text-align:center">r7</td>
<td style="text-align:center">r0</td>
<td style="text-align:center">r0</td>
<td style="text-align:center">r1</td>
<td style="text-align:center">r2</td>
<td style="text-align:center">r3</td>
<td style="text-align:center">r4</td>
<td style="text-align:center">r5</td>
</tr>
<tr>
<td style="text-align:center">arm64</td>
<td style="text-align:center">x8</td>
<td style="text-align:center">x0</td>
<td style="text-align:center">x0</td>
<td style="text-align:center">x1</td>
<td style="text-align:center">x2</td>
<td style="text-align:center">x3</td>
<td style="text-align:center">x4</td>
<td style="text-align:center">x5</td>
</tr>
<tr>
<td style="text-align:center">x86</td>
<td style="text-align:center">eaX</td>
<td style="text-align:center">eaX</td>
<td style="text-align:center">ebx</td>
<td style="text-align:center">ecx</td>
<td style="text-align:center">edx</td>
<td style="text-align:center">esi</td>
<td style="text-align:center">edi</td>
<td style="text-align:center">ebp</td>
</tr>
<tr>
<td style="text-align:center">x86_64</td>
<td style="text-align:center">rax</td>
<td style="text-align:center">rax</td>
<td style="text-align:center">rdi</td>
<td style="text-align:center">rsi</td>
<td style="text-align:center">rdx</td>
<td style="text-align:center">r10</td>
<td style="text-align:center">r8</td>
<td style="text-align:center">r9</td>
</tr>
</tbody>
</table>
<p>来源：https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit</p>
<p>我们大多都是在 x86_64 位平台去做开发、写代码，所以我们只需要看最后一行，看它对应的函数传递规则就好。我们每次做具体的系统调用时，都需要传参，arg0 是第一个参数，arg5 是第六个参数。也就是说做系统调用时只能传递 6 个参数。Linux 平台中有 300 多个系统调用，也不没有让传递参数超过 6 个。</p>
<p>往 rax 寄存器中存放具体系统调用的编号，内核再通过计算 6 个参数就能知道我们调用的是哪个系统调用，最后把返回值也放在 rax 寄存器中。</p>

  

  </div>
</article>
  
  













  
  
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
            repo= "JupiterXue/BlogComment"
            issue-term="title"
            theme="github-light"
    crossorigin="anonymous"
    async>
    </script>
  </div>
  




    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2022  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/go-to-top">Go 语言系列</a></li>
         
        <li><a href="/posts">杂谈</a></li>
         
        <li><a href="/tags">标签</a></li>
         
        <li><a href="/about">关于我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
