<!doctype html><html lang=zh-cn>
<head>
<link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title> Go 翻山越岭——语法分析实现 | 木夜星空的个人博客</title>
<link rel=canonical href=https://jupiterxue.github.i/go-to-top/go-top-day9-parsing_implementation/>
<meta name=description content="东方不亮木星亮，黑了白昼有星空">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="all,follow">
<meta name=googlebot content="index,follow,snippet,archive">
<meta property="og:title" content="Go 翻山越岭——语法分析实现">
<meta property="og:description" content="之前的文章提到：Go 程序编译和链接涉及到工具 go tool compile 、go tool objdump 和 SSA func build 将源代码转化成静态单赋值形式的中间代码。这些工具都可以直接上手玩一玩，即便对编译原理的理论不熟悉，在实践后还是会逐步明白的，Go 的工程化在这方面做得挺不错。今天来讲一讲“GO 语言语法分析的具体实现”
调试工具回顾 通过命令 readelf -h 可以查看 ELF 可执行文件的头信息，发现调试入口的十六进制地址码，然后用 dlv 来调试 Go 程序。
在 dlv 中，打断点有三种常用方式：
 b * 地址 b 函数名 b 文件名:行数  指令 c 是从一个断点跳到另一个断点。如果打多个断点，那么可以做连续代码的跳转。
指令 si 是单步调试，调试汇编时常用于使用 si 到 jmp 目标位置，即一步步跳转。
我们用工具 go tool objdump 来做反汇编，而它输出的是 plan9 形式的汇编。其实在 dlv 中内置了反汇编工具，disass，不过它输出的是另一种形式的汇编。这里，我们可以掌握多种调试工具，平时就用自己擅长点的，而遇到了没弄明白的，也许另一个工具换来使用有不一样的效果。
之前我们都是遇到问题搜资料，我想系统学习 dlv 怎么办呢？就像上期文章讲到的，还是去看官方文档：https://github.com/go-delve/delve/tree/master/Documentation/cli
简单浏览一下官方文档可以发现，官方也在逐步添加新的功能。比如说，现在有一个地址，我可以直接用 dlv 中的 x 指令查看一段连续内存里存储的值，这个有点像 gdb 中的 x（另一个调试工具，用于查看内存地址的值）。这个指令在 runtime 中有些开头是 len，然后跟着 unsafe pointer 之类的，我能看到 unsafe pointer ，但它后面的结构直接调试可能看不到，这时候用到 x 指令就可以看到它后面内存里存储的是什么值了。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jupiterxue.github.i/go-to-top/go-top-day9-parsing_implementation/"><meta property="article:section" content="go-to-top">
<meta property="article:published_time" content="2021-08-22T08:34:33+08:00">
<meta property="article:modified_time" content="2021-08-22T08:34:33+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Go 翻山越岭——语法分析实现">
<meta name=twitter:description content="之前的文章提到：Go 程序编译和链接涉及到工具 go tool compile 、go tool objdump 和 SSA func build 将源代码转化成静态单赋值形式的中间代码。这些工具都可以直接上手玩一玩，即便对编译原理的理论不熟悉，在实践后还是会逐步明白的，Go 的工程化在这方面做得挺不错。今天来讲一讲“GO 语言语法分析的具体实现”
调试工具回顾 通过命令 readelf -h 可以查看 ELF 可执行文件的头信息，发现调试入口的十六进制地址码，然后用 dlv 来调试 Go 程序。
在 dlv 中，打断点有三种常用方式：
 b * 地址 b 函数名 b 文件名:行数  指令 c 是从一个断点跳到另一个断点。如果打多个断点，那么可以做连续代码的跳转。
指令 si 是单步调试，调试汇编时常用于使用 si 到 jmp 目标位置，即一步步跳转。
我们用工具 go tool objdump 来做反汇编，而它输出的是 plan9 形式的汇编。其实在 dlv 中内置了反汇编工具，disass，不过它输出的是另一种形式的汇编。这里，我们可以掌握多种调试工具，平时就用自己擅长点的，而遇到了没弄明白的，也许另一个工具换来使用有不一样的效果。
之前我们都是遇到问题搜资料，我想系统学习 dlv 怎么办呢？就像上期文章讲到的，还是去看官方文档：https://github.com/go-delve/delve/tree/master/Documentation/cli
简单浏览一下官方文档可以发现，官方也在逐步添加新的功能。比如说，现在有一个地址，我可以直接用 dlv 中的 x 指令查看一段连续内存里存储的值，这个有点像 gdb 中的 x（另一个调试工具，用于查看内存地址的值）。这个指令在 runtime 中有些开头是 len，然后跟着 unsafe pointer 之类的，我能看到 unsafe pointer ，但它后面的结构直接调试可能看不到，这时候用到 x 指令就可以看到它后面内存里存储的是什么值了。">
<link rel=stylesheet href=https://jupiterxue.github.i/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-5QVC54HS9T')</script>
<link rel=icon type=image/png href=https://jupiterxue.github.i/images/favicon.ico>
</head>
<body class="max-width mx-auto px3 ltr">
<div class="content index py4">
<header id=header>
<a href=https://jupiterxue.github.i>
<div id=logo style=background-image:url(https://jupiterxue.github.i/images/logo.png)></div>
<div id=title>
<h1>木夜星空的个人博客</h1>
</div>
</a>
<div id=nav>
<ul>
<li class=icon>
<a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a>
</li>
<li><a href=/>主页</a></li>
<li><a href=/posts>文章</a></li>
<li><a href=/tags>归档</a></li>
<li><a href=/about>关于</a></li>
</ul>
</div>
</header>
<article class=post itemscope itemtype=http://schema.org/BlogPosting>
<div class=content itemprop=articleBody>
<p>之前的文章提到：Go 程序编译和链接涉及到工具 go tool compile 、go tool objdump 和 SSA func build 将源代码转化成静态单赋值形式的中间代码。这些工具都可以直接上手玩一玩，即便对编译原理的理论不熟悉，在实践后还是会逐步明白的，Go 的工程化在这方面做得挺不错。今天来讲一讲“GO 语言语法分析的具体实现”</p>
<h1 id=调试工具回顾>调试工具回顾</h1>
<p>通过命令 readelf -h 可以查看 ELF 可执行文件的头信息，发现调试入口的十六进制地址码，然后用 dlv 来调试 Go 程序。</p>
<p>在 dlv 中，打断点有三种常用方式：</p>
<ol>
<li>b * 地址</li>
<li>b 函数名</li>
<li>b 文件名:行数</li>
</ol>
<p>指令 c 是从一个断点跳到另一个断点。如果打多个断点，那么可以做连续代码的跳转。</p>
<p>指令 si 是单步调试，调试汇编时常用于使用 si 到 jmp 目标位置，即一步步跳转。</p>
<p>我们用工具 go tool objdump 来做反汇编，而它输出的是 plan9 形式的汇编。其实在 dlv 中内置了反汇编工具，disass，不过它输出的是另一种形式的汇编。这里，我们可以掌握多种调试工具，平时就用自己擅长点的，而遇到了没弄明白的，也许另一个工具换来使用有不一样的效果。</p>
<p>之前我们都是遇到问题搜资料，我想系统学习 dlv 怎么办呢？就像上期文章讲到的，还是去看官方文档：https://github.com/go-delve/delve/tree/master/Documentation/cli</p>
<p>简单浏览一下官方文档可以发现，官方也在逐步添加新的功能。比如说，现在有一个地址，我可以直接用 dlv 中的 x 指令查看一段连续内存里存储的值，这个有点像 gdb 中的 x（另一个调试工具，用于查看内存地址的值）。这个指令在 runtime 中有些开头是 len，然后跟着 unsafe pointer 之类的，我能看到 unsafe pointer ，但它后面的结构直接调试可能看不到，这时候用到 x 指令就可以看到它后面内存里存储的是什么值了。</p>
<h1 id=语法实现分析>语法实现分析</h1>
<p>我们已经储备了很多的调试工具，现在就是让这些工具派上用场的时候了。</p>
<p>来分析一下我们写的第一个 go func 简单程序，文件名为 gofunc.go</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;time&#34;</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>        println(<span style=color:#e6db74>&#34;hello world&#34;</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span>    }()
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>    
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>}
</code></pre></div><p>在通过反编译和文本过滤命令</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>go tool compile -S gofunc.go | grep <span style=color:#e6db74>&#34;gofunc.go:6&#34;</span>
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108221618914.png alt=image-20210822154943813></p>
<p>通过定位第 6 行代码结果，我们找到了被翻译出来的关键结果：runtime.newproc(SB)。这里就将之前文章中提到的创建 goroutine 就串起来了。</p>
<p>因此，这里做个小结，所有的 runtime 函数都可以通过上述方式来找关键信息。</p>
<p>如果我们对 channel 的 send 和 recv 感兴趣，也可以如法炮制，文件名 chan.go</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span>    <span style=color:#a6e22e>a</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>666</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>    
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span>    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>a</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span>    println(<span style=color:#a6e22e>x</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span>}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>go tool compile -S chan.go | grep -E <span style=color:#e6db74>&#34;chan.go:5|chan.go:7&#34;</span>
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108221618915.png alt=image-20210822155941901></p>
<p>从图中可知，我们要找的关键函数就是：runtime.chansend1(SB), runtime.chanrecv1(SB)。</p>
<p>我们除了这种普通的 chan 收发，在平时应用中多和 select 联合起来用，这里还是一个简单例子，文件名 nonblock_recv.go。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ch1</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span>    <span style=color:#66d9ef>select</span> {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ch1</span>:
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span>    <span style=color:#66d9ef>default</span>:
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span>    }
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span>}
</code></pre></div><p>我们从 select 中获取 channel 的值，如果当前 channel 阻塞了，我直接走 default 分支跳出来了。来看看反编译后的结果</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>go tool compile -S nonblock_recv.go | grep <span style=color:#e6db74>&#34;nonblock_recv.go:6&#34;</span>
</code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108221618916.png alt=image-20210822160730403></p>
<p>这里的关键信息 nbrecv，不是 nb recv 而是我们代码 nonblock_recv 对应的底层信息，完美对应上了。</p>
<p>今天，我们举了三个例子来学习如何进行 Go 语法实现分析，学会了没？这里留下个问题，用上今天的方法来找到以下三个实现，摘自书籍 《concurrency in go》</p>
<p><img src=https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202108221617934.png alt=image-20210822161317456></p>
<p>分别有三种情况的 panic：</p>
<ol>
<li>往已经关闭的 channel中写入数据</li>
<li>关闭一个是 nil 值的 channel</li>
<li>关闭一个已经是关闭状态的 channel</li>
</ol>
<p>下期预告：讲述以上三个 panic 在 runtime 代码的具体哪个位置输出，关键信息是什么。</p>
</div>
</article>
<footer id=footer>
<div class=footer-left>
Copyright &copy; 2021 JupiterXue
</div>
<div class=footer-right>
<nav>
<ul>
<li><a href=/>主页</a></li>
<li><a href=/posts>文章</a></li>
<li><a href=/tags>归档</a></li>
<li><a href=/about>关于</a></li>
</ul>
</nav>
</div>
</footer>
</div>
</body>
<link rel=stylesheet href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>