<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Go 翻山越岭——内置数据结构（3） | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/day15-data-structure_3/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Go 翻山越岭——内置数据结构（3）" />
<meta property="og:description" content="Map 有时能够返回一个值，有时候能够返回多个值，这是 Map 的特权语法。今天继续从底层角度来聊聊 Go 语言内置数据结构，Map。
Map Map 中大量类似但又冗余的函数，原因之一便是没有泛型。
1package main 2 3var m = make(map[int] int, 10) 4 5func main() { 6 v1 := m[1] 7 v2, ok := m[2] 8 println(v1, v2, ok) 9} 利用之前提到的工具 go tool objdump 能够获得反汇编后的函数：
 make → runtime.makemap 10 → hint m[1] → runtime.mapaccess1_fast64 m[2] → runtime.mapaccess2_fast64  以上这些过程都是编译器帮我完成的，编译器判断赋值语句，如左边有一个值就翻译为 runtime.mapaccess1_fast64， 需要注意以下三点：
 当 hint 大小大于 8 时，采用的是 makemap 当 hint 小于 8 时，采用的是 makemap_small map 分配栈上时，不一定会调用 makemap  为什么一个 Go 语言内置数据结构就有这么多情况，那如果 Go 的 20 来个内置数据结构都有这种判定，岂不是底层就有差不多 60 个不同判定结构？确实是这样的，map 中存在大量类似但又冗余的函数，但不至于把性能拉低很多。这种问题主要是原因之一是 Go 语言在 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/day15-data-structure_3/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-09-02T23:23:12+08:00" />
<meta property="article:modified_time" content="2021-09-02T23:23:12+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 翻山越岭——内置数据结构（3）"/>
<meta name="twitter:description" content="Map 有时能够返回一个值，有时候能够返回多个值，这是 Map 的特权语法。今天继续从底层角度来聊聊 Go 语言内置数据结构，Map。
Map Map 中大量类似但又冗余的函数，原因之一便是没有泛型。
1package main 2 3var m = make(map[int] int, 10) 4 5func main() { 6 v1 := m[1] 7 v2, ok := m[2] 8 println(v1, v2, ok) 9} 利用之前提到的工具 go tool objdump 能够获得反汇编后的函数：
 make → runtime.makemap 10 → hint m[1] → runtime.mapaccess1_fast64 m[2] → runtime.mapaccess2_fast64  以上这些过程都是编译器帮我完成的，编译器判断赋值语句，如左边有一个值就翻译为 runtime.mapaccess1_fast64， 需要注意以下三点：
 当 hint 大小大于 8 时，采用的是 makemap 当 hint 小于 8 时，采用的是 makemap_small map 分配栈上时，不一定会调用 makemap  为什么一个 Go 语言内置数据结构就有这么多情况，那如果 Go 的 20 来个内置数据结构都有这种判定，岂不是底层就有差不多 60 个不同判定结构？确实是这样的，map 中存在大量类似但又冗余的函数，但不至于把性能拉低很多。这种问题主要是原因之一是 Go 语言在 1."/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/go-to-top">Go 语言系列</a></li>
      
        <li><a href="/posts">杂谈</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于我</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>Map 有时能够返回一个值，有时候能够返回多个值，这是 <strong>Map 的特权语法</strong>。今天继续从底层角度来聊聊 Go 语言内置数据结构，Map。</p>
<h1 id="map">Map</h1>
<p>Map 中大量类似但又冗余的函数，原因之一便是没有泛型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>] <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>    <span style="color:#a6e22e">v1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>]
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>    <span style="color:#a6e22e">v2</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">2</span>]
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span>    println(<span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">v2</span>, <span style="color:#a6e22e">ok</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9</span>}
</code></pre></div><p>利用之前提到的工具 go tool objdump 能够获得反汇编后的函数：</p>
<ul>
<li>make → runtime.makemap</li>
<li>10 → hint</li>
<li>m[1] → runtime.mapaccess1_fast64</li>
<li>m[2] → runtime.mapaccess2_fast64</li>
</ul>
<p>以上这些过程都是编译器帮我完成的，编译器判断赋值语句，如左边有一个值就翻译为 runtime.mapaccess1_fast64， 需要注意以下三点：</p>
<ol>
<li>当 hint  大小大于 8 时，采用的是 makemap</li>
<li>当 hint 小于 8 时，采用的是 makemap_small</li>
<li>map 分配栈上时，不一定会调用 makemap</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109042253388.png" alt="Map 函数一览"></p>
<!-- raw HTML omitted -->
<p>为什么一个 Go 语言内置数据结构就有这么多情况，那如果 Go 的 20 来个内置数据结构都有这种判定，岂不是底层就有差不多 60 个不同判定结构？确实是这样的，map 中存在大量类似但又冗余的函数，但不至于把性能拉低很多。这种问题主要是原因之一是 Go 语言在 1.16 版本前没有泛型。可喜的是，在 Go 1.17 版本之后将会引入泛型，大家感兴趣已经可以自己去尝试了。</p>
<p>曹大有个预见：有了泛型以后，类似 Map 底层函数中的数据结构很有可能有一波大的代码更新，不过也相比于现在的代码来说会轻松点，毕竟现在重复的代码太多了。</p>
<h3 id="再来看看-map-的底层结构有哪些">再来看看 Map 的底层结构有哪些：</h3>
<p>注：图中有些不严谨的地方，后续会跟进完善，但不影响我们分析。</p>
<p>当我们写了一个 map 数据结构，其实底层对应的是 hamp 这个结构。在 hmap 中，关键的字段可以从图中看到</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109042312046.png" alt="Map 结构图"></p>
<!-- raw HTML omitted -->
<h3 id="然后再来看看-map-元素操作">然后再来看看 Map 元素操作</h3>
<p>主要分为三个操作：mapaccess 访问、mapassign 赋值 和 mapdelete 删除。mapaccess 和 mapassign 的原理和操作其实都差不多，具体流程如下：</p>
<p>想要访问一个 map 元素，先对一个 key 做 hash。比如有个 hash values 值是 64 位。这 64 为可以大概分成三部分：开头前八位我们叫做 tophash、最后几位我们叫做 low bits。而这个 low bits 其实是跟 bucket 大小相关的，比如我们 bucket 的大小是 2 的 5次方 32，那么 low bits 就会对 5 做与运算。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109042332691.png" alt="Map 元素操作"></p>
<p>具体我们怎么找到，某个元素在 bucket 中存在于什么位置呢？即先对这个 key 做 hash 处理，然后找到 topash 值，根据这个 topash 的值来找到 bucket 中的某个位置。同时在选中之前需要确定 bmap 选的哪个 bucket。</p>
<p>这里的 tophash 其实是和 bmap 的对比，tophash 存在也并不意味着这个 key 是在 Map 中存在的，实际上还需要和 bmap 中的 keys 做个简单对比。 如果 topash 和 keys 都是相等，那么才能说明这个 key 是存在的。</p>
<p>有一点疑问了，既然访问和赋值流程差不多，那有什么区别呢？访问找到就结束，而赋值找到了还需要做一步覆盖，如没找到就要找个空填进去（这里也需要解决 hash 冲突问题）。</p>
<p>总结一下三个常见解决 hash 表冲突的方法：</p>
<ol>
<li>链式寻址</li>
<li>拉链法（Go 语言用的这种），哈希冲突如果放不下，那么就一直回链。</li>
<li>开放地址法</li>
</ol>
<p>mapdelete 的操作也类似，找到这个值，然后对比 tophash 和 keys，找到了则置空 empty。</p>
<h3 id="map-扩容">Map 扩容</h3>
<p>这也是 map 最麻烦的过程。一般而言，扩容在哪个地方出发？访问，赋值还是删除？一般是在 mapassign 中。load factor 过大 或者 overflow bucket 过多的时候，具体流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202109042347182.png" alt="Map 扩容"></p>
<!-- raw HTML omitted -->
<p>从图中可以看到，搬运过程是需要渐进的。</p>
<p>扩容中</p>
<ul>
<li>mapasssign：将命中的 bucket 从 oldbuckets 顺⼿搬运到
buckets 中，顺便再多搬运⼀个 bucket</li>
<li>mapdelete：将命中的 bucket 从 oldbuckets 顺⼿搬运到
buckets 中，顺便再多搬运⼀个 bucket</li>
<li>mapaccess: 优先在 oldbuckets 中找，如果命中，则说明这
个 bucket 没有被搬运</li>
</ul>
<p>需要注意：搬运 bucket x 时，会被该桶的 overflow 桶也⼀并搬完</p>
<h3 id="map-缺陷">Map 缺陷</h3>
<p>最后，来说说 Map 的缺陷：</p>
<ul>
<li>如果已经扩容，无法进行收缩</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10000000</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>        <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">i</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">9990000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>        delete(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">i</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>}
</code></pre></div><ul>
<li>保证并发安全时，要手动读写锁，容易出错</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">// 没有 sync map 之前，需要自己手动加锁
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;sync&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mapWithLock</span> <span style="color:#66d9ef">struct</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>    <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>    <span style="color:#a6e22e">mux</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mapWithLock</span>) <span style="color:#a6e22e">readMap</span>(<span style="color:#a6e22e">idx</span> <span style="color:#66d9ef">int</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">RLock</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">RUnlock</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>    <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">idx</span>]
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>    <span style="color:#75715e">// do a lot things
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>多核心下表现较差</li>
<li>难以使用 sync.Pool 进行重用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">slicePool</span> = <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Pool</span>{}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e">// slice can be easily reused
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">processUserRequest1</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>    <span style="color:#a6e22e">sl</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">slicePool</span>.<span style="color:#a6e22e">Get</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>        <span style="color:#a6e22e">sl</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sl</span>[:<span style="color:#ae81ff">0</span>]
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>        <span style="color:#a6e22e">slicePool</span>.<span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">sl</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>    }()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>    <span style="color:#75715e">// process user logic
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mapPool</span> = <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Pool</span>{}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e">// what about map?
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">processUserRequest2</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>.<span style="color:#a6e22e">Pool</span>.<span style="color:#a6e22e">Get</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>        <span style="color:#75715e">// how to reset a map?
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#75715e"></span>        <span style="color:#75715e">// FIXME
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">slicePool</span>.<span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">m</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>    }()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>    <span style="color:#75715e">// process user logic
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span style="color:#75715e"></span>}
</code></pre></div><p>关于 Map 的讲解就到这里，像里面还省略了一些同时涉及到 overflow 和扩容中的操作，这个很复杂。不过基础部分都涉及到了。</p>

  

  </div>
</article>
  
  













  
  
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
            repo= "JupiterXue/BlogComment"
            issue-term="title"
            theme="github-light"
    crossorigin="anonymous"
    async>
    </script>
  </div>
  




    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/go-to-top">Go 语言系列</a></li>
         
        <li><a href="/posts">杂谈</a></li>
         
        <li><a href="/tags">标签</a></li>
         
        <li><a href="/about">关于我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
