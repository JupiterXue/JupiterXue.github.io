<!doctype html><html lang=zh-cn>
<head>
<link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title> Go 翻山越岭——编译与反编译 | 木夜星空的个人博客</title>
<link rel=canonical href=https://jupiterxue.github.io/go-to-top/go-top-day7-assembly/>
<meta name=description content="东方不亮木星亮，黑了白昼有星空">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="all,follow">
<meta name=googlebot content="index,follow,snippet,archive">
<meta property="og:title" content="Go 翻山越岭——编译与反编译">
<meta property="og:description" content="Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。
重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。
具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）
编译与反编译工具 我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。
1go tool 这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：
 几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。
 再让我们看看这两句指令在具体场合下都是什么意思：
 go tool compile -S main.go # 反编译代码为汇编代码。
  go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）
go tool objdump [-s symregexp] 二进制 # Objdump 打印二进制文件中所有文本符号（代码）的反汇编。如果存在 -s 选项，objdump 只会反汇编名称与正则表达式匹配的符号。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/go-top-day7-assembly/"><meta property="article:section" content="go-to-top">
<meta property="article:published_time" content="2021-08-19T23:02:38+08:00">
<meta property="article:modified_time" content="2021-08-19T23:02:38+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Go 翻山越岭——编译与反编译">
<meta name=twitter:description content="Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而最重要的就是进行虚拟地址重定位（Relocation）。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。
重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。
具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）
编译与反编译工具 我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。
1go tool 这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：
 几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。
 再让我们看看这两句指令在具体场合下都是什么意思：
 go tool compile -S main.go # 反编译代码为汇编代码。
  go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）
go tool objdump [-s symregexp] 二进制 # Objdump 打印二进制文件中所有文本符号（代码）的反汇编。如果存在 -s 选项，objdump 只会反汇编名称与正则表达式匹配的符号。">
<link rel=stylesheet href=https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-5QVC54HS9T')</script>
<link rel=icon type=image/png href=https://jupiterxue.github.io/images/favicon.ico>
</head>
<body class="max-width mx-auto px3 ltr">
<div class="content index py4">
<header id=header>
<a href=https://jupiterxue.github.io/>
<div id=logo style=background-image:url(https://jupiterxue.github.io/images/logo.png)></div>
<div id=title>
<h1>木夜星空的个人博客</h1>
</div>
</a>
<div id=nav>
<ul>
<li class=icon>
<a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a>
</li>
<li><a href=/>主页</a></li>
<li><a href=/posts>文章</a></li>
<li><a href=/tags>归档</a></li>
<li><a href=/about>关于</a></li>
</ul>
</div>
</header>
<article class=post itemscope itemtype=http://schema.org/BlogPosting>
<div class=content itemprop=articleBody>
<p>Go 程序，从源代码到可执行文件，通常要经过两个步骤：编译 → 链接，而<strong>最重要的就是进行虚拟地址重定位（Relocation）</strong>。上期我们了解了GO语言编译过程包括六个细致的编译步骤，而链接是最后的编译过程。知道了整个流程后，今天再来聊一聊 Go 程序在完成编译后，我们还可以通过哪些工具知道一些信息——编译与反编译。</p>
<p>重定位(relocation)是指把符号引用与符号定义链接到一起的过程。当程序调用一个函数时，将从当前运行的指令地址处跳转到一个新的指令地址处去执行。我们平时在编写程序时，只需指明所要调用的函数名即可，对编译器来说就是指明了符号引用。然后在重定位过程中，动态链接器会把函数名与函数实际所在的地址（符号定义）联系到一起，进而使得程序能够知道应该跳转到哪里去。</p>
<p>具体而言，GO 程序在编译后，所有函数地址都是从 0 开始，每天指令是相对函数第一条指令的偏移，并在进行链接后，所有指令都有了全局唯一的虚拟地址。（注意：不是上方框选地址，这里是指某个函数的偏移量，而是箭头下方的地址，虚拟地址）</p>
<p><img src=C:%5CUsers%5CXfavor%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210819234132142.png alt=image-20210819234132142></p>
<h1 id=编译与反编译工具>编译与反编译工具</h1>
<p>我们学习掌握 Go 语言编译原理理论的过程，会相对有些枯燥。不过通过实践，我们能够很好地将所学到的理论融汇贯通，并且即便你对理论不是很熟悉，也能够玩转这些工具。我会提到平时我们在研究 GO 汇编底层经常用到的工具，让我们来看看它是什么，跟着我一起动动手。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>go tool
</code></pre></div><p><img src=C:%5CUsers%5CXfavor%5CAppData%5CLocal%5CYNote%5Cdata%5CweixinobU7VjplR8GhsqZn6qPSNHGlLvOg%5Cbf1978b1b2864b888597f55ca77551b3%5Cclipboard.png alt=img></p>
<p>这里我标注出了两个最常用的工具 go tool compile 和 go tool objdump。在我们卷 Go 汇编底层的时候，业内还有这么一句黑话：</p>
<blockquote>
<p>几乎没有任何一个 Go 汇编底层问题不是用一条 go tool compile 不能解决的，如果不行的话，就用 go tool objdump，总能知道是怎么回事。</p>
</blockquote>
<p>再让我们看看这两句指令在具体场合下都是什么意思：</p>
<blockquote>
<p>go tool compile -S main.go # 反编译代码为汇编代码。</p>
</blockquote>
<blockquote>
<p>go tool objdump # 可用于查看任意函数的机器码、汇编指令、偏移。（go 源码下面有个 cmd/internal/goobj包，可以读到.o文件的重定向信息，更好）</p>
<p>go tool objdump [-s symregexp] 二进制 # Objdump 打印二进制文件中所有文本符号（代码）的反汇编。如果存在 -s 选项，objdump 只会反汇编名称与正则表达式匹配的符号。</p>
</blockquote>
<p>我们来编写一个小案例进行汇编调试实践：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = <span style=color:#e6db74>&#34;hello&#34;</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> = []byte(<span style=color:#a6e22e>a</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>b</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span>}
</code></pre></div><p>通过反汇编工具来查看一下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span>go tool compile -S ./hello.go | grep <span style=color:#e6db74>&#34;hello.go:5&#34;</span>
</code></pre></div><p><img src=C:%5CUsers%5CXfavor%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210819235112398.png alt=image-20210819235112398></p>
<p>这条命令的意思是，产生 .o 目标文件，并且把目标的汇编内容输出出来。后面跟上管道，用 grep 截取出来 hello.go 编译出来第五行的汇编代码。这里大部分汇编代码其实我们不需要看懂，我们只需要它调用了其中某个函数就知道了。</p>
<p>对于初学者来说，学习Go汇编不需要全都懂，只需要一些关键路径在干什么就行。比如这里最关键的是 &ldquo;runtime.stringtoslicebyte(SB)"，即我们要把 string 转换成 byte 数组，底层会调用这个函数。</p>
<p>掌握了这个方法我们就能解决之前文章中提到的第一个问题：</p>
<p>场景1，这两段代码运行速度怎样？第一个比第二个快？</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#75715e>// 代码1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>person</span> <span style=color:#66d9ef>struct</span> {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>    <span style=color:#a6e22e>age</span> <span style=color:#66d9ef>int</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>person</span>{<span style=color:#ae81ff>111</span>}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>    println(<span style=color:#a6e22e>a</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#75715e>// 对比代码2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>person</span> <span style=color:#66d9ef>struct</span> {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span>    <span style=color:#a6e22e>age</span> <span style=color:#66d9ef>int</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>person</span> {<span style=color:#ae81ff>111</span>}
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span>    println(<span style=color:#a6e22e>a</span>)
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span>}
</code></pre></div><p>我们来看看第一个代码第 8 行编译后变成啥了：</p>
<p><img src=C:%5CUsers%5CXfavor%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210819235718660.png alt=image-20210819235718660></p>
<p>再来看看第二个代码第 8 和第 9 行：</p>
<p><img src=C:%5CUsers%5CXfavor%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210819235743177.png alt=image-20210819235743177></p>
<p>由此，我们可以得出结论：一行版本的代码和两行版本的代码最终编译出的结果是完全一致的，没有任何区别。</p>
<p>掌握了 go tool 中两个常用工具，我们在 Go 语言底层汇编的道路就打开了。下期我还将讲解场景的 8 个业务场景如何应对。</p>
<p><strong>参考资料</strong></p>
<p>[1] 重定位- elf文件类型四Relocation</p>
<p><a href=http://www.360doc.com/content/15/1126/20/7377734_516130511.shtml>http://www.360doc.com/content/15/1126/20/7377734_516130511.shtml</a></p>
<p>[2] go tool 命令</p>
<p><a href="https://louyuting.blog.csdn.net/article/details/101014450?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-3.control">https://louyuting.blog.csdn.net/article/details/101014450</a></p>
<p>[3] go tool objdump</p>
<p><a href=https://my.oschina.net/u/4586289/blog/4634710>https://my.oschina.net/u/4586289/blog/4634710</a></p>
<p>[4] 命令 objdump</p>
<p><a href=https://golang.google.cn/cmd/objdump/>https://golang.google.cn/cmd/objdump/</a></p>
</div>
</article>
<footer id=footer>
<div class=footer-left>
Copyright &copy; 2021 JupiterXue
</div>
<div class=footer-right>
<nav>
<ul>
<li><a href=/>主页</a></li>
<li><a href=/posts>文章</a></li>
<li><a href=/tags>归档</a></li>
<li><a href=/about>关于</a></li>
</ul>
</nav>
</div>
</footer>
</div>
</body>
<link rel=stylesheet href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>