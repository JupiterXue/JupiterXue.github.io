<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Go 翻山越岭——架构下的业务逻辑 | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/day46-business_layering_under_the_framework/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Go 翻山越岭——架构下的业务逻辑" />
<meta property="og:description" content="在我们互联网公司中都会有一类工程师叫做，架构师。他们经常会去参加一些架构师大会。在他们的圈子中也会有一些黑话，我们一般的程序员是听不懂的，因此就需要我们在写代码的同时，去学习一些相关的理论。这些理论只是名词多，其实并不难。
因为 Go 语言主要用在做后端系统，下面说的也是 API 层面的业务分层。
传统分层 在很早的 web 项目中，都是采用的 MVC 的框架模式。
MVC 这种模式在上个世纪 70 年代就已提出，到现在一直在被使用，因此可以说使用 MVC 的 web 项目称得上远古时代。最早的 web 开发用 PHP 的比较多，而 PHP 的架构尤其以 MVC 模式比较多，Model、View、Controller 都是标准化的组件。
但是，存在一个局限性：前后端所有的代码都放在一起的。所以前端可能不那么讲究，就在 PHP 代码中做一套模板引擎，然后直接在在 Vue 里面去写渲染代码；后端的逻辑也很简单，都写在 Controller 里面。情况更糟的是，有些的公司对业务逻辑到底写在哪里还有争议，有的人写在 Model 里。
后来，当前后端分离变成主流共识之后，View 层直接被干掉了。
有一个原因在于前端和后端各自都变得比较复杂了，所以前端也要专门去做工程化了，随后有了 Angular、React、Vue 等三大知名的前端框架。
而后端将 View 拆出去以后，只剩 Model 和 Controller，不过项目也开始变得复杂，一个接口就有几千、上万行代码的情况。这种情况，如果将全部代码堆积在 Controller 里面，并且还是按照以前的编程流程，过程式开发的话，整个代码维护起来相当地费劲。
所以，大多数公司的后端会将逻辑越来越复杂的业务，拆分成单独的 logic，如下：
 model 改成了 dao（data access object）。由于 model 很多时候都被当作领域模型来用，看起来里面就应该有一些逻辑。而 dao 就是仅仅作为数据获取的结构体。 controller 直接被拆分成了两部分，一部分还是叫做 controller，不过功能上更加简单，可能负责的是 API 接口的入口、协议或校验入口等。另一部分 logic ，这个在不同公司有不同的名字，可能叫做 services，都是用来写业务逻辑的。  但是，随着公司的发展，业务逻辑也在逐渐地膨胀，到后面越来越复杂。如果对 拆分后的 controller 没有指导的话，业务代码是很难管理、很难看懂维护的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/day46-business_layering_under_the_framework/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-12-30T19:36:09+08:00" />
<meta property="article:modified_time" content="2021-12-30T19:36:09+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 翻山越岭——架构下的业务逻辑"/>
<meta name="twitter:description" content="在我们互联网公司中都会有一类工程师叫做，架构师。他们经常会去参加一些架构师大会。在他们的圈子中也会有一些黑话，我们一般的程序员是听不懂的，因此就需要我们在写代码的同时，去学习一些相关的理论。这些理论只是名词多，其实并不难。
因为 Go 语言主要用在做后端系统，下面说的也是 API 层面的业务分层。
传统分层 在很早的 web 项目中，都是采用的 MVC 的框架模式。
MVC 这种模式在上个世纪 70 年代就已提出，到现在一直在被使用，因此可以说使用 MVC 的 web 项目称得上远古时代。最早的 web 开发用 PHP 的比较多，而 PHP 的架构尤其以 MVC 模式比较多，Model、View、Controller 都是标准化的组件。
但是，存在一个局限性：前后端所有的代码都放在一起的。所以前端可能不那么讲究，就在 PHP 代码中做一套模板引擎，然后直接在在 Vue 里面去写渲染代码；后端的逻辑也很简单，都写在 Controller 里面。情况更糟的是，有些的公司对业务逻辑到底写在哪里还有争议，有的人写在 Model 里。
后来，当前后端分离变成主流共识之后，View 层直接被干掉了。
有一个原因在于前端和后端各自都变得比较复杂了，所以前端也要专门去做工程化了，随后有了 Angular、React、Vue 等三大知名的前端框架。
而后端将 View 拆出去以后，只剩 Model 和 Controller，不过项目也开始变得复杂，一个接口就有几千、上万行代码的情况。这种情况，如果将全部代码堆积在 Controller 里面，并且还是按照以前的编程流程，过程式开发的话，整个代码维护起来相当地费劲。
所以，大多数公司的后端会将逻辑越来越复杂的业务，拆分成单独的 logic，如下：
 model 改成了 dao（data access object）。由于 model 很多时候都被当作领域模型来用，看起来里面就应该有一些逻辑。而 dao 就是仅仅作为数据获取的结构体。 controller 直接被拆分成了两部分，一部分还是叫做 controller，不过功能上更加简单，可能负责的是 API 接口的入口、协议或校验入口等。另一部分 logic ，这个在不同公司有不同的名字，可能叫做 services，都是用来写业务逻辑的。  但是，随着公司的发展，业务逻辑也在逐渐地膨胀，到后面越来越复杂。如果对 拆分后的 controller 没有指导的话，业务代码是很难管理、很难看懂维护的。"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/go-to-top">Go 语言系列</a></li>
      
        <li><a href="/posts">杂谈</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于我</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>在我们互联网公司中都会有一类工程师叫做，架构师。他们经常会去参加一些架构师大会。在他们的圈子中也会有一些黑话，我们一般的程序员是听不懂的，因此就需要我们在写代码的同时，去学习一些相关的理论。这些理论只是名词多，其实并不难。</p>
<p>因为 Go 语言主要用在做后端系统，下面说的也是 API 层面的业务分层。</p>
<h1 id="传统分层">传统分层</h1>
<p>在很早的 web 项目中，都是采用的 MVC 的框架模式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302001395.png" alt="image-20211230200100037"></p>
<!-- raw HTML omitted -->
<p>MVC 这种模式在上个世纪 70 年代就已提出，到现在一直在被使用，因此可以说使用 MVC 的 web 项目称得上远古时代。最早的 web 开发用 PHP 的比较多，而 PHP 的架构尤其以 MVC 模式比较多，Model、View、Controller 都是标准化的组件。</p>
<p>但是，存在一个局限性：前后端所有的代码都放在一起的。所以前端可能不那么讲究，就在 PHP 代码中做一套模板引擎，然后直接在在 Vue 里面去写渲染代码；后端的逻辑也很简单，都写在 Controller 里面。情况更糟的是，有些的公司对业务逻辑到底写在哪里还有争议，有的人写在 Model 里。</p>
<p>后来，当前后端分离变成主流共识之后，View 层直接被干掉了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302202047.png" alt="image-20211230220222943"></p>
<!-- raw HTML omitted -->
<p>有一个原因在于前端和后端各自都变得比较复杂了，所以前端也要专门去做工程化了，随后有了 Angular、React、Vue 等三大知名的前端框架。</p>
<p>而后端将 View 拆出去以后，只剩 Model 和 Controller，不过项目也开始变得复杂，一个接口就有几千、上万行代码的情况。这种情况，如果将全部代码堆积在 Controller 里面，并且还是按照以前的编程流程，过程式开发的话，整个代码维护起来相当地费劲。</p>
<p>所以，大多数公司的后端会将逻辑越来越复杂的业务，拆分成单独的 logic，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302213764.png" alt="image-20211230221310686"></p>
<!-- raw HTML omitted -->
<ul>
<li>model 改成了 dao（data access object）。由于 model 很多时候都被当作领域模型来用，看起来里面就应该有一些逻辑。而 dao 就是仅仅作为数据获取的结构体。</li>
<li>controller 直接被拆分成了两部分，一部分还是叫做 controller，不过功能上更加简单，可能负责的是 API 接口的入口、协议或校验入口等。另一部分 logic ，这个在不同公司有不同的名字，可能叫做 services，都是用来写业务逻辑的。</li>
</ul>
<p>但是，随着公司的发展，业务逻辑也在逐渐地膨胀，到后面越来越复杂。如果对 拆分后的 controller 没有指导的话，业务代码是很难管理、很难看懂维护的。</p>
<p>后来，DDD （领域驱动设计）社区提出了两种方法：</p>
<ul>
<li>贫血模式。也就是刚刚讲的逻辑，将业务代码都卸载 logic 层内，并且像 Struct、Class 上没有任何逻辑，或只有少量逻辑的代码也写在一起。</li>
<li>充血模式。可以往 Struct 和 Class 上去绑定一定的行为，让 domain object 即 entity 有更多逻辑，将原来的业务逻辑从这种改动后剥离出来，还有一些对象校验的也能从业务逻辑中剥离出来。有了这些领域对象之后，再通过聚合来组合 entity 的逻辑，最终组成现有的业务逻辑。</li>
</ul>
<p>这么说还是有点抽象，来看两个贫血模式代码的例子，摘自书籍《实现领域驱动设计》：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302233978.png" alt="image-20211230223359867"></p>
<!-- raw HTML omitted -->
<p>这里的逻辑是想要保存用户的信息，其中有一大堆的参数。可能我现在有一个业务逻辑只是想要更新一下用户所在的城市，那么也要调用 saveCustomer 这个大的函数，并且传入一大堆本来不需要传递的参数。</p>
<p>其中有点糟糕的是，saveCustomer 函数会认为你传入的参数都是有效的，因此会依次把每个字段都做更新，如果其他参数传入的是空，可能就会对其他数据造成影响。</p>
<p>再来看一个实际开发中更可能遇到的场景：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302238308.png" alt="image-20211230223854227"></p>
<!-- raw HTML omitted -->
<p>这里的 saveCustomer  函数逻辑将每个字段做了是否为空的校验，如果不为空意味着你想要更新这个字段。</p>
<p>更糟糕的是，业务逻辑被埋没在存储业务之中了，因此这种代码可能导致你在开发过程中“失忆”的，在对某段函数迭代了一段时间以后，本身这个业务逻辑到底要做哪些需求的，完全看不出来了。</p>
<p>DDD 社区提供了一个解决的思路：定义 Customer Repo，代码如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302247022.png" alt="image-20211230224749949"></p>
<!-- raw HTML omitted -->
<p>首先定义了一个叫做 Customer 的 Repo，然后将之后想要完成的业务需求直接改成了非常具体的函数名字。比如说想要修改用户的地址，就直接加一个功能叫做 relocateTo；如果想要修改电话号码，就添加函数 changeHomeTelephone。这便是整个 Customer Repo 所拥有的的方法集。我们通过阅读当前方法集的名字就能够明白当前的业务需求是什么。</p>
<p>在此基础上，相关的 Repo 实现都相对简单多了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302247687.png" alt="image-20211230224725610"></p>
<!-- raw HTML omitted -->
<p>整个 Repo 的实现比较简单，里面拆分成了几个小的函数。主流程中，根据不同的用例选择执行不同的对象函数，而不是用数据建模，将所有处理集中在同一个函数里。</p>
<h1 id="solid">SOLID</h1>
<p>SOLID 是指面向对象设计 5 大重要原则的首字母缩写，当我们设计类和模块时，遵守 SOLID 原则可以让软件更加健壮和稳定。</p>
<p>今天我们重点了解依赖倒置原则 DIP（Dependency Inversin Principle），它的意思是说高层模块不应该依赖低层模块，相反，他们应该依赖抽象类或者接口。这里有一段根据 DIP 原则修改前的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">// business/order.go
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e"></span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;dao&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createOreder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">someData</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>    <span style="color:#a6e22e">dao</span>.<span style="color:#a6e22e">SaveOrder</span>(<span style="color:#a6e22e">data</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#75715e">// dao/mysql.go
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SaveOrder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">data</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>    <span style="color:#75715e">// do the mysql job
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#75715e"></span>}
</code></pre></div><p>而使用依赖导致原则修改后的代码，如果最初我们的逻辑是 controller → logic → dao，就能改变为 dao → logic → contorller，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">// business/order.go
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e">// import &#34;dao&#34; 不再依赖 dao 层
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">OrderRepo</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">repoInstance</span>{}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createOrder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">someData</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>    <span style="color:#a6e22e">repoInstance</span>.<span style="color:#a6e22e">SaveOrder</span>(<span style="color:#a6e22e">data</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">OrderRepo</span> <span style="color:#66d9ef">interface</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>    <span style="color:#a6e22e">SaveOrder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">data</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span style="color:#75715e">// dao/mysql.go
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SaveOrder</span>(<span style="color:#f92672">...</span><span style="color:#a6e22e">data</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>    <span style="color:#75715e">// do the mysql job
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span style="color:#75715e"></span>}
</code></pre></div><p>之前的代码中，业务依赖着 dao，必须导入才能使用。现在我们不让业务依赖具体的某一个存储实现，那么我们就需要把 dao 的操作变为接口。</p>
<p>改造后的代码中，我们定义了一个 repoInstance 来实现接口 OrderRepo，这个接口只有 SaveOrder 的操作。由于 Interface 的定义是和业务代码放在一起的，所以都在同一个文件里，不需要再去导入。并且我们能够在 dao 中实现业务模块中定义的接口。</p>
<p>通过这种改造，我们能够将整个依赖关系从业务到 dao，改变为从 dao 到业务，将逻辑关系反转了。</p>
<p>以下再用一张图来解释我说的话：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112302303317.png" alt="image-20211230230345237"></p>
<!-- raw HTML omitted -->
<p>可以看到，无论是入口还是存储层，都会依赖业务逻辑。而如果将业务逻辑放在最上层，意味着业务逻辑可以不依赖任何的库，最终外部任何库的变化都不会导致业务逻辑发生任何变化。</p>
<p>OK，今天讲的只是业务逻辑转化的概念，下期文章继续聊聊各个社区的大佬是如何根据这些原则去写代码的。</p>

  

  </div>
</article>
  
  













  
  
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
            repo= "JupiterXue/BlogComment"
            issue-term="title"
            theme="github-light"
    crossorigin="anonymous"
    async>
    </script>
  </div>
  




    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2022  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/go-to-top">Go 语言系列</a></li>
         
        <li><a href="/posts">杂谈</a></li>
         
        <li><a href="/tags">标签</a></li>
         
        <li><a href="/about">关于我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
