<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Go 翻山越岭——并发数据结构（3） | 木夜星空的个人博客</title>
  <link rel = 'canonical' href = 'https://jupiterxue.github.io/go-to-top/day33-sync_structure_3/'>
  <meta name="description" content="东方不亮木星亮，黑了白昼有星空">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Go 翻山越岭——并发数据结构（3）" />
<meta property="og:description" content="一个优质的程序、优秀的设计不是凭空产生的，而是经过由简至精，不断迭代产生出来的。在上期文章中，我们了解了 Go 语言中的信号量 semaphore 和互斥锁 sync.Mutex，在此基础上我们还可以实现更加复杂的锁。
sync.RWMutex 读写锁 (sync.RWMutex)，可以来看下它的数据结构和运作逻辑：
可以看到它的第一个结构叫做 w 其实就是互斥锁 sync.Mutex。在这里的作用是为了挡住大部分写操作的 Goroutine，只让第一个进来的能够和其他的读操作的 Goroutine 去做竞争。
现在有一个写 Goroutine writer 进来了，如果还有其他 reader 在做操作，就会把这个进入的挂载在 writerSem 后面的 sudog。如果后面来了新的 writer，前面的 writer 还没有退出的话，那么新的 writer 就需要挂载在之前的互斥锁 sync.Mutex 上的 sudog 后面。同样的 writer 和 reader 也会在不同阶段去做些竞争和唤醒的操作。
一旦有一个 writer 进入并且调用了 lock，那么就会在 writerSem 后面挂载一个阻塞的 sudog，并且把 readerCount 减去一个最大的值，即图中 1 左移 30 的值，最终让 readerCount 变为负数。当 readerCount 变为负数时，reader 在执行 Runlcok 的操作以后，会发现当前已经变为特殊模式了，所以就会后来进来新来的 reader，这些新的 reader 会去调用 Rlock，那么就会挂载在 readerSem 队列中。readerSem 其实也是一个信号量，最终会对应一个等待队列，并且最后的结构 readerWait 的数量其实是和这个等待队列的数量是对应的。
小结一下，一般正常的操作流程是这样的：如果没有 writer 在等待，那么 reader 可以直接去修改 readerCount。readerCount属于正值，readerWait 为 0。一旦有个 writer 阻塞了，那么 readerCount 变为负，readerWait 数量就和 readerSem 队列中等待的数量一致。最终之前来的 reader 它们都执行完之后，会发现 readerCount 是个特殊的值，然后就会把 writer 唤醒，让 writer 去执行它的逻辑。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jupiterxue.github.io/go-to-top/day33-sync_structure_3/" /><meta property="article:section" content="go-to-top" />
<meta property="article:published_time" content="2021-12-01T13:46:40+08:00" />
<meta property="article:modified_time" content="2021-12-01T13:46:40+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 翻山越岭——并发数据结构（3）"/>
<meta name="twitter:description" content="一个优质的程序、优秀的设计不是凭空产生的，而是经过由简至精，不断迭代产生出来的。在上期文章中，我们了解了 Go 语言中的信号量 semaphore 和互斥锁 sync.Mutex，在此基础上我们还可以实现更加复杂的锁。
sync.RWMutex 读写锁 (sync.RWMutex)，可以来看下它的数据结构和运作逻辑：
可以看到它的第一个结构叫做 w 其实就是互斥锁 sync.Mutex。在这里的作用是为了挡住大部分写操作的 Goroutine，只让第一个进来的能够和其他的读操作的 Goroutine 去做竞争。
现在有一个写 Goroutine writer 进来了，如果还有其他 reader 在做操作，就会把这个进入的挂载在 writerSem 后面的 sudog。如果后面来了新的 writer，前面的 writer 还没有退出的话，那么新的 writer 就需要挂载在之前的互斥锁 sync.Mutex 上的 sudog 后面。同样的 writer 和 reader 也会在不同阶段去做些竞争和唤醒的操作。
一旦有一个 writer 进入并且调用了 lock，那么就会在 writerSem 后面挂载一个阻塞的 sudog，并且把 readerCount 减去一个最大的值，即图中 1 左移 30 的值，最终让 readerCount 变为负数。当 readerCount 变为负数时，reader 在执行 Runlcok 的操作以后，会发现当前已经变为特殊模式了，所以就会后来进来新来的 reader，这些新的 reader 会去调用 Rlock，那么就会挂载在 readerSem 队列中。readerSem 其实也是一个信号量，最终会对应一个等待队列，并且最后的结构 readerWait 的数量其实是和这个等待队列的数量是对应的。
小结一下，一般正常的操作流程是这样的：如果没有 writer 在等待，那么 reader 可以直接去修改 readerCount。readerCount属于正值，readerWait 为 0。一旦有个 writer 阻塞了，那么 readerCount 变为负，readerWait 数量就和 readerSem 队列中等待的数量一致。最终之前来的 reader 它们都执行完之后，会发现 readerCount 是个特殊的值，然后就会把 writer 唤醒，让 writer 去执行它的逻辑。"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jupiterxue.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxxx"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5QVC54HS9T');
</script>


  
<link rel="icon" type="image/png" href="https://jupiterxue.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jupiterxue.github.io/">
  
    <div id="logo" style="background-image: url(https://jupiterxue.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>木夜星空的个人博客</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/go-to-top">Go 语言系列</a></li>
      
        <li><a href="/posts">杂谈</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于我</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>一个优质的程序、优秀的设计不是凭空产生的，而是经过由简至精，不断迭代产生出来的。在上期文章中，我们了解了 Go 语言中的信号量 semaphore 和互斥锁 sync.Mutex，在此基础上我们还可以实现更加复杂的锁。</p>
<h2 id="syncrwmutex">sync.RWMutex</h2>
<p>读写锁 (<strong>sync.RWMutex</strong>)，可以来看下它的数据结构和运作逻辑：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112012248318.png" alt="sync.RWMutex 结构 (2)"></p>
<!-- raw HTML omitted -->
<p>可以看到它的第一个结构叫做 w 其实就是互斥锁 sync.Mutex。在这里的作用是为了挡住大部分写操作的 Goroutine，只让第一个进来的能够和其他的读操作的 Goroutine 去做竞争。</p>
<p>现在有一个写 Goroutine writer 进来了，如果还有其他 reader 在做操作，就会把这个进入的挂载在 writerSem 后面的 sudog。如果后面来了新的 writer，前面的 writer 还没有退出的话，那么新的 writer 就需要挂载在之前的互斥锁 sync.Mutex 上的 sudog 后面。同样的 writer 和 reader 也会在不同阶段去做些竞争和唤醒的操作。</p>
<p>一旦有一个 writer 进入并且调用了 lock，那么就会在 writerSem 后面挂载一个阻塞的 sudog，并且把 readerCount 减去一个最大的值，即图中 1 左移 30 的值，最终让 readerCount 变为负数。当 readerCount 变为负数时，reader 在执行 Runlcok 的操作以后，会发现当前已经变为特殊模式了，所以就会后来进来新来的 reader，这些新的 reader  会去调用 Rlock，那么就会挂载在 readerSem 队列中。readerSem 其实也是一个信号量，最终会对应一个等待队列，并且最后的结构 readerWait 的数量其实是和这个等待队列的数量是对应的。</p>
<p>小结一下，一般正常的操作流程是这样的：如果没有 writer 在等待，那么 reader 可以直接去修改 readerCount。readerCount属于正值，readerWait 为 0。一旦有个 writer 阻塞了，那么 readerCount 变为负，readerWait 数量就和 readerSem 队列中等待的数量一致。最终之前来的 reader 它们都执行完之后，会发现 readerCount 是个特殊的值，然后就会把 writer 唤醒，让 writer 去执行它的逻辑。</p>
<h2 id="syncmap">sync.Map</h2>
<p>并发安全的 map 结构 sync.Map，这个结构稍微复杂，不过一点点拆解地去理解，就不是那么困难了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112012248307.png" alt="sync.Map 结构与逻辑 (2)"></p>
<!-- raw HTML omitted -->
<p>在 sync.Map 结构中，mu 表示 Mutex，可以不用在意。其余分为了两个结构一个是 read，一个是dirty，还有一个计数器 misses。</p>
<p>read 表示优先去读的 map，即图中的 m。amended 结构表示当前 dirty 结构中是否有 read 没有包含的数据，如果 amended 是 true，那么就表示 dirty 中是有值的。而 misses 会在 read 没有值的情况下去 dirty 中去找值，并且每次发生这种情况的时候都需要对这个 misses + 1。一旦这个 misses 加到了 dirty 的长度大小时，说明当前需要将 dirty 和 read 的值做交换，即把 dirty 变为 read，把 dirty 置为 nil。</p>
<p>这里有个模拟的代码片段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Map</span>{}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#ae81ff">1</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#e6db74">&#34;y&#34;</span>, <span style="color:#ae81ff">2</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#e6db74">&#34;z&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#e6db74">&#34;x&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#e6db74">&#34;y&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Delete</span>(<span style="color:#e6db74">&#34;x&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#e6db74">&#34;z&#34;</span>, <span style="color:#ae81ff">3</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9</span><span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#ae81ff">10</span>)
</code></pre></div><ul>
<li>
<p>第一步初始化 sync.Map，这时候 misses 中的值为 0，amended 是 false，并且 m 和 dirty 两个 map 中没有值</p>
</li>
<li>
<p>第二步向其中存入一对键值 &ldquo;x&rdquo; 为 1，即 dirty 中的 map 存入了 key 为 &ldquo;x&rdquo;，val 为 1 的值。由于 dirty 有了 read 中没有的值，所以 amended 为 true。</p>
</li>
<li>
<p>第三步继续存入一对键值，dirty 会有了第二组值，key 为 &ldquo;y&rdquo;, val 为 1。</p>
</li>
<li>
<p>第四步读取 &ldquo;z&rdquo;，这个键既不在 read 也不再 dirty 中，所以不会去修改 misses。</p>
</li>
<li>
<p>第五步读取 &ldquo;x&rdquo;，是去读取 read 中的键，而这个键存放在 dirty 中，所以需要把 misses 改为 + 1，说明在读期间发生了一次 miss。</p>
</li>
<li>
<p>第六步继续读取 &ldquo;y&rdquo;，这个键也存放在 dirty中，misses 继续 + 1。这时候因为 misses 的大小和 dirty 的长度一样，dirty 就会和 read 交换，read 存放 dirty 中的值，misses 还原为 0，dirty 置为空。</p>
</li>
<li>
<p>第七步删除键&quot;x&quot;中的值，会将 read 中的 map 存放的键 &ldquo;x&rdquo; 做一个修改而不会真正地删除，而是置为 <!-- raw HTML omitted --> 的值。</p>
</li>
<li>
<p>第八步继续存键值对 &ldquo;z&rdquo; : 3，底层会将 read 中所有键值对都拷贝到 dirty 中（被修改为 expunged 的键值对不会被拷贝），并且会把新的值写入 dirty 中。</p>
</li>
<li>
<p>第九步再存一对键值对 &ldquo;x&rdquo;: 10，会将 read 中已有的键 &ldquo;x&rdquo; 的值修改为 10，向 dirty 中存入键 key 为 &ldquo;x&rdquo;，值 val 为 10。这里有点神奇，read 和 dirty 内部都有相同的键 key，不过它们的 val 值都是指向的同一个地方</p>
</li>
</ul>
<p>整个 read 结构中读和写都是不需要加锁的。dirty 中的写操作要比正常的 map 操作多了非常多的流程，而且要加锁。所以说 sync.Map 是在写少读多的场景下比我们标准的 map 速度要快很多的。</p>
<h2 id="syncwaitgroup">sync.Waitgroup</h2>
<p>最后一个并发结构，比较容易理解，关键只有一个 state 字段，还是来看下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JupiterXue/PictureBed/BlogImg/202112012347608.png" alt="sync.Waitgroup"></p>
<!-- raw HTML omitted -->
<p>它将 state 分为 4 bytes 一个组，中间是个 counter 计数器，waiter 是指我的应用代码在多少个 Goroutine 里面执行了 WG.Wait，如果有一个就 + 1（平时常见的也是1）。右边是信号量 sema 结构，一旦有程序发生了阻塞，wait 的信号量就会挂载在这个后面，成为一个链表。最后，如果 counter 减少到 0 时，就会唤醒所有 sema 上阻塞的 sudog。</p>
<p>OK，以上就将 Go 语言中大部分 sync 库中数据结构都简单学习了一遍，串起来了。下期文章将会讲解一些并发编程模式下的例子，敬请期待。</p>

  

  </div>
</article>
  
  













  
  
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
            repo= "JupiterXue/BlogComment"
            issue-term="title"
            theme="github-light"
    crossorigin="anonymous"
    async>
    </script>
  </div>
  




    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  JupiterXue 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/go-to-top">Go 语言系列</a></li>
         
        <li><a href="/posts">杂谈</a></li>
         
        <li><a href="/tags">标签</a></li>
         
        <li><a href="/about">关于我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
