<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>经典书 on 木夜星空的个人博客</title>
    <link>https://jupiterxue.github.io/tags/%E7%BB%8F%E5%85%B8%E4%B9%A6/</link>
    <description>Recent content in 经典书 on 木夜星空的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>JupiterXue</copyright>
    <lastBuildDate>Sat, 11 Sep 2021 23:02:05 +0800</lastBuildDate><atom:link href="https://jupiterxue.github.io/tags/%E7%BB%8F%E5%85%B8%E4%B9%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>读经典《DDIA》-第二章</title>
      <link>https://jupiterxue.github.io/posts/2021-09-11-ddia-chapter2/</link>
      <pubDate>Sat, 11 Sep 2021 23:02:05 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-11-ddia-chapter2/</guid>
      <description>已经看完第二章《DDIA》，说下我是怎么抄书的，以及我有什么收获。
0.什么？抄书？没错，我是边抄边写笔记。因为我就和你一样，看不进书（当然你比我更自律点）。开玩笑啦
1.当你不想看书的时候，就抄书；当你抄书抄到不想抄了，就想看了。虽然这句话被 S 老师作为段子来传颂，但我看到了有人抄过化学，有人抄过高数。我没有这种经历，也想亲自去实践一下到底有怎样的魔力。其次，我认为好的书是浅显易懂，深入浅出的，值得揣摩。
2.求其上者得其中，求其中者得其下，求其下着无所得。刚开始抄书是一件有点兴奋的事，因为抄这个动作是比较轻松的，因为理想中这是不怎么动脑子的。实际上由于你的专注，你会不由自主地关注作者在说些什么（虽然有时也会走神不知道作者在说什么）。并且由于抄书，你会开始对作者某个词语进行或多或少的思考。而抄书的困难也正是源于此，认真看和思绪漫游会导致你的阅读速度极大地降低，尤其在你发现抄了一两个小时，连一半都没有的时候，心情是有点绝望的，好在，你还可以明天抄嘛：） giao！
3.实事求是，实地考察。抄书中，你会发现作者写的话有多少冗余、多少用词不当。尤其我看的这本书原版是英文，翻译过来连句法还是英语的语法，根本不符合中文逻辑。所以我会将这句话进行汉译汉，转化为我自己能够理解的。大家都认为看技术不要看中文，因为中文和蹩脚，是的。但我再补充一句，你可以自己把蹩脚化为流畅。
4.简明扼要，提高速度。一直这么慢的抄写肯定不行，我在抄的过程中也逐步掌握了一些技巧：着重摘录抽象句式和实用句式，代码复制（看代码其实是最直接和方便的），详细参数说明忽略，图能动就不抄，不能动就用文字描述，不能用文字就截图、先摘录一二级标题，然后一个个攻坚（会有点成就感）。
5.暴力破解，巨无事细。抄书意味着会对每个地方都看一遍，找出是否有价值的地方。所以会对每个文字做一次简单的“有什么有用，是否摘要”的编码动作，这不同于看书。看书的时候，我很有可能是在想“这个不重要，过”。所以抄一遍下来，老师如果问哪一页哪个知识点，虽然你答不上来在哪里，但你知道，我确实看过，而不是看，过了。
6.建立根据地，逐步发展。即便中文的技术书读起来不是很顺畅，但大体意思作者是能够把握。最重要的是，当我看完了中文，我会对原书作者讲了什么内容有个大概的把握。所以看起英文来就更加流畅。
最后，这篇文章不是给看中文技术书洗白，只是想表达我在参与过程中的收获和感受。按照成熟的技术方法来说，看书、看文档还是以官方为准，以原版语言为准。地道的语言和没有信息损失的一手材料，才是好的学习资料。毕竟，高级食材，我们都吃原材料。
和小伙伴讨论章节内容，一个意外收获：
  我说：几种 Datalog 方法都没有听过，没有见过。好像是在说图结构有哪些处理方式，怎么表示更简洁、更高效
Helios 回复：主要还是场景不一样。
场景说得好，看完就局限在代码层面，一下又跳了出来。
  第二章笔记 第二章
数据模型在软件开发中最重要。不仅影响软件编写方式，还影响解题思路。
多数应用用使用层层叠加的数据模型构建，关键问题：如何用低一层数据模型表示。例如：
\1. 用对象或数据结构以及 API 来建模现实世界。
\2. 用数据模式表示存储结构。如 JSON、XML、数据库表、图，
\3. 用内存、磁盘或网络字节表示 JSON/XML/关系/图数据，进而来查询、搜索、操作。
\4. 在更低层次，用电流、光脉冲、磁场或其他东西表示字节。
复杂应用程序有更多中间层，如 API 的 API。但思想仍一样：提供明确数据模型来因此更低层次复杂性。这个抽象使得不同人员能够参与协作。
选择一个适合数据模型非常重要。因为种类很多，易用但不易支持，可操作但表现差，数据转化有的自然有的麻烦。
关系模型与文档模型
最著名数据模型——SQL。1970年 Edgar Codd 提出关系模型：数据为关系，关系是元素的无序集合。
关系数据库起源于商业数据处理，今天来看显得很平常：典型事物处理。
&amp;gt; 如：将销售或银行交易，航空公司预订，库存管理信息记录在库）和批处理（客户发票，工资单，报告）
并且当时数据库迫使开发者必须考虑数据库内部的数据表示形式。关系模型解决的是在实现细节隐藏在更简洁的接口之后。
网络模型和分词模型在 70、80 年代的主要选择，但关系模型随后占据主导。对象数据库在 90 年代由盛而衰。XML 数据出现于 21世纪初。
2010 年，NoSQL 开始萌芽，虽名字没有涉及任何技术，最初只是 Twitter 标签，2009 年非关系数据库开源会上这个术语的出现，迅速得到了传播。NoSQL 被重新解释为不仅是 SQL（Not Only SQL），NoSQL 流行的几个因素：</description>
    </item>
    
    <item>
      <title>读经典《DDIA》-第一章</title>
      <link>https://jupiterxue.github.io/posts/2021-09-08-ddia-chapter1/</link>
      <pubDate>Wed, 08 Sep 2021 23:25:30 +0800</pubDate>
      
      <guid>https://jupiterxue.github.io/posts/2021-09-08-ddia-chapter1/</guid>
      <description>算是等了好久，终于有机会来读这本书《Designing Data Intensive Applications》，中文名《设计数据密集型应用》，我们一般简称《DDIA》或者猪书（因为书的封面是一头野猪，Hog Riderrrrr～！）。读完这本书第一章，我也想极力向推荐给计算机和互联网行业做后端和服务端的同学。阅读背景 最初了解这本书是在曹大（曹春晖）的第一堂课上。曹大说自己看了那么多书，只有这一本是最好的，也推荐给大家（当时听完就有点热血沸腾）。后来我还发现，draveness 大佬在它的《程序员可能必读书单推荐（一）》https://draveness.me/books-1/ 中最后一本也提到了此神书。再后来，又去豆瓣看了看，中英文都是 9.7 分：
简单介绍一下，读《DDIA》能够 帮助我们建立一个分布式系统的全局概念，但还需要根据自己所在行业、所处业务和所面对的需求。前面一些章节和 rpc 有关系，中间一些和存储关系比较大，后面将大数据和流式计算。内容比较全，看完就知道分布式系统有哪些问题。
一个人可以走得很快，而一群人能够走得很远。读这本书，其实我是参与了一个小组的 github 读书项目，如果你感兴趣也可以联系我，我们一起参与这次读书之旅。
好，话不多说，开始卷！（以下为我简明扼要摘录的笔记，可以快速浏览）
第一章笔记 为什么要设计 现今很多应用程序都是 数据密集型（data-intensive） 的，而非 计算密集型（compute-intensive） 的。
CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。
数据密集型应用：
- 存储数据
- 缓存
- 索引
- 流处理
- 批处理
看上去平淡无奇是因为数据系统在抽象层面做得非常成功。工程师常常直接拿来用，而不是自己去做开发，因为数据库已经足够完美。
然而现实中还有各种不同的需求：多种缓存，多级搜索。重要的是有必要先弄清楚最适合当前业务的工具和方法。当单个工具已经解决不了我们的问题时，组合使用也有些难度。因此本书在探索如何设计数据密集应用的方法，以实现可靠、可伸缩、可维护的数据系统。
数据系统的思考 按我们的常识，为认为数据库、消息队列、缓存这些工具都是有差异的，但我们还是归类为 数据系统当中。虽然新出现了许多数据存储工具和数据处理工具，但类别之间的界限越来越模糊，比如：数据存储可以作为消息队列（Redis），消息队列带有类似数据库的持久保证（Apache Kafka）。
当单个工具不足以满足所有数据处理和存储需求，就需要将总体工作拆分成一系列能够被单个工具高效完成，并且通过应用代码缝合起来。如缓存（Memcached）和全文搜索（ES）结合将主数据库剥离，由应用代码来让缓存或索引和主数据库保持同步。
一个可能的组合使用多个组件的数据系统架构
多个工具组合提供服务，服务的接口或应用程序编程接口 API 会向客户隐藏实现细节。
设计 DIA 会遇到问题：系统故障，如何保证数据正确性和完整性？系统退化降级，如何给客户提供始终如一的良好性能。负载增加，如何扩容？什么样的 API 是好的？
影响设计的因素：参与者技能和经验、历史遗留问题、系统路径依赖、交付时限、公司风险容忍度、监管约束。
本书重点讨论：
- 可靠性。在 adversity 中（包括：硬件、软件、人为 故障或错误）仍可以正常工作。
- 可伸缩性。合理应对系统增长（数据量，流量，复杂性）
- 可维护性。不同参与者，在不同生命周期都能高效地在系统上工作（适应新的应用场景）。
可靠性 常见期望：
- 符合用户期望的功能
- 允许出错，还能正常使用软件</description>
    </item>
    
  </channel>
</rss>
